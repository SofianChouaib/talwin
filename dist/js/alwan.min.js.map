{"version":3,"file":"js/alwan.min.js","mappings":"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","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/constants/classnames.js","webpack://Alwan/./src/constants/globals.js","webpack://Alwan/./src/utils/string.js","webpack://Alwan/./src/core/events/binder.js","webpack://Alwan/./src/utils/object.js","webpack://Alwan/./src/utils/util.js","webpack://Alwan/./src/utils/dom.js","webpack://Alwan/./src/utils/number.js","webpack://Alwan/./src/lib/popper.js","webpack://Alwan/./src/components/App.js","webpack://Alwan/./src/assets/svg.js","webpack://Alwan/./src/colors/stringify.js","webpack://Alwan/./src/colors/converter.js","webpack://Alwan/./src/colors/parser.js","webpack://Alwan/./src/core/component.js","webpack://Alwan/./src/components/Palette.js","webpack://Alwan/./src/components/Utility.js","webpack://Alwan/./src/components/Sliders.js","webpack://Alwan/./src/components/Inputs.js","webpack://Alwan/./src/components/Swatches.js","webpack://Alwan/./src/core/color.js","webpack://Alwan/./src/core/init.js","webpack://Alwan/./src/constants/defaults.js","webpack://Alwan/./src/index.js","webpack://Alwan/./src/core/events/dispatcher.js","webpack://Alwan/./src/components/reference.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ALWAN_CLASSNAME = 'alwan';\nexport const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;\nexport const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;\nexport const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;\nexport const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;\nexport const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;\nexport const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;\nexport const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;\nexport const SLIDERS_CLASSNAME = `${ALWAN_CLASSNAME}__sliders`;\nexport const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--hue`;\nexport const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--alpha`;\nexport const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;\nexport const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;\nexport const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;\nexport const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;\nexport const PRESET_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__preset-button`;\nexport const OVERLAY_CLASSNAME = `${ALWAN_CLASSNAME}__overlay`;\nexport const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__collapse-button`;\n\nexport const POPUP_CLASSNAME = `${ALWAN_CLASSNAME}--popup`;\nexport const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;\nexport const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;","export const ROOT = document;\nexport const HTML = ROOT.documentElement;\n\nexport const BUTTON = 'button';\n\nexport const OPEN = 'open';\nexport const CLOSE = 'close';\nexport const COLOR = 'color';\nexport const CLICK = 'click';\nexport const POINTER_DOWN = 'pointerdown';\nexport const POINTER_MOVE = 'pointermove';\nexport const POINTER_UP = 'pointerup';\nexport const SCROLL = 'scroll';\nexport const RESIZE = 'resize';\nexport const KEY_DOWN = 'keydown';\nexport const INPUT = 'input';\nexport const CHANGE = 'change';\nexport const FOCUS_OUT = 'focusout';\nexport const FOCUS_IN = 'focusin';\nexport const MOUSE_OUT = 'mouseout';\n\nexport const HEX_FORMAT = 'hex';\nexport const RGB_FORMAT = 'rgb';\nexport const HSL_FORMAT = 'hsl';\nexport const HSV_FORMAT = 'hsv';\n\nexport const TAB = 'Tab';\nexport const ENTER = 'Enter';\nexport const ESCAPE = 'Escape';\n\nexport const COLOR_PROPERTY = '--lw-' + COLOR;\n\n// Picker supported color formats.\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\nexport const INSERT_BEFORE_FIRST_CHILD = 'afterbegin';","/**\n * Checks if a value is a string.\n *\n * @param {unknown} value - Value to check.\n * @returns {boolean} Whether value is a string.\n */\nexport const isString = (value) => {\n    return typeof value === 'string';\n}\n\n/**\n * Trims a string.\n *\n * @param {string} str - String to trim.\n * @returns {string} trimmed string\n */\nexport const trimString = (str) => {\n    return str.trim();\n}","import { isString } from \"../../utils/string\";\n\n/**\n * Adds event listeners to an element and stores its data.\n *\n * @returns {object}\n */\nexport const Binder = () => {\n    /**\n     * Stores event listeners data.\n     */\n    let eventListenersData = [];\n\n    /**\n     * Adds/Removes event listeners.\n     *\n     * @param {EventTarget} eventTarget - Event target.\n     * @param {array<string>} events - Events (event type)\n     * @param {Function} handler - Event handler.\n     * @param {boolean} toggler - add/remove event listener.\n     */\n    let toggleEventListener = (eventTarget, events, handler, toggler = true) => {\n        events.forEach(event => {\n            eventTarget[`${toggler?`add`:`remove`}EventListener`](event, handler);\n        });\n    }\n\n    return {\n        /**\n         * binds an event listener to an element.\n         *\n         * @param {EventTarget} eventTarget - Event target.\n         * @param {string|Array<string>} events - Event(s)\n         * @param {Function} handler - Event handler.\n         */\n        _bind(eventTarget, events, handler) {\n            if (isString(events)) {\n                events = [events];\n            }\n            eventListenersData.push([eventTarget, events, handler]);\n            toggleEventListener(eventTarget, events, handler);\n        },\n\n        /**\n         * Removes all event listeners and clears their data.\n         */\n        _unbindAll() {\n            eventListenersData.forEach(([target, events, handler]) => {\n                toggleEventListener(target, events, handler, false);\n            });\n            eventListenersData = [];\n        }\n    }\n}","export const { keys, assign, setPrototypeOf, prototype } = Object;\n\n/**\n * Iterate in an object.\n * If any callback function return a value different then null or undefined,\n * then stop iteration and return that value.\n *\n * @param {Object} object - Any object.\n * @param {Function} fn - A Callback function.\n * @returns {any}\n */\nexport const objectIterator = (object, fn) => {\n    let props = keys(object);\n    for (const prop of props) {\n       fn(object[prop], prop);\n    }\n}\n\n/**\n * Merges two or more objects together into the target object.\n *\n * @param {Object} target - Object that will receive the new properties.\n * @param  {...Object} sources - Objects containing additional properties to merge in.\n * @returns {Object}\n */\nexport const merge = (target, ...sources) => {\n    return assign(target, ...sources);\n}\n\n/**\n * Checks if obj1 keys and values equal to obj2's keys and values.\n *\n * @param {Object} obj1 - Any object.\n * @param {Object} obj2 - Any object.\n * @returns {Boolean}\n */\nexport const isEqual = (obj1, obj2) => {\n    if (obj1 && obj2) {\n        return keys(obj1).every(key => obj1[key] === obj2[key]);\n    }\n    return false;\n}","/**\n * Checks if a value is not undefined or null.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isset = value => value != null;","import { BUTTON_CLASSNAME, SLIDER_CLASSNAME } from \"../constants/classnames\";\nimport { BUTTON, HTML, INPUT, ROOT } from \"../constants/globals\";\nimport { merge, objectIterator } from \"./object\";\nimport { isString, trimString } from \"./string\";\nimport { isset } from \"./util\";\n\n/**\n * Gets the body element.\n *\n * @returns Document's body.\n */\nexport const body = () => ROOT.body;\n\n/**\n * Gets elements.\n *\n * @param {string|Element} reference - CSS selector or a HTML element.\n * @param {Document|Element} context - Element to search from.\n * @param {boolean} all - Select all elements.\n * @returns {null|Element|NodeList}\n */\nexport const getElement = (reference, context = ROOT, all = false) => {\n    if (isString(reference) && trimString(reference)) {\n        return context[`querySelector${ all ? 'All' : ''}`](reference);\n    }\n\n    if (reference instanceof Element) {\n        return reference;\n    }\n\n    return null;\n}\n\n/**\n * Inserts an element relative to another element (target element).\n *\n * @param {Element} element - The element to be inserted.\n * @param {Element} targetElement - Element used as a reference.\n * @param {string} where - Insert position relative to the targetElement.\n * @returns {Element|undefined} - The inserted element.\n */\nexport const insertElement = (element, targetElement, where) => {\n    if (element && targetElement) {\n        return targetElement.insertAdjacentElement(where || 'beforeend', element);\n    }\n}\n\n/**\n * Sets element's inner html.\n *\n * @param {Element} element - An HTML element.\n * @param {string} html - HTML string.\n */\nexport const setHTML = (element, html) => {\n    element.innerHTML = html;\n}\n\n/**\n * Creates a new HTML Element.\n *\n * @param {string} tagName - Element tag name.\n * @param {string} className - Element class name.\n * @param {Element} targetElement - Insert the new element relative to this element using position.\n * @param {object} details - Element details (attributes + Initial content).\n * @param {InsertPosition} insertPosition - Insert position.\n * @returns {Element} The new created element.\n */\nexport const createElement = (tagName, className, targetElement, details, insertPosition) => {\n    const element = ROOT.createElement(tagName || 'div');\n\n    if (className) {\n        element.className = className;\n    }\n\n    objectIterator(details || {}, (value, name) => {\n        if (name === 'html') {\n            setHTML(element, value);\n        } else if (value) {\n            element.setAttribute(name, value);\n        }\n    });\n\n    if (targetElement) {\n        insertElement(element, targetElement, insertPosition);\n    }\n\n    return element;\n}\n\n/**\n * Gets element's bounding rect.\n *\n * @param {Document|Element} element - Element.\n * @returns {DOMRect}\n */\nexport const getBounds = (element) => {\n    if (element === ROOT) {\n        return {\n            x: 0,\n            y: 0,\n            top: 0,\n            left: 0,\n            right: HTML.clientWidth,\n            bottom: HTML.clientHeight\n        }\n    }\n    return element.getBoundingClientRect();\n}\n\n/**\n * Gets an element parent.\n *\n * @param {Element} element - Element.\n * @returns {Element|null} - The parent element.\n */\nexport const parent = (element) => {\n    return element.parentElement;\n}\n\n/**\n * Replaces an element in the DOM with another element.\n *\n * @param {Element} newElement - Element to replace another element.\n * @param {Element} oldElement - Element to be replaced by the newElement.\n * @returns {Element} The new element.\n */\nexport const replaceElement = (newElement, oldElement) => {\n    parent(oldElement).replaceChild(newElement, oldElement);\n    return newElement;\n}\n\n/**\n * Remove element from the document.\n *\n * @param {Element} element - Element to remove.\n */\nexport const removeElement = (element) => {\n    if (element) {\n        element.remove();\n    }\n}\n\n/**\n * Gets scrollable ancestor of an element (body element is not included).\n *\n * @param {Element} element - Element.\n * @param {array<Element|Document>} scrollables - Array of scrollable Elements.\n * @returns {array<Element|Document>}\n */\nexport const getScrollableAncestors = (element, scrollables = [ROOT]) => {\n    element = parent(element);\n    if (! element || element === ROOT.body) {\n        return scrollables;\n    }\n\n    if (/auto|scroll/.test(getComputedStyle(element).overflow)) {\n        scrollables.push(element);\n    }\n\n    return getScrollableAncestors(element, scrollables);\n}\n\n\n\n/**\n * Check if an element is visible in the viewport of all scrollable elements.\n *\n * @param {Element} element - Element.\n * @param {Array} scrollables - Scrollable elements.\n * @returns {boolean}\n */\nexport const isInViewport = (element, scrollables) => {\n    return scrollables.every(scrollable => {\n        let { x: elementX, y: elementY, bottom: elementBottom, right: elementRight } = getBounds(element);\n        let { x: scrollableX, y: scrollableY, bottom: scrollableBottom, right: scrollableRight } = getBounds(scrollable);\n\n        return elementY < scrollableBottom && elementBottom > scrollableY && elementX < scrollableRight && elementRight > scrollableX;\n    });\n}\n\n\n/**\n * Sets a CSS custom property.\n *\n * @param {HTMLElement} el  - Element to set its custom property.\n * @param {string} property - Property name.\n * @param {string} value    - Property value.\n */\nexport const setCustomProperty = (element, property, value) => {\n    if (element && isset(value)) {\n        element.style.setProperty(property, value);\n    }\n}\n\n\n/**\n * Hides/Shows element.\n * \n * @param {Element} element - Element to show/hide.\n * @param {boolean} toggler - Whether to show (true) or hide the element.\n */\nexport const toggleVisibility = (element, toggler = true) => {\n    element.style.display = toggler ? '' : 'none';\n}\n\n/**\n * Adds/Removes a class to/from an based on a boolean variable.\n *\n * @param {Element} element - Element.\n * @param {string} token - Class name.\n * @param {boolean} toggler - Whether to add (true) or remove a class.\n */\nexport const toggleClassName = (element, token, toggler) => {\n    if (token) {\n        element.classList.toggle(token, toggler);\n    }\n}\n\n/**\n * Creates a button Element.\n *\n * @param {string} className - Class.\n * @param {Element} targetElement - TargetElement.\n * @param {object} details - Button details.\n * @param {string} insertPosition - Button insert position.\n * @returns {Element} A button.\n */\nexport const createButton = (className, targetElement, details, insertPosition) => {\n    return createElement(BUTTON, BUTTON_CLASSNAME + ' ' + className, targetElement, merge({ type: BUTTON }, details), insertPosition);\n}\n\n/**\n * Translates an element.\n *\n * @param {Element} element - Element to translate.\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n */\nexport const translate = (element, x, y) => {\n    element.style.transform = `translate(${x}px,${y}px)`;\n}\n\n/**\n * Creates a slider.\n *\n * @param {string} className - CSS class.\n * @param {Element} parent - Sldier parent.\n * @param {number} max - Max property.\n * @param {number} step - Step property.\n * @returns {HTMLInputElement} - Slider.\n */\nexport const createSlider = (className, parent, max, step) => {\n    return createElement(INPUT, SLIDER_CLASSNAME + ' ' + className, parent, { type: 'range', max, step });\n}","export const { parseFloat: float, parseInt: int, isFinite: isNumeric } = Number;\nexport const { min, max, abs, round, PI } = Math;\n\n/**\n * Keeps a number in a range.\n *\n * @param {number} number - A number to keep it between two numbers.\n * @param {number} upperBound - Max.\n * @param {number} lowerBound - Min.\n * @returns {number}\n */\nexport const numberRange = (number, upperBound = 100, lowerBound = 0) => {\n    return min(max(number, lowerBound), upperBound);\n}\n\n/**\n * Angle value in degrees, it must be between 0 and 360.\n *\n * @param {number} angle - Angle.\n * @returns {Number}\n */\nexport const normalizeAngle = angle => {\n    return (round(angle) % 360 + 360) % 360;\n}","import { ROOT } from \"../constants/globals\";\nimport { getBounds, translate } from \"../utils/dom\";\nimport { abs, float, isNumeric } from \"../utils/number\";\nimport { objectIterator } from \"../utils/object\";\nimport { isString } from \"../utils/string\";\n\n/**\n * Popper constants.\n */\nconst TOP = 'top';\nconst BOTTOM = 'bottom';\nconst RIGHT = 'right';\nconst LEFT = 'left';\nconst START = 'start';\nconst CENTER = 'center';\nconst END = 'end';\n\nconst dimension = {\n    x: 'width',\n    y: 'height'\n}\n\nconst upperBound = {\n    x: RIGHT,\n    y: BOTTOM\n}\n\nconst X_AXIS = 'x';\nconst Y_AXIS = 'y';\n\n/**\n * Creates popper instance.\n *\n * @param {Element} reference - Popper reference element.\n * @param {Element} container - Popper container.\n * @param {object} param2 - Popper options.\n * @returns {object} - Popper instance.\n */\nexport const createPopper = (reference, container, { _margin, _position }) => {\n    /**\n     * Sides to fallback to.\n     */\n    let fallbackSides = {\n        [TOP]:    [TOP, BOTTOM, RIGHT, LEFT],\n        [BOTTOM]: [BOTTOM, TOP, RIGHT, LEFT],\n        [RIGHT]:  [RIGHT, LEFT, TOP, BOTTOM],\n        [LEFT]:   [LEFT, RIGHT, TOP, BOTTOM]\n    };\n    /**\n     * Alignments to fallback to.\n     */\n    let fallbackAlignments = {\n        start: [START, CENTER, END],\n        center: [CENTER, START, END],\n        end: [END, CENTER, START]\n    };\n    /**\n     * Popup coordinates.\n     */\n    let coordinates;\n\n    /**\n     * Space between the reference and the container.\n     */\n    let margin = 5;\n\n    /**\n     * Side and alignment from the position.\n     */\n    let [side, alignment] = isString(_position) ? _position.split('-') : [];\n\n    // Validate values.\n    if (! fallbackSides[side]) {\n        side = BOTTOM;\n    }\n    if (! alignment) {\n        alignment = CENTER;\n    } else if (! fallbackAlignments[alignment]) {\n        alignment = START;\n    }\n    _margin = float(_margin);\n    if (isNumeric(_margin)) {\n        margin = _margin;\n    }\n\n    return {\n        /**\n         * Popper Reference element.\n         *\n         * @type {Element}\n         */\n        _reference: reference,\n\n        /**\n         * Update container's position.\n         */\n        _update() {\n            let domBounds = getBounds(ROOT);\n            let referenceBoundingRect = getBounds(reference);\n            let containerBoundingRect = getBounds(container);\n\n            coordinates = {\n                x: null,\n                y: null\n            }\n\n            /**\n             * Check sides.\n             */\n            fallbackSides[side].some(referenceSide => {\n                let axis = referenceSide === TOP || referenceSide === BOTTOM ? Y_AXIS : X_AXIS;\n\n                let domBound = domBounds[referenceSide];\n                let referenceBound = referenceBoundingRect[referenceSide];\n\n                // The amount of space for the container.\n                let containerSpace = margin + containerBoundingRect[dimension[axis]];\n                // If container has available space.\n                if (containerSpace <= abs(domBound - referenceBound)) {\n                    // Calculate coordinate to set this side,\n                    // for the top/left sides substruct the container space from the top/left bound of the reference element,\n                    // and for the bottom/right sides just add the margin.\n                    coordinates[axis] = referenceBound + (domBound ? margin : -containerSpace);\n                    // Reverse the axises for the alignments.\n                    axis = axis === X_AXIS ? Y_AXIS : X_AXIS;\n\n                    /**\n                     * Check alignments, only if the container is attached.\n                     */\n                    fallbackAlignments[alignment].some(alignment => {\n                        // container width/height depends on the axis.\n                        let containerDimension = containerBoundingRect[dimension[axis]];\n                        // Lower bound is for the top/left coordinates.\n                        // Upper bound is for the bottom/right coordinates.\n                        // top/left coordinates are always lesser(lower) than bottom/right.\n                        let {\n                            [axis]: referenceLowerBound,\n                            [upperBound[axis]]: referenceUpperBound,\n                        } = referenceBoundingRect;\n                        // Distance between the reference bottom/right coordinates and the DOM,\n                        // bottom/right coordinates or boundries.\n                        let upperBoundDistance = domBounds[upperBound[axis]] - referenceLowerBound;\n\n                        // Offset between the container and the reference element.\n                        let offset = (containerDimension + referenceBoundingRect[dimension[axis]]) / 2;\n\n                        // Check for space availability and set the coordinate.\n                        if (alignment === START && containerDimension <= upperBoundDistance) {\n                            coordinates[axis] = referenceLowerBound;\n                            return true;\n                        }\n                        if (alignment === CENTER && offset <= referenceUpperBound && offset <= upperBoundDistance) {\n                            coordinates[axis] = referenceUpperBound - offset;\n                            return true;\n                        }\n                        if (alignment === END && containerDimension <= referenceUpperBound) {\n                            coordinates[axis] = referenceUpperBound - containerDimension;\n                            return true;\n                        }\n                    });\n                    // Exit the fallback sides loop.\n                    return true;    \n                }\n            });\n            // If there is no space to position the popover in all sides,\n            // then center the popover in the screen.\n            // If the popover is attached to one side but there is no space,\n            // for the alignment than center it horizontally/vertically depends on the side.\n            objectIterator(coordinates, (value, axis) => {\n                if (value === null) {\n                    coordinates[axis] = (domBounds[upperBound[axis]] - containerBoundingRect[dimension[axis]]) / 2;\n                }\n            });\n\n            translate(container, coordinates.x, coordinates.y);\n        }\n    }\n}","import { POPUP_CLASSNAME } from \"../constants/classnames\";\nimport { BUTTON, ESCAPE, INPUT, KEY_DOWN, RESIZE, ROOT, SCROLL, TAB } from \"../constants/globals\";\nimport { Binder } from \"../core/events/binder\";\nimport { createPopper } from \"../lib/popper\";\nimport { getElement, getScrollableAncestors, insertElement, isInViewport, removeElement, toggleClassName, toggleVisibility, translate } from \"../utils/dom\";\nimport { objectIterator } from \"../utils/object\";\nimport { isString } from \"../utils/string\";\n\n/**\n * Creates App componenet and initialize components.\n *\n * @param {Element} root - Picker container.\n * @param {Alwan} alwan - Alwan instance.\n * @returns {App}\n */\nexport const App = (root, alwan, events) => {\n    /**\n     * Alwan reference component.\n     */\n    let reference;\n\n    /**\n     * Popper event binder.\n     */\n    let popperEvents = Binder();\n\n    /**\n     * Popper instance.\n     */\n    let popper;\n\n    /**\n     * Popper reference's scrollable ancestors.\n     *\n     * @type {Array[Element]}\n     */\n    let scrollableAncestors;\n\n    /**\n     * Updates popper's position and visibility.\n     * \n     * @param {Event} e - Event. \n     */\n    let updatePopper = e => {\n        if (reference._isOpen()) {\n\n            popper._update();\n\n            // Close picker if popper's reference is scrolled out of view.\n            if (! isInViewport(popper._reference, scrollableAncestors)) {\n                reference._close(true);\n            }\n        }\n    }\n\n    /**\n     * Handles keyboard accessibility.\n     * \n     * If picker is displayed as a popover then link the focus from the reference,\n     * to the picker focusable elements.\n     *\n     * @param {KeyboardEvent} e - Event.\n     */\n    let handleAccessibility = e => {\n        if (reference._isOpen()) {\n            let { target, key, shiftKey } = e;\n            let paletteElement = alwan._components._palette._element;\n            let elementToFocusOn;\n            let lastFocusableElement;\n\n            // Pressing Escape key closes the picker.\n            if (key === ESCAPE) {\n                reference._close();\n            } else if (key === TAB) {\n\n                lastFocusableElement = [...getElement(BUTTON + ',' + INPUT, root, true)].pop();\n\n                if (target === reference._element && ! shiftKey) {\n                    // Pressing Tab while focusing on the reference element sends focus,\n                    // to the first element (palette) inside the picker container.\n                    elementToFocusOn = paletteElement;\n                } else if ((shiftKey && target === paletteElement) || (! shiftKey && target === lastFocusableElement)) {\n                    // Pressing Tab while focusing on the palette with the shift key or focussing on the last,\n                    // focusable element without shift key sends focus to the reference element (if it's focusable).\n                    elementToFocusOn = reference._element;\n                }\n                if (elementToFocusOn) {\n                    e.preventDefault();\n                    elementToFocusOn.focus();\n                }\n            }\n        }\n    }\n\n    return {\n        /**\n         * Picker container.\n         */\n        _root: root,\n\n        /**\n         * Setup and Initialize other components.\n         *\n         * @param {object} options - Alwan options.\n         * @param {object} instance - Alwan instance. \n         */\n        _setup(options, instance = alwan) {\n            alwan = instance;\n            let { theme, popover, target, position, margin, id, toggle, shared, disabled } = options;\n            let targetElement = getElement(target);\n\n            if (isString(id) && ! shared) {\n                root.id = id;\n            }\n\n            // Shared option force the toggle.\n            if (shared) {\n                toggle = true;\n            }\n    \n            // Initialize components.\n            objectIterator(alwan._components, ({ _init }) => {\n                if (_init) {\n                    _init(options, alwan);\n                }\n            })\n\n            reference = alwan._reference;\n            target = targetElement || reference._element;\n\n            // Set theme (dark or light).\n            root.dataset.theme = theme;\n\n            // Toggle option changed to false then open (show) the picker\n            if (! toggle) {\n                reference._open(true);\n            }\n            // Hide reference element if both popover and toggle are false.\n            toggleVisibility(reference._element, popover || toggle);\n            // Toggle popup class that makes the root's position fixed.\n            toggleClassName(root, POPUP_CLASSNAME, popover);\n\n            popperEvents._unbindAll();\n            popper = null;\n\n            if (popover) {\n                popper = createPopper(target, root, {\n                    _margin: margin,\n                    _position: position\n                });\n                popper._update();\n                // If reference element inside a nested scrollable elements,\n                // get all those scrollable elements in an array.\n                scrollableAncestors = getScrollableAncestors(target);\n                // Attach scroll event to all scrollable ancestors of the reference element,\n                // in order to update the popper's position.\n                // On window resize reposition the popper.\n                popperEvents._bind(window, RESIZE, updatePopper);\n                scrollableAncestors.forEach(scrollable => {\n                    popperEvents._bind(scrollable, SCROLL, updatePopper);\n                });\n                popperEvents._bind(ROOT, KEY_DOWN, handleAccessibility);\n            } else {\n                root.style = '';\n                insertElement(root, target, ! targetElement && 'afterend');\n            }\n\n            reference._toggleDisable(disabled);\n        },\n\n        /**\n         * Updates the popper's position.\n         */\n        _reposition() {\n            if (popper) {\n                popper._update();\n            }\n        },\n\n        /**\n         * Gets instance that controls the components.\n         *\n         * @returns {object} - Alwan instance.\n         */\n        _getInstance: () => alwan,\n\n        /**\n         * Destroy components and remove root element from the DOM.\n         */\n        _destroy() {\n            // Remove components events.\n            events._unbindAll();\n            // Remove popper events.\n            popperEvents._unbindAll();\n            root = removeElement(root);\n            alwan = {};\n        }\n    }\n}","export const clipboardSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>`;\nexport const checkSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path></svg>`;\nexport const switchInputsSVG = `<svg width=\"15\" height=\"15\" viewBox=\"0 0 20 20\" aria-role=\"none\"><path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path></svg>`;\nexport const caretSVG = `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z\"></path></svg>`;","import { HSL_FORMAT } from \"../constants/globals\";\n\n/**\n * Converts RGB or HSL color objects to string.\n *\n * @param {object} color - HSL or RGB color object.\n * @param {string} format - hsl or rgb.\n * @returns {string} rgb or hsl string.\n */\nexport const stringify = (color, format, opaque) => {\n    let percentage = '';\n    let opacity = '';\n    let a = color.a;\n\n    if (format === HSL_FORMAT) {\n        percentage = '%';\n    }\n\n    if (a < 1 && ! opaque) {\n        format += 'a';\n        opacity = ', ' + a;\n    }\n\n    return `${format}(${color[format[0]]}, ${color[format[1]] + percentage}, ${color[format[2]] + percentage + opacity})`;\n}","import { int, max, min, normalizeAngle, round } from \"../utils/number\";\n\n/**\n * Helper function used for converting HSV to RGB.\n *\n * @param {number} k - Positive coefficient.\n * @param {number} s - Saturation.\n * @param {number} v - Value.\n * @returns {number}\n */\nconst fn = (k, s, v) => {\n    return (v - v * s * max(0, min(k, 4 - k, 1))) * 255;\n}\n\n/**\n * Converts HSV to RGB.\n *\n * @param {object} param0 - HSV color object.\n * @returns {object} - RGB color object.\n */\nexport const HSVToRGB = ({ h, s, v, a }) => {\n    h /= 60;\n    return {\n        r: round(fn((5 + h) % 6, s, v)),\n        g: round(fn((3 + h) % 6, s, v)),\n        b: round(fn((1 + h) % 6, s, v)),\n        a\n    }\n}\n\n\n/**\n * Converts hex color string to RGB object.\n *\n * @param {string} hex - Hexadecimal color.\n * @returns {object} - RGB color object.\n */\nexport const HEXToRGB = hex => {\n    return {\n        r: int(hex.slice(1, 3), 16),\n        g: int(hex.slice(3, 5), 16),\n        b: int(hex.slice(5, 7), 16),\n        a: 1\n    }\n}\n\n/**\n * Converts a decimal number to hexadecimal.\n *\n * @param {number} number - A decimal number.\n * @returns {string} - Hexadecimal.\n */\nconst toHex = number => {\n    return (number < 16 ? '0' : '') + number.toString(16);\n}\n\n\n/**\n * Converts RGB object to Hex string.\n *\n * @param {object} param0 - RGB color object.\n * @returns {string} - Hex color.\n */\nexport const RGBToHEX = ({ r, g, b, a }) => {\n    return '#' + toHex(r) + toHex(g) + toHex(b) + (a < 1 ? toHex(round(a * 255)) : '');\n}\n\n\n/**\n * Converts HSV to HSL.\n *\n * @param {object} param0 - HSV color object.\n * @returns {object} - HSL object.\n */\nexport const HSVToHSL = ({ h, s, v, a }) => {\n    let l = v * (1 - s / 2);\n    return {\n        h,\n        s: round((! l || l === 1 ? 0 : (v - l) / min(l, 1 - l)) * 100),\n        l: round(l * 100),\n        a: round(a * 100) / 100\n    }\n}\n\n\n/**\n * Converts HSL to HSV.\n *\n * @param {Object} hsl - HSL color object.\n * @returns {Object}\n */\nexport const HSLToHSV = ({ h, s, l, a }) => {\n    s /= 100;\n    l /= 100;\n\n    let v = l + s * min(l, 1 - l);\n\n    return {\n        h,\n        s: v ? 2 * (1 - l / v) : 0,\n        v,\n        a\n    }\n}\n\n\n/**\n * Converts RGB to HSV.\n *\n * @param {Object} rgb - RGB color object.\n * @returns {Object}\n */\nexport const RGBToHSV = ({ r, g, b, a }) => {\n\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    let cMax = max(r, g, b);\n    let cMin = min(r, g, b);\n    let range = cMax - cMin;\n    let h = range === 0 ? 0\n            : cMax === r ? ((g - b) / range) % 6\n            : cMax === g ? ((b - r) / range) + 2\n            : cMax === b ? ((r - g) / range) + 4\n            : 0;\n\n    return {\n        h: normalizeAngle(h * 60),\n        s: cMax ? range / cMax : 0,\n        v: cMax,\n        a: round(a * 100) / 100\n    }\n}","import { HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"../constants/globals\";\nimport { createElement } from \"../utils/dom\";\nimport { float, isNumeric, normalizeAngle, numberRange, PI } from \"../utils/number\";\nimport { isString, trimString } from \"../utils/string\";\nimport { isset } from \"../utils/util\";\nimport { HEXToRGB } from \"./converter\";\nimport { stringify } from \"./stringify\";\n\nconst ctx = createElement('canvas').getContext('2d');\n\n/**\n * Regex.\n */\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?\\s*[\\s,]\\s*([+-]?\\d*\\.?\\d+)%?\\s*,?\\s*([+-]?\\d*\\.?\\d+)%?(?:\\s*[\\/,]\\s*([+-]?\\d*\\.?\\d+)(%)?)?\\s*\\)?$/;\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\n\nconst ANGLE_COEFFICIENT_MAP = {\n    deg: 1,\n    turn: 360,\n    rad: 180 / PI,\n    grad: 0.9\n}\n\n/**\n * Parses any value into an RGB or HSL objects.\n * Invalid color values default to #000.\n *\n * @param {unknown} value - A value to parse.\n * @param {boolean} asString - Whether to return the result as a string or object.\n * @returns {object|string} - Parsed color as string or object.\n */\nexport const parseColor = (value = '', asString) => {\n\n    let color;\n    let format;\n    let str = '';\n\n    /**\n     * Validate Non string values, convert color objects into strings.\n     * Invalid values default to empty string.\n     */\n    if (! isString(value)) {\n\n        format = [RGB_FORMAT, HSL_FORMAT, HSV_FORMAT].find(format => {\n\t\t\treturn format.split('').every(key => {\n\t\t\t\treturn isNumeric(float(value[key]));\n\t\t\t});\n\t\t});\n\n        if (format) {\n            if (! isset(value.a)) {\n                value.a = 1;\n            }\n\n            if (format === HSV_FORMAT) {\n                format = RGB_FORMAT;\n                value = HSVToRGB({\n                    h: normalizeAngle(value.h),\n                    s: numberRange(value.s) / 100,\n                    v: numberRange(value.v) / 100,\n                    a: value.a\n                });\n            }\n\n            str = stringify(value, format);\n        }\n    } else {\n        str = trimString(value);\n    }\n\n    /**\n     * Parse strings\n     */\n    let [input, h, angle, s, l, a, percentage] = HSL_REGEX.exec(str) || [];\n\n    // str is a hsl string.\n    if (input) {\n        /**\n         * Normalize values.\n         *\n         * The hue value is so often given in degrees, it can be given as a number, however\n         * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradians),\n         * If the hue has a unit other than deg, then convert it to degrees.\n         */\n        color = {\n            h: normalizeAngle(h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),\n            s: numberRange(s),\n            l: numberRange(l),\n            a: isset(a) ? numberRange(percentage ? a / 100 : a, 1) : 1\n        }\n        format = HSL_FORMAT;\n    } else {\n        format = RGB_FORMAT;\n\n        ctx.fillStyle = '#000';\n        ctx.fillStyle = str;\n        str = ctx.fillStyle;\n        // ColorString is either hex or rgb string,\n        // if it's hex convert it to rgb object,\n        // if it's rgb then parse it to object.\n        if (HEX_REGEX.test(str)) {\n            color = HEXToRGB(str);\n        } else {\n            let [r, g, b, a] = /\\((.+)\\)/.exec(str)[1].split(',').map(value => float(value));\n            color = { r, g, b, a };\n        }\n    }\n\n    return asString ? stringify(color, format) : { _format: format, _color: color }\n}","import { ALWAN_CLASSNAME, CONTAINER_CLASSNAME } from \"../constants/classnames\";\nimport { App } from \"../components/App\";\nimport { Inputs } from \"../components/Inputs\";\nimport { Palette } from \"../components/Palette\";\nimport { Sliders } from \"../components/Sliders\";\nimport { Swatches } from \"../components/Swatches\";\nimport { Utility } from \"../components/Utility\";\nimport { body, createElement } from \"../utils/dom\";\nimport { Binder } from \"./events/binder\";\n\n/**\n * Shared Components.\n */\nlet sharedComponents = null;\n\n/**\n * Number of instances that uses the shared components.\n */\nlet instanceCount = 0;\n\n/**\n * Creates components.\n *\n * @param {Alwan} alwan - Alwan instance.\n * @returns {object} alwan components.\n */\nconst createComponents = (alwan) => {\n    const events = Binder();\n    const root = createElement('', ALWAN_CLASSNAME, body());\n\n    const _app = App(root, alwan, events);\n    const _palette = Palette(root, alwan, events);\n    const container = createElement('', CONTAINER_CLASSNAME, root);\n    const _utility = Utility(container, alwan, events);\n    const _sliders = Sliders(container, alwan, events);\n    const _inputs = Inputs(createElement('', CONTAINER_CLASSNAME, root), alwan, events);\n    const _swatches = Swatches(root, alwan, events);\n\n    return {\n        _app,\n        _palette,\n        _utility,\n        _sliders,\n        _inputs,\n        _swatches\n    }\n}\n\n/**\n * Checks if components are shared.\n *\n * @param {object} components - Alwan components.\n * @returns {boolean} - True if components are shared.\n */\nexport const isShared = (components) => {\n    return !!sharedComponents && components === sharedComponents;\n}\n\n/**\n * Destroys components.\n *\n * @param {object} components - Alwan components.\n * @returns {void}\n */\nexport const destroyComponents = (components) => {\n    if (isShared(components)) {\n        instanceCount--;\n        if (instanceCount > 0) {\n            return;\n        }\n        sharedComponents = null;\n    }\n\n    components._app._destroy();\n    components = {};\n}\n\n/**\n * Gets components.\n *\n * @param {Alwan} alwan - Alwan instance.\n * @returns {object} components.\n */\nexport const useComponents = (alwan) => {\n    let { _components, config: { shared }} = alwan;\n\n    // Alwan already has components.\n    if (_components) {\n        // Nothing is changing, if components are shared and the option shared is true,\n        // or the components are not shared and the option shared is false\n        // then just return the current compoenents.\n        if ((isShared(_components)) === shared) {\n            return _components;\n        }\n\n        // Force close the picker before destroying its components.\n        alwan._reference._close(true, true);\n        // If something changed, either the components were shared,\n        // and the option shared is false which means set the components as,\n        // non-shared or the coponents were non-shared and we want to share them.\n        // in either cases we need to destroy the current components.\n        destroyComponents(_components);\n    }\n\n    if (shared) {\n        // Create components and set them to sharedComponents.\n        if (! sharedComponents) {\n            sharedComponents = createComponents(alwan);\n        }\n        // Increase the instances that uses this shared components.\n        instanceCount++;\n\n        return sharedComponents;\n    }\n\n    // Create components.\n    return createComponents(alwan);\n}\n\n\n/**\n * Closes the previous instance that controls the shared components,\n * before the current instance (alwan) controls the components.\n *\n * @param {object} alwan - Alwan instance.\n * @param {object} options - Alwan options.\n * @param {boolean} setup - If true run app setup.\n */\nexport const closeSharedInstance = (alwan, options, setup) => {\n    let app = alwan._components._app;\n    let instance = app._getInstance();\n\n    if (instance !== alwan) {\n        if (isShared(instance._components)) {\n            instance._reference._close(true);\n        }\n\n        if (setup) {\n            app._setup(options, alwan);\n        }\n    }\n}","import { MARKER_CLASSNAME, OVERLAY_CLASSNAME, PALETTE_CLASSNAME } from \"../constants/classnames\";\nimport { CHANGE, COLOR, KEY_DOWN, POINTER_DOWN, POINTER_MOVE, POINTER_UP, ROOT } from \"../constants/globals\";\nimport { createElement, getBounds, translate, removeElement } from \"../utils/dom\"\nimport { numberRange } from \"../utils/number\";\n\n/**\n * Picker palette.\n *\n * @param {Element} root - Root element to append the palette elements to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object}\n */\nexport const Palette = (root, alwan, events) => {\n    /**\n     * Marker X coordinate.\n     *\n     * @type {number}\n     */\n    let markerX;\n\n    /**\n     * Marker Y coordinate.\n     *\n     * @type {number}\n     */\n    let markerY;\n\n    /**\n     * Palette element bounds.\n     *\n     * @type {DOMRect}\n     */\n    let paletteBounds;\n\n    /**\n     * A transparent element cover the whole document.\n     *\n     * @type {Element}\n     */\n    let overlayElement;\n\n    /**\n     * Indicates whether a pointer (mouse, pen or touch) is down.\n     */\n    let isPointerDown = false;\n\n    /**\n     * Palette element.\n     */\n    const palette = createElement('', PALETTE_CLASSNAME, root, { tabindex: '0' });\n\n    /**\n     * Palette marker.\n     */\n    const marker = createElement('', MARKER_CLASSNAME, palette);\n\n    /**\n     * Palette element dimension.\n     */\n    const { width, height } = getBounds(palette);\n\n    /**\n     * Move marker horizontally using the keyboard arrow keys.\n     */\n    const keyboardX = {\n        ArrowRight: 1,\n        ArrowLeft: -1\n    };\n\n    /**\n     * Move marker vertically using the keyboard arrow keys\n     */\n    const keyboardY = {\n        ArrowDown: 1,\n        ArrowUp: -1\n    };\n\n    /**\n     * Move marker and update color state.\n     *\n     * @param {number} x - X coordinate.\n     * @param {number} y - Y coordinate.\n     * @param {Function} change - Callback function if color changed.\n     */\n    const moveMarkerAndUpdateColor = (x, y, change) => {\n\n        x = numberRange(x, width);\n        y = numberRange(y, height);\n\n        if (x !== markerX || y !== markerY) {\n            markerX = x;\n            markerY = y;\n            translate(marker, markerX, markerY);\n            alwan._color._update({ s: markerX / width, v: (1 - markerY / height)});\n            alwan._events._dispatch(COLOR, palette);\n\n            if (change) {\n                change();\n            }\n        }\n    }\n\n    /**\n     * Starts dragging the marker.\n     *\n     * @param {PointerEvent} e - Event.\n     */\n    const dragStart = e => {\n        if (! overlayElement) {\n            overlayElement = createElement('', OVERLAY_CLASSNAME, root);\n        }\n        // Save color state.\n        alwan._color._saveState();\n        paletteBounds = getBounds(palette);\n        isPointerDown = true;\n        moveMarkerAndUpdateColor(e.clientX - paletteBounds.x, e.clientY - paletteBounds.y);\n        palette.focus();\n    }\n\n    /**\n     * Dragging the marker.\n     *\n     * @param {PointerEvent} e - Event.\n     */\n    const drag = e => {\n        if (isPointerDown) {\n            moveMarkerAndUpdateColor(e.clientX - paletteBounds.x, e.clientY - paletteBounds.y);\n        }\n    }\n\n    /**\n     * Drag end (released the marker).\n     *\n     * @param {PointerEvent} e - Event.\n     */\n    const dragEnd = e => {\n        if (isPointerDown) {\n            alwan._color._triggerChange(palette);\n            overlayElement = removeElement(overlayElement);\n            isPointerDown = false;\n        }\n    }\n\n    /**\n     * Moves marker using keyboard arrow keys and adds focus-visible to the palette.\n     *\n     * @param {KeyboardEvent} e - Event.\n     */\n    const handleKeyboard = e => {\n        let key = e.key;\n\n        if (keyboardX[key] || keyboardY[key]) {\n            e.preventDefault();\n\n            moveMarkerAndUpdateColor(\n                markerX + (keyboardX[key] || 0) * width / 100,\n                markerY + (keyboardY[key] || 0) * height / 100,\n                () => {\n                    alwan._events._dispatch(CHANGE, palette);\n                }\n            );\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    events._bind(palette, POINTER_DOWN, dragStart);\n    events._bind(ROOT, POINTER_MOVE, drag);\n    events._bind(ROOT, POINTER_UP, dragEnd);\n    events._bind(palette, KEY_DOWN, handleKeyboard);\n\n\n    return {\n        _element: palette,\n\n        /**\n         * Initialize component.\n         *\n         * @param {object} options - Alwan options.\n         * @param {object} instance - Alwan instance.\n         */\n        _init(_options, instance) {\n            alwan = instance || alwan;\n        },\n\n        /**\n         * Updates marker position from an hsv color object.\n         *\n         * @param {object} param0 - HSV color object.\n         */\n        _update({ s, v }) {\n            translate(marker, s * width, (1 - v) * height);\n        }\n    }\n}","import { checkSVG, clipboardSVG } from \"../assets/svg\";\nimport { COPY_BUTTON_CLASSNAME, PREVIEW_CLASSNAME } from \"../constants/classnames\";\nimport { CLICK, COLOR_PROPERTY, FOCUS_OUT, HTML, INPUT, INSERT_BEFORE_FIRST_CHILD, MOUSE_OUT, ROOT } from \"../constants/globals\";\nimport { createButton, createElement, insertElement, removeElement, setCustomProperty, setHTML } from \"../utils/dom\";\n\n/**\n * Creates utility component.\n *\n * @param {Element} parent - Container.\n * @param {Alwan} alwan - Alwan instance.\n * @param {object} events - Event binder.\n * @returns {object} Utility component.\n */\nexport const Utility = (parent, alwan, events) => {\n    /**\n     * Preview color.\n     *\n     * @type {Element}\n     */\n    let previewElement;\n\n    /**\n     * Copy button.\n     *\n     * @type {HTMLButtonElement}\n     */\n    let copyButton;\n\n    /**\n     * Indicate whether color is copied.\n     */\n    let isCopied;\n\n    /**\n     * API.\n     */\n    const self = {\n        /**\n         * Initialize utility component.\n         *\n         * @param {object} param0 - Alwan options.\n         * @param {object} instance - Alwan instance.\n         */\n        _init({ preview, copy }, instance) {\n            alwan = instance;\n            if (copy !== !! copyButton) {\n                if (copy) {\n                    copyButton = createButton(COPY_BUTTON_CLASSNAME, previewElement || parent, { html: clipboardSVG }, INSERT_BEFORE_FIRST_CHILD);\n                } else {\n                    copyButton = removeElement(copyButton);\n                }\n            }\n\n            if (preview !== !! previewElement) {\n                if (preview) {\n                    previewElement = createElement('', PREVIEW_CLASSNAME, parent, false, INSERT_BEFORE_FIRST_CHILD);\n                } else {\n                    previewElement = removeElement(previewElement);\n                }\n\n                insertElement(copyButton, previewElement || parent, INSERT_BEFORE_FIRST_CHILD);\n            }\n        }\n    }\n\n    /**\n     * Copies the selected color to the clipboard.\n     *\n     * @param {MouseEvent} e - Event.\n     */\n    const copyColor = ({ target }) => {\n        if (target === copyButton && ! isCopied && ! alwan.config.disabled) {\n\n            let clipboard = navigator.clipboard;\n            let color = alwan._color._getColorByFormat(true);\n            let input;\n\n            if (clipboard) {\n                clipboard.writeText(color);\n            } else {\n                input = createElement(INPUT, '', HTML, { value: color });\n                input.select();\n                ROOT.execCommand('copy');\n                input = removeElement(input);\n            }\n            // change icon.\n            isCopied = true;\n            setHTML(copyButton, checkSVG);\n        }\n    }\n\n    /**\n     *  Updates the svg icon of the button.\n     *\n     * @param {MouseEvent|FocusEvent} e - Event.\n     */\n    const updateButtonIcon = e => {\n        if (e.target === copyButton) {\n            // If the color is copied (that means the copy button has changed its icon),\n            // and the button has lost focus or mouse left it, then set the icon back,\n            // to the clipboard svg.\n            if (isCopied) {\n                isCopied = false;\n                setHTML(copyButton, clipboardSVG);\n            }\n            copyButton.blur();\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    events._bind(parent, CLICK, copyColor);\n    events._bind(parent, [MOUSE_OUT, FOCUS_OUT], updateButtonIcon);\n\n    return self;\n}","import { ALPHA_SLIDER_CLASSNAME, HUE_SLIDER_CLASSNAME, SLIDERS_CLASSNAME } from \"../constants/classnames\";\nimport { CHANGE, COLOR, COLOR_PROPERTY, INPUT } from \"../constants/globals\";\nimport { createElement, createSlider, removeElement, setCustomProperty } from \"../utils/dom\";\n\n/**\n * Creates sliders component.\n *\n * @param {Element} parent - Element to append sliders to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object} Sliders component.\n */\nexport const Sliders = (parent, alwan, events) => {\n    /**\n     * Alpha slider.\n     *\n     * @type {HTMLInputElement}\n     */\n    let alphaSlider;\n\n    /**\n     * Sliders container.\n     */\n    const container = createElement('', SLIDERS_CLASSNAME, parent);\n\n    /**\n     * Hue slider.\n     *\n     * @type {HTMLInputElement}\n     */\n    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, container, 360);\n\n    /**\n     * Updates color.\n     *\n     * @param {InputEvent} param0 - Event.\n     */\n    const handleChange = ({ target, type, target: { value } }) => {\n        alwan._color._update(target === hueSlider ? { h: 360 - value } : { a: value * 1 });\n        alwan._events._dispatch(type === CHANGE ? CHANGE : COLOR, target);\n    }\n\n    /**\n     * Bind events.\n     */\n    events._bind(container, [INPUT, CHANGE], handleChange);\n\n\n    return {\n        /**\n         * Initialize sliders.\n         *\n         * @param {object} param0 - Alwan options.\n         * @param {object} instance - Alwan instance.\n         */\n        _init({ opacity }, instance) {\n            alwan = instance || alwan;\n\n            if (opacity !== !! alphaSlider) {\n                if (opacity) {\n                    alphaSlider = createSlider(ALPHA_SLIDER_CLASSNAME, container, 1, 0.01);\n                } else {\n                    alphaSlider = removeElement(alphaSlider);\n                    alwan._color._update({ a: 1 });\n                }\n            }\n        },\n\n        /**\n         * Sets sliders values.\n         *\n         * @param {object} param0 - HSV color object.\n         */\n        _setValue({ h, a }) {\n            hueSlider.value = 360 - h;\n            if (alphaSlider) {\n                alphaSlider.value = a;\n            }\n        }\n    };\n}","import { switchInputsSVG } from \"../assets/svg\";\nimport { INPUTS_CLASSNAME, INPUT_CLASSNAME } from \"../constants/classnames\";\nimport { stringify } from \"../colors/stringify\";\nimport { CHANGE, CLICK, COLOR, COLOR_FORMATS, ENTER, FOCUS_IN, HEX_FORMAT, INPUT, KEY_DOWN} from \"../constants/globals\";\nimport { createButton, createElement, removeElement, setHTML, toggleVisibility } from \"../utils/dom\";\nimport { max } from \"../utils/number\";\nimport { objectIterator } from \"../utils/object\";\nimport { isString, trimString } from \"../utils/string\";\nimport { isset } from \"../utils/util\";\n\n\n/**\n * Creates Inputs component.\n *\n * @param {Element} container - Element to append the inputs container element to.\n * @param {Object} alwan - Alwan instance.\n * @returns {Object} - Inputs component.\n */\nexport const Inputs = (container, alwan, events) => {\n\n    /**\n     * Inputs wrapper element.\n     */\n    let inputsContainer;\n\n    /**\n     * Switch button.\n     *\n     * @type {Element}\n     */\n    let switchButton;\n\n    /**\n     * Picker formats.\n     */\n    let formats = [];\n\n    /**\n     * Index of the current format.\n     */\n    let formatIndex;\n\n    /**\n     * Object that maps fields label to their inputs.\n     *\n     * @type {object}\n     */\n    let inputsMap;\n\n    /**\n     * Indicates that an input value has changed.\n     */\n    let isChanged = false;\n\n    /**\n     * Component API.\n     */\n    const self = {\n        /**\n         * Initialize Inputs.\n         *\n         * @param {object} param0 - Alwan options.\n         * @param {object} instance - Alwan instance.\n         */\n        _init({ inputs, format }, instance) {\n\n            alwan = instance || alwan;\n            inputs = isset(inputs) ? inputs : {};\n            inputsMap = {};\n\n            // Get only valid formats.\n            formats = COLOR_FORMATS.filter(format => inputs[format]);\n            let length = formats.length;\n\n            if (! length) {\n                // No inputs, remove inputs container and the switch button.\n                inputsContainer = removeElement(inputsContainer);\n                switchButton = removeElement(switchButton);\n                // Normalize format value.\n                format = COLOR_FORMATS.includes(format) ? format : COLOR_FORMATS[0];\n            } else {\n\n                // Create inputs container.\n                if (! inputsContainer) {\n                    inputsContainer = createElement('', INPUTS_CLASSNAME, container);\n                }\n\n                if (length === 1) {\n                    switchButton = removeElement(switchButton);\n                } else if (!switchButton) {\n                    // For more than one input format, add a switch button.\n                    switchButton = createButton('', container, { html: switchInputsSVG });\n                }\n\n                // Validate and normalize format value.\n                formatIndex = max(formats.indexOf(format), 0);\n                format = formats[formatIndex];\n                build(format);\n            }\n\n            alwan.config.format = format;\n            // Show/Hide parent container.\n            toggleVisibility(container, length);\n        },\n\n        /**\n         * Updates Input(s) value(s).\n         *\n         * @param {Object} color - Color object.\n         */\n        _setValue(color) {\n            objectIterator(inputsMap, (input, key) => {\n                input.value = isString(color) ? color : color[key];\n            });\n        }\n    }\n\n    /**\n     * Builds inputs.\n     *\n     * @param {string} format - Color format.\n     */\n    const build = (format) => {\n        let { singleInput, opacity } = alwan.config;\n        let fields;\n        // Each letter in the format variable represent a color channel,\n        // For multiple inputs, each color channel has an input field.\n        // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\n        if (singleInput || format === HEX_FORMAT) {\n            fields = [format];\n        } else {\n            fields = (format + (opacity ? 'a' : '')).split('');\n        }\n\n        // Empty the container from any inputs.\n        setHTML(inputsContainer, '');\n\n        fields.forEach(field => {\n            /**\n             * Create Input.\n             * \n             * <label>\n             *     <input type=\"text|number\" class=\"alwan__input\">\n             *     <span>${field}</span>\n             * </label>\n             */\n            const labelElement = createElement('label', '', inputsContainer);\n            inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, labelElement, { type: 'text' });\n            createElement('span', '', labelElement, { html: field });\n        });\n    }\n\n    /**\n     * Handles changes in inputs.\n     *\n     * @param {InputEvent} e - Event.\n     */\n    const handleChange = ({ target: { value }}) => {\n\n        if (! isChanged) {\n            alwan._color._saveState();\n            isChanged = true;\n        }\n\n        let str = '';\n        let color = {};\n        let format = formats[formatIndex];\n\n        if (alwan.config.singleInput || format === HEX_FORMAT) {\n            str = value;\n        } else {\n            // Copy inputs values into an object (rgb or hsl).\n            objectIterator(inputsMap, (input, key) => {\n                color[key] = trimString(input.value);\n            });\n            // Convert the object into string.\n            str = stringify(color, format);\n        }\n\n        if (alwan._color._set(str, true)) {\n            alwan._events._dispatch(COLOR, inputsMap);\n        }\n    }\n\n    /**\n     * Handles when an input loses focus after its value was changed.\n     *\n     * @param {InputEvent} e - Event.\n     */\n    const handleChangeStop = e => {\n        if (isChanged) {\n            alwan._color._triggerChange(inputsMap);\n            isChanged = false;\n        }\n    }\n\n    /**\n     * Changes color format.\n     *\n     * @param {MouseEvent} e - Click event.\n     */\n    const changeFormat = e => {\n        if (e.target === switchButton) {\n            // Increment input format index, reset it if it reaches the end.\n            // this index will point to the next format.\n            formatIndex = (formatIndex + 1) % formats.length;\n            alwan.config.format = formats[formatIndex];\n            build(formats[formatIndex]);\n            // Update values.\n            alwan._color._update();\n        }\n    }\n\n    /**\n     * Select input value when focus in, and close the picker when pressing Enter key.\n     *\n     * @param {FocusEvent|KeyboardEvent} e - Event.\n     */\n    const selectOrClose = ({ target, key, type }) => {\n        if (target !== switchButton) {\n            if (type === FOCUS_IN) {\n                target.select();\n            } else if (key === ENTER) {\n                alwan._reference._close();\n            }\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    events._bind(container, CLICK, changeFormat);\n    events._bind(container, INPUT, handleChange);\n    events._bind(container, CHANGE, handleChangeStop);\n    events._bind(container, [KEY_DOWN, FOCUS_IN], selectOrClose);\n\n\n    return self;\n}","import { caretSVG } from \"../assets/svg\";\nimport { COLLAPSE_BUTTON_CLASSNAME, COLLAPSE_CLASSNAME, SWATCHES_CLASSNAME, SWATCH_CLASSNAME } from \"../constants/classnames\";\nimport { parseColor } from \"../colors/parser\";\nimport { CHANGE, CLICK, COLOR, COLOR_PROPERTY } from \"../constants/globals\";\nimport { createButton, createElement, parent, removeElement, setCustomProperty, setHTML, toggleClassName } from \"../utils/dom\";\nimport { int } from \"../utils/number\";\nimport { isset } from \"../utils/util\";\n\n/**\n * Creates swatches component.\n *\n * @param {Element} root - Element to append the palette element to.\n * @param {object} alwan - Picker Instance.\n * @param {object} events - Event binder.\n * @returns {object} - Swatches component.\n */\nexport const Swatches = (root, alwan, events) => {\n\n    /**\n     * Swatches container.\n     *\n     * @type {Element}\n     */\n    let container;\n\n    /**\n     * Swatches array.\n     *\n     * @type {array<string>}\n     */\n    let swatches;\n\n    /**\n     * Button.\n     *\n     * @type {HTMLButtonElement}\n     */\n    let collapseButton;\n\n    /**\n     * Swatches array length.\n     *\n     * @type {number}\n     */\n    let swatchesLength;\n\n    /**\n     * Indicate whether swatches container is collapsible.\n     *\n     * @type {boolean}\n     */\n    let isCollapsible\n\n    /**\n     * Swatches API.\n     */\n    const self = {\n        /**\n         * Initialize swatches.\n         *\n         * @param {Object} options - Alwan options.\n         */\n        _init(options = {}, instance) {\n            alwan = instance || alwan;\n\n            swatches = options.swatches || swatches;\n            isCollapsible = options.toggleSwatches;\n            isCollapsible = isset(isCollapsible) ? isCollapsible : false;\n\n            if (Array.isArray(swatches)) {\n\n                swatchesLength = swatches.length;\n\n                if (swatchesLength) {\n                    // Create swatches container.\n                    if (! container) {\n                        container = createElement('', SWATCHES_CLASSNAME, root);\n                    } else {\n                        // Initialize container.\n                        setHTML(container, '');\n                    }\n\n                    // Create swatch button.\n                    swatches.forEach(color => {\n                        setCustomProperty(\n                            createButton(SWATCH_CLASSNAME, container),\n                            COLOR_PROPERTY,\n                            parseColor(color, true)\n                        );\n                    });\n\n                    // Create or remove the collapse button depend if the toggleSwatches,\n                    // option changes.\n                    if (isCollapsible) {\n                        if (! collapseButton) {\n                            collapseButton = createButton(COLLAPSE_BUTTON_CLASSNAME, root, { html: caretSVG });\n                        }\n                    } else {\n                        collapseButton = removeElement(collapseButton);\n                    }\n                    toggleClassName(container, COLLAPSE_CLASSNAME, isCollapsible);\n                } else {\n                    // Remove everything if the swatches array is empty.\n                    container = removeElement(container);\n                    collapseButton = removeElement(collapseButton);\n                }\n            }\n        },\n        /**\n         * Adds a swatch button.\n         *\n         * @param {String|object} color - Color.\n         */\n        _add(color) {\n            swatchesLength = swatches.push(color);\n            if (swatchesLength > 1) {\n                setCustomProperty(\n                    createButton(SWATCH_CLASSNAME, container),\n                    COLOR_PROPERTY,\n                    parseColor(color, true)\n                );\n            } else {\n                // Initialize component, if calling add swatches on an empty array.\n                self._init();\n            }\n        },\n        /**\n         * Removes a swatch button.\n         *\n         * @param {String|Number} swatch - Color or Swatch Index.\n         */\n        _remove(swatch) {\n            let index = swatches.findIndex((color, index) => swatch === color || int(swatch) === index);\n\n            if (index > -1) {\n                swatchesLength--;\n                // Remove swatch button.\n                removeElement(container.children[index]);\n                // Remove color from swatches array.\n                swatches.splice(index, 1);\n\n                if (! swatchesLength) {\n                    // Initialize component, if calling remove swatches on an array that,\n                    // has only one value.\n                    self._init();\n                }\n            }\n        }\n    };\n\n    /**\n     * Handles clicks in the swatches container or the collapse button.\n     *\n     * @param {MouseEvent} e - Event.\n     */\n    const handleClick = ({ target }) => {\n        if (target === collapseButton) {\n            toggleClassName(container, COLLAPSE_CLASSNAME);\n        }else if(parent(target) === container) {\n            alwan._color._set(target.style.getPropertyValue(COLOR_PROPERTY));\n            alwan._events._dispatch(COLOR, target);\n            alwan._events._dispatch(CHANGE, target);\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    events._bind(root, CLICK, handleClick);\n\n\n    return self;\n}","import { HSLToHSV, HSVToHSL, HSVToRGB, RGBToHEX, RGBToHSV } from \"../colors/converter\";\nimport { parseColor } from \"../colors/parser\";\nimport { stringify } from \"../colors/stringify\";\nimport { CHANGE, COLOR_PROPERTY, HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"../constants/globals\";\nimport { setCustomProperty } from \"../utils/dom\";\nimport { isEqual, merge } from \"../utils/object\";\n\n/**\n * Creates the core color state and UI updater.\n *\n * @param {object} alwan - Alwan instance.\n * @returns {object} Core color state.\n */\nexport const color = (alwan) => {\n    /**\n     * HSV color object.\n     */\n    let HSV = {\n        h: 0,\n        s: 0,\n        v: 0,\n        a: 1\n    };\n\n    /**\n     * RGB color object.\n     *\n     * @type {object}\n     */\n    let RGB;\n\n    /**\n     * RGB color string.\n     *\n     * @type {string}\n     */\n    let rgbString;\n\n    /**\n     * Color state.\n     *\n     * @type{object}\n     */\n    let state;\n\n    /**\n     * Alwan options.\n     */\n    let config = alwan.config;\n\n    /**\n     * Gets color data.\n     *\n     * @param {object} color - Color object.\n     * @param {string} format - Color format.\n     * @param {boolean} asArray - Gets data as an array.\n     * @param {string} str - Color string.\n     * @returns {object} - Color data.\n     */\n    let colorData = (color, format, asArray, str) => {\n        return merge(\n            (format + (config.opacity ? 'a' : '')).split('').reduce((output, channel, index) => {\n                output[asArray ? index : channel] = color[channel];\n                return output;\n            }, asArray ? [] : {}),\n\n            format !== HSV_FORMAT ? { toString: () => str || stringify(color, format) } : {}\n        )\n    }\n\n    /**\n     * Color api.\n     */\n    let self = {\n        /**\n         * Updates core color, css custom properties and inputs values.\n         *\n         * @param {object} hsv - HSV color object.\n         * @param {object|undefined} rgb - RGB color object.\n         * @param {boolean} isInputs - If true don't set inputs values.\n         */\n        _update(hsv, rgb, isInputs) {\n\n            let { _app: { _root }, _inputs } = alwan._components;\n\n            if (! config.disabled) {\n                hsv = hsv || HSV;\n                merge(HSV, hsv);\n\n                RGB = rgb || HSVToRGB(HSV);\n                rgbString = stringify(RGB, RGB_FORMAT);\n\n                // Update UI.\n                setCustomProperty(alwan._reference._element, COLOR_PROPERTY, rgbString);\n                setCustomProperty(_root, '--h', hsv.h);\n                setCustomProperty(_root, '--rgb', stringify(RGB, RGB_FORMAT, true));\n                setCustomProperty(_root, COLOR_PROPERTY, rgbString);\n\n                if (! isInputs) {\n                    _inputs._setValue(self._getColorByFormat(config.singleInput));\n                }\n            }\n        },\n\n        /**\n         * Same as update method plus it updates palette's marker position,\n         * and sliders values.\n         *\n         * @param {object} hsv - HSV color object.\n         * @param {object|undefined} rgb - RGB color object.\n         * @param {boolean} isInputs - If true don't set inputs values.\n         */\n        _updateAll(hsv, rgb, isInputs) {\n            let { _palette, _sliders } = alwan._components;\n            self._update(hsv, rgb, isInputs);\n            _palette._update(HSV);\n            _sliders._setValue(HSV);\n        },\n\n        /**\n         * Gets a color string or object by a format.\n         *\n         * @param {boolean} asString - Whether to get the color as a string.\n         * @param {string} format - Color format.\n         * @returns {object|string} - Color.\n         */\n        _getColorByFormat: (asString, format = config.format) => {\n    \n            if (format === RGB_FORMAT) {\n                if (asString) {\n                    return rgbString;\n                }\n                return RGB;\n            }\n    \n            if (format === HSL_FORMAT) {\n                if (asString) {\n                    return stringify(HSVToHSL(HSV), HSL_FORMAT);\n                }\n                return HSVToHSL(HSV);\n            }\n    \n            if (format === HEX_FORMAT) {\n                return RGBToHEX(RGB);\n            }\n    \n            return '';\n        },\n\n        /**\n         * Save color state.\n         */\n        _saveState() {\n            state = self._getColorByFormat();\n        },\n\n        /**\n         * Compare the current color with the saved color, if they are different,\n         * then dipatch a change event.\n         *\n         * @param {Element} source - Event source.\n         */\n        _triggerChange(source) {\n            if (! isEqual(state, self._getColorByFormat())) {\n                alwan._events._dispatch(CHANGE, source);\n            }\n        },\n\n        /**\n         * Sets color.\n         *\n         * @param {string|object} color - Color value.\n         * @param {boolean} isInputs - Is inputs component.\n         * @returns {boolean} - Whether the color state is changed or not.\n         */\n        _set(color, isInputs = false) {\n            let { _format, _color } = parseColor(color);\n            let isChanged = ! isEqual(_color, self._getColorByFormat(false, _format));\n            let isRGB = _format === RGB_FORMAT;\n    \n            if (isChanged) {\n                self._updateAll(\n                    // Convert colors (RGB or HSL) to HSV.\n                    isRGB ? RGBToHSV(_color) : HSLToHSV(_color),\n                    // If the parsed color is RGB.\n                    isRGB ? _color : false,\n                    isInputs\n                );\n                \n            }\n    \n            return isChanged;\n        },\n\n        /**\n         * Gets color value.\n         *\n         * @returns {object} - Color value.\n         */\n        _value: () => ({ \n            value: self._getColorByFormat(true),\n            hsv: asArray => colorData(HSV, HSV_FORMAT, asArray),\n            rgb: asArray => colorData(RGB, RGB_FORMAT, asArray, rgbString),\n            hsl: asArray => colorData(HSVToHSL(HSV), HSL_FORMAT, asArray),\n            hex: () => RGBToHEX(RGB),\n        })\n    }\n\n    return self;\n}","import { merge } from \"../utils/object\"\nimport { isset } from \"../utils/util\";\nimport { useComponents, closeSharedInstance } from \"./component\";\n\n/**\n * Initialize instance.\n *\n * @param {object} alwan - Instance.\n * @param {object} options - Alwan options.\n */\nexport const initialize = (alwan, options = {}) => {\n    let config = merge(alwan.config, options);\n    let color = options.color;\n    let { _set, _update } = alwan._color;\n\n    alwan._components = useComponents(alwan);\n    alwan._reference._init(config);\n    closeSharedInstance(alwan);\n    alwan._components._app._setup(config, alwan);\n\n    if (isset(color)) {\n        _set(color);\n    } else {\n        // To update inputs values.\n        _update();\n    }\n}","/**\n * SC Picker default options.\n */\n export const defaults = {\n    // Set the container's (widget) id.\n    id: '',\n\n    // One or many classes separated by a white space,\n    // to add it to the preset button.\n    classname: '',\n\n    // Choose a theme, 'dark' or 'light'.\n    theme: 'light',\n\n    // Toggle picker's visibility (Show/Hide),\n    // Setting this to false keeps the picker visible.\n    toggle: true,\n\n    // Display the picker container as a pop-up (a box that floats on top of the page content),\n    // if it's false, picker container will be displayed as a block (embeded in the page's content).\n    popover: true,\n\n    // Set the position of the popper (if popover is set to true) relative to the reference element,\n    // the position has two values seperated by a dash (-),\n    // the first value is the direction (top, bottom, right, left),\n    // the second value is the alignment (start, center, end), omitting this value will default to center.\n    // e.g. 'bottom-start': 'bottom' places the picker below the reference element,\n    // and 'start' aligns the left side of the container with the left side of the reference element.\n    // Note: \n    // If the picker container has no space to be placed, it will auto-position itself.\n    // based on the available space.\n    position: 'bottom-start',\n\n    // Set the gap (in pixels) between the picker container and the reference element.\n    margin: 8,\n\n    // Replace the reference element with a pre-styled button.\n    preset: true,\n\n    // Initial color.\n    color: '#000',\n\n    // Default color.\n    default: '#000',\n\n    // Target can be a selector or an HTML element,\n    // If the option popover is true, the picker container will be positionned retalive to this element,\n    // instead of the reference element.\n    // else if popover option is false, the picker container will be appended as a child into this element.\n    target: '',\n\n    // Disable the picker, users won't be able to pick colors.\n    disabled: false,\n\n    // Initial color format.\n    format: 'rgb',\n\n    // For the formats 'hsl' and 'rgb', choose a single input to display the color string,\n    // or if false, display an input for each color channel.\n    singleInput: false,\n\n    // Choose color formats for the picker input, 'hsl', 'rgb' or 'hex',\n    // No input will be displayed if the array is empty.\n    inputs: {\n        rgb: true,\n        hex: true,\n        hsl: true,\n    },\n\n    // Support alpha channel and display opacity slider.\n    opacity: true,\n\n    // Preview the color.\n    preview: true,\n\n    // Add/Remove a copy button.\n    copy: true,\n\n    // Array of color strings, invalid color strings will default to rgb(0,0,0).\n    swatches: [],\n\n    /**\n     * Share components with multiple alwan instances.\n     */\n    shared: false,\n\n    /**\n     * Make swatches container collapsible.\n     */\n    toggleSwatches: false,\n}","import { Reference } from \"./components/reference\";\nimport { merge, objectIterator, prototype, setPrototypeOf } from \"./utils/object\";\nimport { destroyComponents } from \"./core/component\";\nimport { color } from \"./core/color\";\nimport { Dispatcher } from \"./core/events/dispatcher\";\nimport { initialize } from \"./core/init\";\nimport \"./assets/scss/alwan.scss\";\nimport { defaults } from \"./constants/defaults\";\n\n\nexport default class Alwan {\n\n    static version = VERSION;\n\n    /**\n     * Alwan defaults.\n     */\n    static defaults = defaults;\n\n    /**\n     * Alwan instance constructor.\n     *\n     * @param {String|Element} reference - The reference element.\n     * @param {Object} options - Options.\n     */\n    constructor(reference, options) {\n        let alwan = this;\n\n        alwan.config = merge({}, Alwan.defaults);\n        alwan._events = Dispatcher(alwan);\n        alwan._color = color(alwan);\n        alwan._reference = Reference(reference, alwan);\n        initialize(alwan, options);\n    }\n\n    /**\n     * Sets new options.\n     *\n     * @param {Object} options - Alwan options.\n     */\n    setOptions(options) {\n        initialize(this, options);\n    }\n\n    /**\n     * Gets the state of the picker whether it's opened or closed.\n     *\n     * @returns {Boolean}\n     */\n    isOpen() {\n        return this._reference._isOpen();\n    }\n\n    /**\n     * Opens the picker.\n     */\n    open() {\n        this._reference._open();\n    }\n\n    /**\n     * Closes the picker.\n     */\n    close() {\n        this._reference._close();\n    }\n\n    /**\n     * Toggles (opens/closes) the picker.\n     */\n    toggle() {\n        this._reference._toggle();\n    }\n\n    /**\n     * Attaches an event handler function for an event.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    on(type, handler) {\n        this._events._addListener(type, handler);\n    }\n\n    /**\n     * Detaches one or more event handlers.\n     *\n     * Note:\n     * omitting handler, remove all handlers from the event,\n     * omitting both event type and handler, remove all handlers that are,\n     * attached to all events.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    off(type, handler) {\n        this._events._removeListeners(type, handler);\n    }\n\n    /**\n     * Sets a color.\n     *\n     * @param {String|Object} color - Color.\n     */\n    setColor(color) {\n        this._color._set(color);\n        return this;\n    }\n\n    /**\n     * Gets color.\n     *\n     * @returns {Object}\n     */\n    getColor() {\n        return this._color._value();\n    }\n\n    /**\n     * Adds a swatch.\n     *\n     * @param {String} color - Color.\n     */\n    addSwatch(color) {\n        this._components._swatches._add(color);\n    }\n\n    /**\n     * Removes a swatch.\n     *\n     * @param {String|Number} swatch - Can a color string or it's index in the swatches array.\n     */\n    removeSwatch(swatch) {\n        this._components._swatches._remove(swatch);\n    }\n\n    /**\n     * Enables picker.\n     */\n    enable() {\n        this._reference._toggleDisable(false);\n    }\n\n    /**\n     * Disables picker.\n     */\n    disable() {\n        this._reference._toggleDisable(true);\n    }\n\n    /**\n     * Resets to default color.\n     */\n    reset() {\n        this._color._set(this.config.default);\n    }\n\n    /**\n     * Repositions picker if it's displayed as a popover.\n     */\n    reposition() {\n        this._components._app._reposition();\n    }\n\n    /**\n     * Executes all handlers attached to the specified event.\n     *\n     * @param {String} type - Event type.\n     */\n    trigger(type) {\n        this._events._dispatch(type);\n    }\n\n    /**\n     * Destroy picker and free up memory.\n     */\n    destroy() {\n        let alwan = this;\n\n        alwan._reference._destroy();\n        destroyComponents(alwan._components);\n\n        // Remove all properties of this instance.\n        objectIterator(alwan, (value, key) => {\n            delete alwan[key];\n        });\n\n        // Empty instance prototype.\n        setPrototypeOf(alwan, prototype);\n    }\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants/globals\"\nimport { merge, objectIterator } from \"../../utils/object\";\nimport { isset } from \"../../utils/util\";\n\n/**\n * Alwan events.\n *\n * @param {Alwan} alwan - Alwan Instance.\n * @returns \n */\nexport const Dispatcher = (alwan) => {\n    /**\n     * Alwan event listeners.\n     */\n    const listeners = {\n        [OPEN]: [],\n        [CLOSE]: [],\n        [CHANGE]: [],\n        [COLOR]: []\n    }\n\n    return {\n        /**\n         * Dispatch an event.\n         *\n         * @param {string} type - Event type.\n         * @param {object} ev - Event object.\n         */\n        _dispatch(type, source) {\n            if (! alwan.config.disabled) {\n                (listeners[type] || []).forEach(handler => {\n                    handler(merge({ type, source }, alwan._color._value()));\n                });\n            }\n        },\n\n        /**\n         * Add an event listener.\n         *\n         * @param {string} eventType - Event type.\n         * @param {CallableFunction} eventHandler - Event handler to registered.\n         */\n        _addListener(eventType, eventHandler) {\n            if (listeners[eventType] && ! listeners[eventType].includes(eventHandler)) {\n                listeners[eventType].push(eventHandler);\n            }\n        },\n\n        /**\n         * Remove event listener(s).\n         *\n         * @param {string} type - Event type.\n         * @param {CallableFunction} handlerToRemove - Event handler to remove.\n         */\n        _removeListeners(eventType, handlerToRemove) {\n\n            let handlers = eventType && listeners[eventType];\n\n            if (isset(eventType)) {\n                if (handlers) {\n                    if (isset(handlerToRemove)) {\n                        listeners[eventType] = handlers.filter((handler => handler !== handlerToRemove));\n                    } else {\n                        listeners[eventType] = [];\n                    }\n                }\n            } else {\n                objectIterator(listeners, (_array, eventType) => {\n                    listeners[eventType] = [];\n                });\n            }\n        }\n    }\n}","import { OPEN_CLASSNAME, PRESET_BUTTON_CLASSNAME } from \"../constants/classnames\";\nimport { CLOSE, OPEN, POINTER_DOWN, ROOT } from \"../constants/globals\";\nimport { closeSharedInstance } from \"../core/component\";\nimport { Binder } from \"../core/events/binder\";\nimport { body, createButton, getElement, removeElement, replaceElement, toggleClassName } from \"../utils/dom\";\nimport { isString } from \"../utils/string\";\nimport { isset } from \"../utils/util\";\n\n/**\n * Creates the reference control.\n * \n * @param {string|Element} reference - User Reference.\n * @param {Alwan} param1 - Alwan instance.\n * @returns {object} - ReferenceElement control.\n */\nexport const Reference = (reference, alwan) => {\n    /**\n     * Visibility state.\n     */\n    let isOpen = false;\n\n    /**\n     * Reference element classes.\n     */\n    let classes = [];\n\n    /**\n     * Event binder.\n     */\n    const events = Binder();\n\n    /**\n     * Body.\n     */\n    const bodyElement = body();\n\n    /**\n     * Reference element.\n     *\n     * @type {Element|null}\n     */\n    const element = getElement(reference);\n\n    /**\n     * User reference.\n     * \n     * Check if the reference element is valid.\n     */\n    const userReference = bodyElement.contains(element) && element !== bodyElement ? element : null;\n\n    /**\n     * Alwan options.\n     */\n    const config = alwan.config;\n\n    /**\n     * Reference API.\n     */\n    const self = {\n        // If user reference is not valid element in the body, then create,\n        // a preset button and append it to the body.\n        _element: userReference ? userReference : createButton(PRESET_BUTTON_CLASSNAME, bodyElement),\n        \n        /**\n         * Initialize Reference element.\n         *\n         * @param {object} param - Alwan options. \n         */\n        _init({ preset, classname }) {\n            let element = self._element;\n\n            // If the user reference is valid then replace it with the preset button,\n            // if preset option is true.\n            if (userReference && preset !== (userReference !== element)) {\n                if (preset) {\n                    // Replace user reference with a preset button.\n                    element = replaceElement(createButton(PRESET_BUTTON_CLASSNAME, null, { id: userReference.id }), userReference);\n                } else {\n                    // Replace preset button with the user reference.\n                    element = replaceElement(userReference, element);\n                }\n            }\n\n            // Add custom classes to the preset button.\n            if (! userReference || preset && isString(classname)) {\n                // Remove previously add classes.\n                toggleClasses(element, classes, false);\n                classes = classname.split(/\\s+/);\n                // Add the new classname.\n                toggleClasses(element, classes);\n            }\n\n            self._element = element;\n        },\n\n        /**\n         * Gets current picker state (opened or closed).\n         *\n         * @returns Picker state.\n         */\n        _isOpen: () => isOpen,\n\n        /**\n         * Shows the color picker.\n         *\n         * @param {boolean} silent - Indicate whether to dispatch the open event or not.\n         */\n        _open(silent) {\n            if (! isOpen && ! config.disabled) {\n                closeSharedInstance(alwan, config, true);\n                alwan._color._updateAll();\n                alwan._components._app._reposition();\n                setState(true, silent);\n            }\n        },\n\n        /**\n         * Hides the color picker.\n         *\n         * @param {boolean} silent - If true don't dispatch close event.\n         * @param {boolean} forced - Close the color picker event if its toggle option is set to false.\n         */\n        _close(silent, forced) {\n            if (isOpen && (config.shared || config.toggle || forced)) {\n                setState(false, silent);\n            }\n        },\n\n        /**\n         * Opens/Closes the color picker.\n         */\n        _toggle() {\n            isOpen ? self._close() : self._open();\n        },\n\n        /**\n         * Changes state Disable/Enable.\n         *\n         * @param {boolean} disabled - Disabled state.\n         */\n        _toggleDisable(disabled) {\n            config.disabled = disabled;\n\n            if (disabled) {\n                self._close(true, true);\n            } else if (! config.toggle) {\n                self._open(true);\n            }\n\n            self._element.disabled = disabled;\n        },\n\n        /**\n         * Destroy reference component.\n         */\n        _destroy() {\n            if (userReference) {\n                self._init({ preset: false });\n            } else {\n                self._element = removeElement(self._element);\n            }\n            events._unbindAll();\n        }\n    }\n\n    /**\n     * Shows/Hide root element (container) and updates the state.\n     *\n     * @param {boolean} state - open or close.\n     * @param {boolean} silent - Don't dispatch the event.\n     */\n    const setState = (state, silent) => {\n        toggleClassName(alwan._components._app._root, OPEN_CLASSNAME, state);\n        isOpen = state;\n\n        if (! silent) {\n            alwan._events._dispatch(state ? OPEN : CLOSE, self._element);\n        }\n    }\n\n    /**\n     * Adds/Removes array of classes to/from an element.\n     *\n     * @param {Element} element - Element.\n     * @param {string[]} tokensArray - Array of classnames.\n     * @param {boolean} toggler - True to add classes, false to remove them.\n     */\n    const toggleClasses = (element, tokensArray, toggler = true) => {\n        tokensArray.forEach(className => {\n            toggleClassName(element, className, toggler);\n        });\n    }\n\n    /**\n     * Handles Document clicks that results in opening/closing the Color picker.\n     *\n     * @param {PointerEvent} param0 - Event.\n     */\n    const handleClick = ({ target }) => {\n        if (target === self._element) {\n            self._toggle();\n            // If The click is outside the color picker container and it displayed as,\n            // popover then close it.\n        } else if (isOpen && config.popover && ! alwan._components._app._root.contains(target)) {\n            self._close();\n        }\n    }\n\n    // Event listener.\n    events._bind(ROOT, POINTER_DOWN, handleClick);\n\n    return self;\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ALWAN_CLASSNAME","CONTAINER_CLASSNAME","SWATCH_CLASSNAME","PRESET_BUTTON_CLASSNAME","COLLAPSE_CLASSNAME","ROOT","document","HTML","documentElement","BUTTON","OPEN","CLOSE","COLOR","CLICK","POINTER_DOWN","KEY_DOWN","INPUT","CHANGE","FOCUS_IN","HEX_FORMAT","RGB_FORMAT","HSL_FORMAT","HSV_FORMAT","COLOR_PROPERTY","COLOR_FORMATS","INSERT_BEFORE_FIRST_CHILD","isString","value","trimString","str","trim","Binder","eventListenersData","toggleEventListener","eventTarget","events","handler","toggler","forEach","event","_bind","push","_unbindAll","target","keys","assign","setPrototypeOf","objectIterator","object","fn","props","merge","sources","isEqual","obj1","obj2","every","isset","body","getElement","reference","context","all","Element","insertElement","element","targetElement","where","insertAdjacentElement","setHTML","html","innerHTML","createElement","tagName","className","details","insertPosition","name","setAttribute","getBounds","x","y","top","left","right","clientWidth","bottom","clientHeight","getBoundingClientRect","parent","parentElement","replaceElement","newElement","oldElement","replaceChild","removeElement","remove","getScrollableAncestors","scrollables","test","getComputedStyle","overflow","setCustomProperty","property","style","setProperty","toggleVisibility","display","toggleClassName","token","classList","toggle","createButton","BUTTON_CLASSNAME","type","translate","transform","createSlider","max","step","SLIDER_CLASSNAME","parseFloat","float","parseInt","int","isFinite","isNumeric","Number","min","abs","round","PI","Math","numberRange","number","upperBound","lowerBound","normalizeAngle","angle","TOP","BOTTOM","RIGHT","LEFT","START","CENTER","END","dimension","App","alwan","popper","scrollableAncestors","popperEvents","updatePopper","e","_isOpen","_update","_reference","scrollable","elementX","elementY","elementBottom","elementRight","scrollableX","scrollableY","scrollableBottom","scrollableRight","_close","handleAccessibility","elementToFocusOn","lastFocusableElement","shiftKey","paletteElement","_components","_palette","_element","pop","preventDefault","focus","_root","_setup","options","instance","theme","popover","position","margin","id","shared","disabled","_init","dataset","_open","container","_margin","_position","coordinates","fallbackSides","fallbackAlignments","start","center","end","side","alignment","split","domBounds","referenceBoundingRect","containerBoundingRect","some","referenceSide","axis","domBound","referenceBound","containerSpace","containerDimension","referenceLowerBound","referenceUpperBound","upperBoundDistance","offset","createPopper","window","_toggleDisable","_reposition","_getInstance","_destroy","clipboardSVG","stringify","color","format","opaque","percentage","opacity","a","k","s","v","toHex","toString","RGBToHEX","r","g","b","HSVToHSL","h","l","ctx","getContext","HSL_REGEX","HEX_REGEX","ANGLE_COEFFICIENT_MAP","deg","turn","rad","grad","parseColor","asString","find","HSVToRGB","input","exec","fillStyle","hex","slice","map","_format","_color","sharedComponents","instanceCount","createComponents","_app","markerX","markerY","paletteBounds","overlayElement","isPointerDown","palette","tabindex","marker","width","height","keyboardX","ArrowRight","ArrowLeft","keyboardY","ArrowDown","ArrowUp","moveMarkerAndUpdateColor","change","_events","_dispatch","_saveState","clientX","clientY","_triggerChange","_options","Palette","_utility","previewElement","copyButton","isCopied","preview","copy","config","clipboard","navigator","_getColorByFormat","writeText","select","execCommand","blur","Utility","_sliders","alphaSlider","hueSlider","_setValue","Sliders","_inputs","inputsContainer","switchButton","formatIndex","inputsMap","formats","isChanged","inputs","filter","length","indexOf","build","includes","fields","singleInput","field","labelElement","_set","Inputs","_swatches","swatches","collapseButton","swatchesLength","isCollapsible","toggleSwatches","Array","isArray","_add","_remove","swatch","index","findIndex","children","splice","getPropertyValue","Swatches","isShared","components","destroyComponents","closeSharedInstance","setup","app","RGB","rgbString","state","HSV","colorData","asArray","reduce","output","channel","hsv","rgb","isInputs","_updateAll","source","isRGB","cMax","range","RGBToHSV","HSLToHSV","_value","hsl","initialize","useComponents","defaults","classname","preset","default","Alwan","VERSION","constructor","this","listeners","_addListener","eventType","eventHandler","_removeListeners","handlerToRemove","handlers","_array","Dispatcher","isOpen","classes","bodyElement","userReference","contains","toggleClasses","silent","setState","forced","_toggle","tokensArray","Reference","setOptions","open","close","on","off","setColor","getColor","addSwatch","removeSwatch","enable","disable","reset","reposition","trigger","destroy"],"sourceRoot":""}