{"version":3,"file":"js/alwan.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,QAAS,GAAIH,GACM,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,GACjB,CATD,CASGK,MAAM,WACT,O,wBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,SAASL,EAASM,GACzC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAG3E,ECPAF,EAAwB,SAASQ,EAAKC,GAAQ,OAAOL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,EAAO,G,4CCA/F,MAAMI,EAAkB,QAClBC,EAAuB,GAAED,eACzBE,EAAqB,GAAEF,aACvBG,EAAoB,GAAEH,YACtBI,EAAqB,GAAEJ,aACvBK,EAAoB,GAAEL,YACtBM,EAAyB,GAAEN,iBAC3BO,EAAoB,GAAEP,YACtBQ,EAAqB,GAAER,aACvBS,EAAwB,GAAET,iBAC1BU,EAA0B,GAAEV,mBAC5BW,EAAmB,GAAEX,WACrBY,EAAoB,GAAEZ,YACtBa,EAAoB,GAAEb,YACtBc,EAAsB,GAAEd,cACxBe,EAA2B,GAAEf,mBAC7BgB,EAAsB,GAAEhB,cACxBiB,EAA6B,GAAEjB,mBAE/BkB,EAAmB,GAAElB,WACrBmB,EAAkB,GAAEnB,UACpBoB,EAAsB,GAAEpB,cCrBxBqB,EAAOC,SACPC,EAAcF,EAAKG,gBAEnBC,EAAgB,OAEhBC,EAAS,SAETC,EAAO,OACPC,EAAQ,QACRC,EAAQ,QACRC,EAAQ,QACRC,EAAe,cACfC,EAAe,cACfC,EAAa,YAGbC,EAAW,UACXC,EAAQ,QACRC,EAAS,SAMTC,EAAa,MACbC,EAAa,MAMbC,EAAgB,CARH,MAQgBF,EAAYC,GAGzCE,EAA4B,aAC5BC,EAAe,WACfC,EAA0B,YAE1BC,EAAa,aAKbC,EAAa,CACtBC,WAAY,EACZC,WAAY,GAMHC,EAAa,CACtBC,UAAW,EACXC,SAAU,GC9CDC,EAAW,CAACC,EAAQC,EAAOC,KACpCF,EAAOG,iBAAiBF,EAAOC,EAA/B,EAUSE,EAAc,CAACJ,EAAQC,EAAOC,KACvCF,EAAOK,oBAAoBJ,EAAOC,EAAlC,GCnBS,KAAEI,EAAMC,OAAQC,EAAhB,eAAuBC,EAAgB/D,UAASA,GAAKN,QACnDsE,KAAMC,EAAR,QAAiBC,GAAYC,MAW7BC,GAAiB,CAACC,EAAQC,KACnC,IAAIC,EAAQX,EAAKS,GACjB,IAAK,MAAMtE,KAAQwE,EAChBD,EAAGD,EAAOtE,GAAOA,EACnB,EAUQyE,GAAe,CAACC,EAAQC,KACjCN,GAAeM,GAAS,CAACC,EAAKnF,KACtBA,KAAOiF,IACY,iBAARE,GAAqBT,EAAQS,GAIpCF,EAAOjF,GAAOkF,EAAQlF,IAHtBiF,EAAOjF,GAAOsE,EAAM,CAAC,EAAGW,EAAOjF,IAC/BgF,GAAaC,EAAOjF,GAAMmF,IAIjC,GARL,ECrBSC,GAAYC,GACG,iBAAVA,EASLC,GAAQD,GAAkB,MAATA,EASjBE,GAAc,EAAGC,SAAQC,YAAaD,GAAUC,ECfhDC,GAAc,IAAM1D,EAAK2D,KAUzBC,GAAa,CAACC,EAAWC,EAAUJ,KAAeK,GAAM,IAC7DX,GAASS,IAAcA,EAAUG,OAC1BF,EAAS,iBAAgBC,EAAM,MAAQ,KAAMF,GAGpDA,aAAqBI,SAAWP,KAAcQ,SAASL,IAAcA,IAAcH,KAC5EG,EAGJ,KAWEM,GAAgB,CAACC,EAASC,EAAeC,EAAQjD,KACtD+C,GAAWC,GACXA,EAAcE,sBAAsBD,EAAOF,EAC9C,EASQI,GAAU,CAACJ,EAASK,KAC7BL,EAAQM,UAAYD,CAApB,EAaSE,GAAgB,CAACC,EAASC,EAAWR,EAAeS,EAASC,KACtE,MAAMX,EAAUpE,EAAK2E,cAAcC,GAAW,OAkB9C,OAhBIC,IACAT,EAAQS,UAAYA,GAGxBjC,GAAekC,GAAW,CAAC,GAAG,CAACzB,EAAO2B,KACrB,SAATA,EACAR,GAAQJ,EAASf,GACVA,GACPe,EAAQa,aAAaD,EAAM3B,EAC9B,IAGDgB,GACAF,GAAcC,EAASC,EAAeU,GAGnCX,CAAP,EASSc,GAAad,IACtB,IAAIe,EAAGC,EAAGC,EAAOC,EAAQC,EAAOC,EAUhC,OARIpB,IAAYpE,GACZmF,EAAIC,EAAI,EACRC,EAAQE,EAAQrF,EAAYuF,YAC5BH,EAASE,EAAStF,EAAYwF,gBAE3BP,IAAGC,IAAGC,QAAOC,SAAQC,QAAOC,UAAWpB,EAAQuB,yBAG/C,CAACR,EAAGC,EAAGC,EAAOC,EAAQC,EAAOC,EAApC,EAUSI,GAAiB,CAACxB,EAASyB,KACpCzB,EAAQ0B,YAAYD,GACbA,GAQEE,GAAiB3B,IACtBA,GACAA,EAAQ4B,SAGL,MAUEC,GAAuB,CAAC7B,EAAS8B,EAAY,CAAClG,MAEnDoE,IACAA,EAAUA,EAAQ+B,eAGhB/B,GAAWA,IAAYV,MAIzB,mCAAmC0C,KAAKC,iBAAiBjC,GAASkC,WAClEJ,EAAUK,KAAKnC,GAGZ6B,GAAqB7B,EAAS8B,IAP1BA,GAkBFM,GAAiB,CAACpC,EAASqC,EAAUpD,IAE1Ce,EACOA,EAAQsC,MAAMpD,GAAMD,GAAS,cAAgB,oBAAoB,WAAaoD,EAAUpD,GAG5F,GAWEsD,GAAkB,CAACvC,EAASwC,EAAQC,KAEzCzD,GAASwD,KACTA,EAAS,CAACA,IAGdA,EAAOE,SAAQC,IACPA,GACA3C,EAAQ4C,UAAUvD,OAAOsD,EAAOF,EACnC,GAHL,EAkBSI,GAAe,CAACpC,EAAWR,EAAeS,EAASoC,EAAOC,EAAOpC,IACnEJ,GACHtE,EACArB,EAAmB,IAAM6F,EACzBR,EACA/B,EAAM,CACF8E,KAAM/G,EACN,CAACiB,GAAa4F,EACdC,MAAOA,GAASD,GACjBpC,GACHC,GAWKsC,GAAY,CAACjD,EAASe,EAAGC,KAClChB,EAAQsC,MAAMY,UAAa,aAAYnC,OAAOC,MAA9C,EAYSmC,GAAe,CAAC1C,EAAW2C,EAAQC,EAAKC,IAC1C/C,GAAc7D,EAAO5B,EAAmB,IAAM2F,EAAW2C,EAAQ,CAAEJ,KAAM,QAASK,MAAKC,SASrFC,GAAkB,CAACtD,EAAeC,IACpCK,GAAc,GAAI/F,EAAqByF,EAAe,CAAC,EAAGC,GASxDsD,GAAW,CAACxD,EAAS8C,KAC1B9C,GACAA,EAAQa,aAAa3D,EAAY4F,EACpC,EC1PQW,GAAY,CAACC,EAAeC,KAOrC,IAAI3D,EAAU0D,GAAiBb,GAAavH,EAAyBgE,MAKjEsE,EAAgB,GAKhBC,EAAc,KACdF,EAAMtE,QAAN,EAMJ,MAAO,CAMHyE,EAAK,IAAM9D,EAOX+D,GAAM,OAAEC,EAAF,UAAUC,IAERP,GAAiBM,KAAYN,IAAkB1D,KAG3CA,EAFAgE,EAEUxC,GAAekC,EAAeb,GAAavH,EAAyB,KAAM,CAAE4I,GAAIR,EAAcQ,MAG9F1C,GAAexB,EAAS0D,IAI1CjG,EAASuC,EAAS3D,EAAOwH,GAGlBH,IAAiBM,IAAWhF,GAASiF,KAExC1B,GAAgBvC,EAAS4D,GAAe,GACxCA,EAAgBK,EAAUE,MAAM,OAEhC5B,GAAgBvC,EAAS4D,GAAe,GAE/C,EAODQ,EAAaC,GACT,GAAInF,GAAMmF,GAAW,CACjB,MAAM,OAAExF,EAAF,EAAUyF,GAAgBX,EAC1BlB,EAAU6B,EAAYC,EAAKC,EAEjC3F,EAAOwF,SAAWrE,EAAQqE,WAAcA,EAEpCA,EACA5B,EAAQkB,GAAO,GAAO,GACbxE,GAAYN,IACrB4D,EAAQkB,GAAO,GAAM,EAE5B,CACJ,EAKDc,IACQf,GACAgB,KAAKX,EAAM,CAAEC,QAAQ,IACrBlG,EAAYkC,EAAS3D,EAAOwH,IAE5B7D,EAAU2B,GAAc3B,EAE/B,EAnEL,GCrCW2E,WAAYC,GAAOC,SAAUC,GAAKC,SAAUC,IAAcC,QAC5D,IAAEC,GAAF,IAAO7B,GAAP,IAAY8B,GAAZ,MAAiBC,GAAjB,GAAwBC,IAAOC,KAU/BC,GAAc,CAACC,EAAQC,EAAa,IAAKC,EAAa,IACxDR,GAAI7B,GAAImC,EAAQE,GAAaD,GAS3BE,GAAiBC,IAClBR,GAAMQ,GAAS,IAAM,KAAO,ICHlCC,GAAgB,CAClBC,IAAK,CAZG,EAEG,EADD,EAFD,GAcT1E,OAAQ,CAXG,EAFH,EACE,EAFD,GAeTD,MAAO,CAbG,EAFD,EACD,EAEG,GAaX4E,KAAM,CAhBG,EAEC,EADF,EAEG,IAmBTC,GAAqB,CACvBC,MAAO,CAlBG,EACC,EACH,GAiBRC,OAAQ,CAlBG,EADD,EAEF,GAkBRC,IAAK,CAlBG,EADG,EADD,ICGDC,GAAM,CAACjN,EAAMwK,KAItB,IAAI0C,EAAkB,KAKlBC,GAAS,EAQb,MAAMC,EAAS,CAACzH,EAAS0H,EAAW7C,KAEhC,MAAM8C,GADN9C,EAAQ6C,GACiBlC,GACnB,MAAEoC,EAAF,QAASC,EAAT,OAAkBjJ,EAAlB,SAA0BkJ,EAA1B,OAAoCC,EAApC,GAA4C3C,GAAOpF,EACnDgI,EAAanD,EAAMoD,EAAWjD,IAC9B7D,EAAgBT,GAAW9B,IAAWoJ,EACtCzH,EAASF,GAAYL,GAEvBE,GAASkF,KAAS8C,GAASP,KAC3BtN,EAAK+K,GAAKA,GAId1F,GAAeiI,GAAY,EAAG1C,QACtBA,GACAA,EAAMjF,EAAS6E,EAClB,IAILxK,EAAK8N,QAAQP,MAAQA,EAGfrH,GACFmF,EAAQb,GAAO,GAAM,GAKzBmD,EAAWxE,MAAM4E,QAAUP,GAAWtH,EAAS,GAAK,OAGpDkD,GAAgBpJ,EAAMsC,EAAiBkL,GAEnCN,IACAA,EAAgB5B,IAChB4B,EAAkB,MAGlBM,EACAN,ED5BiB,EAAC3I,EAAQyJ,GAAaC,IAASC,KAAaC,EAAYC,KAC7EvI,GAASoI,KACTA,EAAUxC,GAAMwC,IAEpB,MAAMP,EAAS7B,GAAUoC,GAAWA,EAAU,GACvCI,EAAMC,GAAazI,GAASqI,GAAaA,EAAUlD,MAAM,KAAO,GACjEuD,EAAiB7B,GAAc2B,IAAS3B,GAAczE,OACtDuG,EAAsB3B,GAAmByB,IAAczB,GAAmBE,OAC1E0B,EAAoB/F,GAAqBnE,GAKzCmK,EAAU,KACZ,MAAMC,EAAiBhH,GAAUlF,GAC3BmM,EAAejH,GAAUpD,GACzBsK,EAAkBlH,GAAUqG,GAC5Bc,EAAc,GAKpBP,EAAeQ,MAAMV,IAIjB,IAAIW,EAAOX,EAAO,EAElB,MAAMY,EAAUN,EAAeN,GAEzBa,EAAaN,EAAaP,GAI1Bc,EAAgBzB,EAASmB,EAAgBG,EAAO,GAEtD,GAAIG,GAAiBnD,GAAIiD,EAAUC,GAAa,CAI5CJ,EAAYE,GAAQE,GAAcb,GAAQ,GAAKc,EAAgBzB,GAI/DsB,GAAQA,EAAO,GAAK,EACpB,MAAMI,EAAqBP,EAAgBG,EAAO,GAI5CK,EAAmBT,EAAaI,GAChCM,EAAmBV,EAAaI,EAAO,GAGvCO,EAAqBZ,EAAeK,EAAO,GAAKK,EAEhDG,GAAUJ,EAAqBR,EAAaI,EAAO,IAAM,EA0B/D,OArBAR,EAAoBO,MAAMT,GA5F5B,IA8FUA,GAAuBc,GAAsBG,GAC7CT,EAAYE,GAAQK,GACb,GA/FhB,IAkGSf,GACAkB,GAAUF,GACVE,GAAUD,GAEVT,EAAYE,GAAQM,EAAmBE,GAChC,GAtGnB,IAwGYlB,GAAqBc,GAAsBE,IAC3CR,EAAYE,GAAQM,EAAmBF,GAChC,MAKR,CACV,KAOLtF,GACIkE,KACIc,EAAYW,KAAI,CAAC3J,EAAOkJ,IACxB/C,GACIlG,GAAMD,GACNA,GACG6I,EAAeK,EAAO,GAAKH,EAAgBG,EAAO,IAAM,KANvE,EAeEU,EAAY,IACPjB,EAAkBkB,OAAOC,IAC5B,MAAOhI,EAAGC,EAAJ,EAAWG,EAAOC,GAAUN,GAAUpD,IACrCsL,EAAWC,EAAZ,EAA2BC,EAAeC,GAAkBrI,GAAUiI,GAE5E,OACI/H,EAAImI,GAAkB/H,EAAS6H,GAAalI,EAAImI,GAAiB/H,EAAQ6H,CAD7E,IASFI,EAAe,KACjB9B,EAAWO,EAASgB,EAApB,EAQEQ,EAAiB3K,IACnBkJ,EAAkBlF,SAASqG,IACvBrK,EAAGqK,EP/JO,SO+JWK,EAArB,IAEJ1K,EAAG4K,OPhKW,SOgKKF,GACnB1K,EAAG9C,EAAMa,EAAU8K,GACnB7I,EAAG9C,EAAMU,EAAciL,EAAvB,EAQJ,OAJAM,IAEAwB,EAAc5L,GAEP,CACHoK,IAKApD,IAEI4E,EAAcvL,GACdqJ,EAAU7E,MAAMY,UAAY,EAC/B,EAVL,ECjH0BqG,CACdtJ,EACA9G,EACA,CACIiO,EAASP,EACTQ,EAAWT,GAEfU,EACAC,GAKJxH,GACI5G,EACA8G,EACAA,IAAkB6G,EAAa9J,EAAeC,GAItD0G,EAAM6F,EAAO3B,EAAQ,CAAC,EAAG,MAAM,EAA/B,EASEP,EAAa,CAACmC,EAAQC,MACpBpD,GAAYnH,GAAYwE,EAAM9E,UAC1B6K,IACIpD,GAGAmD,IAEI9F,EAAM9E,OAAO8K,eAEbnF,EAAQb,GAAO,IAKnBa,EAAQb,GAAO,GAAM,GAIzBa,EAAQb,GAAO,GAAO,GAE7B,EAWC4D,EAAwBqC,IAC1B,GAAItD,EAAQ,CACR,IAEIuD,EACAC,EACAC,EACAC,GALA,OAAEtM,EAAF,IAAU9D,EAAV,SAAeqQ,GAAaL,EAC5B9C,EAAanD,EAAMoD,EAAWjD,IR5GxB,WQuHNlK,GACC8D,IAAWoJ,IAAe3N,EAAK2G,SAASpC,KAAaW,EAAQyI,EAAWoD,QAAU,IAAIhC,MAAMpF,GAAUA,EAAMhD,SAASpC,KAEtH8G,EAAQb,GAAO,GR3HZ,QQ4HI/J,IACPiQ,EAAoBxL,EAAQmB,GAAW,0BAA2BrG,GAAM,IACxE2Q,EAAwBD,EAAkB,GAC1CE,EAAuBF,EAAkBM,MAErCzM,IAAWoJ,GAAemD,GAIlBA,GAAYvM,IAAWoM,IAA4BG,GAAYvM,IAAWqM,KAGlFC,EAAmBlD,GAJnBkD,EAAmBF,EAOnBE,IACAJ,EAAEQ,iBACFJ,EAAiBK,SAG5B,GAUC7F,EAAU,CAACgC,EAAU8D,EAAOC,KAG9B,MAAMC,GAFNhE,EAAWA,GAAY7C,GAES9E,OAE1B2L,EAAenG,WAAYkG,IAEvBrL,GAAMoL,KAGJhE,GAAUE,IAAa7C,GACvBa,EAAQb,GAAO,GAGnB2G,GAAUhE,GAGVgE,IAAUhE,IAAWnH,GAAYqL,IAAmBD,KAChDD,IACI9D,IAAa7C,GAGb4C,EAAOiE,EAAgBhE,GAIvB8D,GACAG,KAMJjE,IAAa7C,IACb2C,EAASgE,EACT/H,GAAgBpJ,EAAMuC,EAAgB4O,GACtC3G,EAAM+G,EAAQC,EAAUL,EAAQpO,EAAOC,EAAOhD,KAGzD,EAMCsR,EAAc,KACZpE,GACAA,EAAgBwB,GACnB,EAsBL,MAAO,CACHtB,IACAkE,IACAjG,IACAoG,EAlBY,IACLtE,EAkBP7B,EAZa,KACT4B,GACAA,EAAgB5B,IAEpB9C,GAAcxI,EAAd,EAGJ,EC3PS0R,GAAgB,sNCShBC,GAAY,CAACC,EAAOC,KAC7B,IAAIC,EAAU,GACVC,EAAIH,EAAMG,EACVC,EAAMH,EAOV,OALIE,EAAI,IACJC,GAAO,IACPF,EAAU,KAAOC,GAGjBF,IAAWpO,EACJuO,EAAO,IAAGJ,EAAMK,MAAML,EAAMM,MAAMN,EAAMO,EAAIL,KAGhDE,EAAO,IAAGJ,EAAMQ,MAAMR,EAAMS,OAAOT,EAAMU,KAAKR,IAArD,ECjBES,GAAMnL,GAAc,UAAUoL,WAAW,MAKzCC,GAAY,sIACZC,GAAY,kBAIZC,GAAwB,CAC1BC,IAAK,EACLC,KAAM,IACNC,IAAK,IAAM5G,GACX6G,KAAM,IAWGC,GAAa,CAAClN,EAAQ,GAAImN,KAEnC,IAAIrB,EACAC,EACAG,EAAM,GAMJnM,GAASC,GAaXkM,EAAMlM,EAAMW,QAZZX,EAAQA,GAAS,CAAC,EAElB+L,EAAS,CAACpO,EAAYC,GAAYwP,MAAKrB,GAC5BA,EAAO7G,MAAM,IAAI2E,OAAMlP,GACnBoL,GAAUJ,GAAM3F,EAAMrF,SAIjCoR,IACAG,EAAML,GAAU7L,EAAO+L,KAS/B,IAAKsB,EAAOf,EAAG3F,EAAO4F,EAAGC,EAAGP,EAAI,EAAGqB,GAAcX,GAAUY,KAAKrB,IAAQ,GAGxE,GAAImB,EAQAvB,EAAQ,CACJQ,EAAG5F,GAAe4F,GAAKO,GAAsBlG,GAASkG,GAAsBlG,GAAS,IACrF4F,EAAGpG,GAAMG,GAAYiG,IACrBC,EAAGrG,GAAMG,GAAYkG,IACrBP,EAAG3F,GAAYgH,EAAarB,EAAI,IAAMA,EAAG,IAE7CF,EAASnO,OAUT,GARAmO,EAASpO,EAET8O,GAAIe,UAAYzQ,EAChB0P,GAAIe,UAAYtB,EAChBA,EAAMO,GAAIe,UAINZ,GAAU7J,KAAKmJ,GAEfJ,EAAQ,CACJK,EAAGtG,GAAIqG,EAAIuB,MAAM,EAAG,GAAI,IACxBrB,EAAGvG,GAAIqG,EAAIuB,MAAM,EAAG,GAAI,IACxBpB,EAAGxG,GAAIqG,EAAIuB,MAAM,EAAG,GAAI,IACxBxB,EAAG,OAEJ,CAEH,MAAOE,EAAGC,EAAGC,EAAGJ,GAAK,WAAWsB,KAAKrB,GAAK,GAAGhH,MAAM,KAAKyE,KAAI3J,GAAS2F,GAAM3F,KAC3E8L,EAAQ,CAAEK,IAAGC,IAAGC,IAAGJ,IACtB,CAQL,OAJAH,EAAMG,EAAI9F,GAAgB,IAAV2F,EAAMG,GAAW,IAEjCC,EAAML,GAAUC,EAAOC,GAEhBoB,EAAWjB,EAAM,CAACJ,EAAOC,EAAQG,EAAxC,EC3FSwB,GAAW,CAACC,EAAKjJ,KAO1B,IAAIwD,EAOA0F,EAOAC,EAKJ,MAAO,CAOH/I,GAAM,SAAEgJ,EAAF,eAAYC,GAAkBxG,GAChC7C,EAAQ6C,GAAY7C,EACpBkJ,EAAgB,GAEZvO,EAAQyO,KACRF,EAAgBE,EAChB5F,EAAYxF,GAAcwF,GAC1B2F,EAAiBnL,GAAcmL,GAE3BC,EAASE,SAET9F,EAAY5G,GAAc,GAAIlF,EAAoBuR,GAElDG,EAASrK,SAAQqI,IACb3I,GACIS,GACIzH,EACA+L,EACA,CAAC,EACDxD,EAAM9E,OAAOqO,KAAKC,QAAQC,OAAS,KAAOrC,EAC1CA,GAEJ3O,EACA+P,GAAWpB,GAAO,GATtB,IAeAiC,IACAF,EAAiBjK,GAAarH,EAA2BoR,EAAK,CAAEvM,KH5E/D,4IGgFD5C,EAASqP,EAAgBzQ,GAAO,KAC5BkG,GAAgB4E,EAAWxL,GAC3BgI,EAAM0J,YAAN,KAMR5P,EAAS0J,EAAW9K,GAAO,EAAGqB,aACvBA,IAAWyJ,GACVxD,EAAM6F,EAAO8D,EAAKlL,GAAe1E,EAAQtB,GAAQsB,GAAQ,EAC5D,KAIhB,EAOD6P,EAAKR,GACDpJ,EAAM9E,OAAOkO,SAAW,IAAKF,KAAkBE,GAC/CrI,KAAKX,EAAMJ,EAAM9E,OACpB,EAOD2O,EAAQT,GACJpJ,EAAM9E,OAAOkO,SAAWF,EAAcY,QAAO,CAACL,EAAQM,KAAYX,EAAS7E,MAAMyF,GAASA,IAASP,GAAUtI,GAAI6I,KAAUD,MAC3HhJ,KAAKX,EAAMJ,EAAM9E,OACpB,EA5EL,EC9BJ,IAAI+O,GAAmB,KAKnBC,GAAgB,EAQpB,MAAMC,GAAoBnK,IAEtB,MAAMxK,EAAOoH,GAAc,GAAIhG,EAAiB+E,MAC1CiF,EAAO6B,GAAIjN,EAAMwK,GACjBoK,EChBa,EAACnB,EAAKjJ,KAMzB,IAAIqK,EAOAC,EAOAC,EAOAC,EAKAC,GAAgB,EAKpB,MAAMC,EAAU9N,GAAc,GAAI9F,EAAmBmS,EAAK,CAAE0B,SAAU,MAKhEC,EAAShO,GAAc,GAAI7F,EAAkB2T,GAS7CG,EAA2B,CAAC5E,EAAG6E,KACjC,IACIC,EAAGC,GADD5N,EAAGC,EAAGC,EAAOC,GAAWgN,EAG1BtE,GACA7I,EAAI6I,EAAEgF,QAAU7N,EAChBC,EAAI4I,EAAEiF,QAAU7N,IAEhBD,EAAIiN,EAAUS,EAAS1N,EAAIE,EAAQ,IACnCD,EAAIiN,EAAUQ,EAASzN,EAAIE,EAAS,KAGxCH,EAAIwE,GAAYxE,EAAGE,GACnBD,EAAIuE,GAAYvE,EAAGE,GAEfH,IAAMiN,GAAWhN,IAAMiN,IACvBD,EAAUjN,EACVkN,EAAUjN,EACViC,GAAUsL,EAAQP,EAASC,GAE3BS,EAAK,EAAI1N,EAAIE,EACbyN,EAAID,GAAK,EAAI3N,GAAK,EAAIE,IAEtB0C,EAAM6F,EAAO3B,EAAQ,CACjBiH,EAAS,IAANH,GAAiB,IAANA,EAAU,GAAKD,EAAIC,GAAKzJ,GAAIyJ,EAAG,EAAIA,GACjDA,KACDN,GACN,EAwBCU,EAAOnF,IACLwE,GACAI,EAAyB5E,EAC5B,EAQCoF,EAAUpF,IACRwE,IACAzK,EAAM6F,EAAOyF,EAAQZ,GAAS,GAC9BF,EAAkBxM,GAAcwM,GAChCC,GAAgB,EACnB,EAkCL,OANA3Q,EAAS4Q,EAAS/R,GA5DAsN,IACRuE,IACFA,EAAkB5N,GAAc,GAAIhF,EAAoBO,IAG5D6H,EAAM6F,EAAO0F,IACbhB,EAAgBpN,GAAUuN,GAC1BD,GAAgB,EAChBI,EAAyB5E,EAAzB,IAqDJnM,EAAS7B,EAAMW,EAAcwS,GAC7BtR,EAAS7B,EAAMY,EAAYwS,GAC3BvR,EAAS4Q,EAAS5R,GAvBKmN,IACnB,MAAMhQ,EAAMgQ,EAAEhQ,IACRmH,EAAI5D,EAAWvD,IAAQ,EACvBoH,EAAI1D,EAAW1D,IAAQ,EACvBuV,EAAOxL,EAAM6F,GAEfzI,GAAKC,KACL4I,EAAEQ,iBAEF8D,EAAgBpN,GAAUuN,GAE1Bc,EAAKD,IACLV,EAAyB,KAAM,CAAEzN,IAAGC,MACpCmO,EAAKF,EAAQZ,GAAS,GACzB,IAYE,CAOHtK,EAAMqL,EAAU5I,GAEZhD,GAAS6K,GADT1K,EAAQ6C,GAAY7C,GACI9E,OAAOqO,KAAKmB,QACvC,EAQDxG,GAAQ,EAAE0D,EAAF,EAAKuD,EAAL,EAAQH,GAAKU,GAEjBjN,GAAeiM,EAAS,IAAK9C,GAEzB8D,IACAnB,EAAgBpN,GAAUuN,GAE1BJ,EAAUU,EAAIG,EAAI5J,GAAIyJ,EAAG,EAAIA,GAE7BX,GAAWC,EAAU,GAAK,EAAIU,EAAIV,GAAW,GAAKC,EAAc,GAChED,GAAW,EAAIA,GAAWC,EAAc,GAExCjL,GAAUsL,EAAQP,EAASC,GAElC,EAKDxJ,IACI3G,EAAYlC,EAAMW,EAAcwS,GAChCjR,EAAYlC,EAAMY,EAAYwS,EACjC,EAxCL,EDxIiBM,CAAQnW,EAAMwK,GACzBwD,EAAY5D,GAAgBpK,GAC5BoW,EElBa,EAAC3C,EAAKjJ,KAMzB,IAAI6L,EAOAC,EAKAC,EAOJ,MAAMC,EAAcrF,IAChBoF,EAAWpF,EACXlK,GAAQqP,EAAYnF,ENvCH,iKMuCsBO,GAAvC,EAQE+E,EAAY7E,IACd,IAAIuB,EAAQ/L,GACR7D,EACA,GACAZ,EACA,CAAEmD,MAAO8L,IAEbuB,EAAMuD,SACNjU,EAAKkU,YAAY,QACjBxD,EAAQ3K,GAAc2K,GACtBmD,EAAWpF,QAEXsF,GAAW,EAAX,EAMEI,EAAY,KACd,IAAML,IAAc/L,EAAM9E,OAAOwF,SAAU,CACvC,MAAM2L,EAAYC,UAAUD,UACtBjF,EAAQpH,EAAM6F,EAAO0G,GAAK,GAE5BF,EACAA,EAAUG,UAAUpF,GACPqF,MAAK,IAAMT,GAAW,KACtBU,OAAM,IAAMT,EAAS7E,KAElC6E,EAAS7E,EAEhB,GAML,MAAO,CAOHhH,GAAM,QAAEuM,EAAF,KAAWC,GAAQ/J,GACrB7C,EAAQ6C,EAERgJ,EAAiB7N,GAAc6N,GAC/BC,EAAa9N,GAAc8N,GAEvBa,IACAd,EAAiBjP,GAAc,GAC3B5F,EACAiS,EACA,CAAC,EACD7P,IAIJwT,IACAd,EAAa5M,GACThI,EACA2U,GAAkB5C,EAClB,CAAEvM,KAAMwK,IACRlH,EAAM9E,OAAOqO,KAAKC,QAAQoD,KAC1B,GACAxT,GAMJU,EAASgS,EAAYpT,EAAO0T,GAE5BtS,EAASgS,EftGL,QesGuB,IAAMC,GAAYC,GAAW,KACxDlS,EAASgS,EfrGA,YeqGuB,IAAMA,EAAWe,SAExD,EAODC,EAAS1F,GACL3I,GAAeoN,EAAgBpT,EAAO2O,EACzC,EAjDL,EFrDiB2F,CAAQvJ,EAAWxD,GAC9BgN,EGpBa,EAAC/D,EAAKjJ,KAMzB,IAAIiN,EAKJ,MAAMzJ,EAAY5G,GAAc,GAAIxF,EAAmB6R,GAOjDiE,EAAY1N,GAAanI,EAAsBmM,EAAW,KAO1D2J,EAAe,EAAGpT,SAAQsF,OAAMtF,QAAUuB,aACxC+D,IAASrG,EACTgH,EAAM6F,EAAOyF,EAAQvR,GAErBiG,EAAM6F,EAAO3B,EAAQnK,IAAWmT,EAAY,CAAEtF,EAAG,IAAMtM,GAAU,CAAEiM,EAAW,EAARjM,GAAavB,EACtF,EAUL,OAJAD,EAAS0J,EAAWzK,EAAOoU,GAC3BrT,EAAS0J,EAAWxK,EAAQmU,GAGrB,CAOH/M,GAAM,QAAEkH,GAAWzE,GACf7C,EAAQ6C,GAAY7C,EAEpB,MAAM,IAAEoN,EAAF,MAAOC,GAAUrN,EAAM9E,OAAOqO,KAAK+D,QAEzCL,EAAcjP,GAAciP,GAExB3F,EACA2F,EAAczN,GACVlI,EACAkM,EACA,EACA,KAGJxD,EAAM6F,EAAO3B,EAAQ,CAAEqD,EAAG,IAG9B1H,GAASqN,EAAWE,GACpBvN,GAASoN,EAAaI,EACzB,EASDnJ,GAAQ,EAAE0D,EAAF,EAAKL,GAAKgG,EAAW7B,GAEzBjN,GAAewO,EAAahU,EAAYsU,GAEpC7B,IACAwB,EAAU5R,MAAQ,IAAMsM,EAEpBqF,IACAA,EAAY3R,MAAQiM,GAG/B,EA/CL,EHpBiBiG,CAAQhK,EAAWxD,GAC9ByN,EIPY,EAACxE,EAAKjJ,KAOxB,IAAIwD,EAOAkK,EAOAC,EAYAC,EAOAC,EAdAC,EAAU,GAmBVC,GAAY,EAKhB,MAAMC,EAAW,IACNhO,EAAM9E,OAAO+S,ajBtDF,QiBsDiBH,EAAQF,GAMzCM,EAAQ,KAEVL,EAAY,CAAC,EAEb7P,GAAc0P,GACdA,EAAkB9Q,GAAc,GAAIpF,EAAkBgM,EAAW,CAAC,EAAGpK,GAErE,MAAMgO,EAAQpH,EAAM6F,EAAO0G,IAIrBlF,EAASyG,EAAQF,IACRI,IACT,CAAC3G,IACAA,GAAUrH,EAAM9E,OAAOoM,QAAU,IAAM,KAAK9G,MAAM,KAElDzB,SAAQoP,IASX,MAAMC,EAAexR,GAAc,QAAS,GAAI8Q,GAChDG,EAAUM,GAASvR,GAAc7D,EAAOxB,EAAiB6W,EAAc,CAAE/O,KAAM,OAAQ/D,MAAO8L,EAAM+G,GAAS,KAC7GvR,GAAc,OAAQ,GAAIwR,EAAc,CAAE1R,KAAMyR,GAAhD,IAMJrU,EAAS4T,EAAiB3U,EAAOoU,GACjCrT,EAAS4T,EAAiB1U,EAAQmU,GAElCrT,EAAS4T,EjBnGO,WiBmGqBzH,IAAQA,EAAElM,OAAOmS,QAAT,IAE7CpS,EAAS4T,EAAiB5U,GAAWmN,IAAkB,UAAVA,EAAEhQ,KAAmB+J,EAAMqO,OAA3B,GAA7C,EAMEC,EAAe,KAGjBV,GAAsBA,EAAqB,GAAKE,EAAQxE,OACxDtJ,EAAM6F,EAAO0I,EAAWT,EAAQF,IAChCM,GAAO,EAQLf,EAAe,EAAGpT,SAAQsF,WAE5B,GAAIA,IAASrG,EACTgH,EAAM6F,EAAOyF,EAAQvR,GAAQ,GAC7BgU,GAAY,MACT,CAEGA,IACF/N,EAAM6F,EAAO0F,IACbwC,GAAY,GAGhB,IAAIvG,EAAMzN,EAAOuB,MACb8L,EAAQ,CAAC,EAEP4G,MAEFnT,GAAegT,GAAW,CAAClF,EAAO1S,KAC9BmR,EAAMnR,GAAOgL,GAAM0H,EAAMrN,MAAzB,IAGJkM,EAAML,GAAUC,EAAO0G,EAAQF,KAGnC5N,EAAM6F,EAAO8D,EAAKnC,EAAKzN,EAC1B,GAML,MAAO,CAOHqG,GAAM,OAAEoO,EAAF,OAAUnH,GAAUxE,GACtB7C,EAAQ6C,GAAY7C,EAGpB8N,EAAU3U,GAEK,KAJfqV,EAASA,GAAU,CAAC,KAMhBV,EAAUA,EAAQhE,QAAQzC,GAAWmH,EAAOnH,MAGhD,MAAMiC,EAASwE,EAAQxE,OAGlBA,IACDwE,EAAU3U,GAEdyU,EAAqBlO,GAAIoO,EAAQW,QAAQpH,GAAS,GAClDrH,EAAM6F,EAAO0I,EAAWT,EAAQF,IAGhCpK,EAAYxF,GAAcwF,GAC1BmK,EAAe3P,GAAc2P,GAEzBrE,IAEA9F,EAAY5D,GAAgBqJ,EAAK5P,GACjC6U,IAEI5E,EAAS,IACTqE,EAAezO,GAAa,GAAIsE,EAAW,CAAE9G,KR9MjC,+HQ8M0DsD,EAAM9E,OAAOqO,KAAKC,QAAQ8E,cAChGxU,EAAS6T,EAAcjV,EAAO4V,IAGzC,EAODI,EAAQtH,GACE2G,GACFlT,GAAegT,GAAa,CAAC,GAAG,CAAClF,EAAO1S,KACpC0S,EAAMrN,MAAQ8L,EAAMnR,EAApB,GAGX,EAtDL,EJ1IgB0Y,CAAOnL,EAAWxD,GAGlC,MAAO,CACHY,IACAwJ,IACAwB,IACAoB,IACAS,IACAmB,EARc5F,GAASxT,EAAMwK,GAEjC,EAgBSqD,GAAYP,KACZmH,IAAoBnH,IAAemH,GASnC4E,GAAqB/L,IAC9B,GAAIO,GAASP,GAAa,CAEtB,GADAoH,KACIA,GAAgB,EAChB,OAEJD,GAAmB,IACtB,CAEDnH,EAAWlC,EAAKE,IAChBgC,EAAWsH,EAAStJ,IACpBgC,EAAa,CAAC,CAAd,EKlEEgM,GAASjN,IACHA,EAAS,GAAK,IAAM,IAAMA,EAAOkN,SAAS,IAwBzChU,GAAK,CAACiU,EAAGnH,EAAGC,KACrBkH,GAAK,GACEvN,GAAgE,KAAzDqG,EAAID,EAAItG,GAAIuG,EAAG,EAAIA,GAAKpI,IAAK,EAAG6B,GAAIyN,EAAI,EAAG,EAAIA,EAAG,OCpBvD5H,GAASpH,IAOlB,IAAIiP,EAOA5H,EAKJ,MAAMV,EAAQ,CAEViB,EAAG,EAGHuD,EAAG,EACHH,EAAG,EAGHnD,EAAG,EACHC,EAAG,EAGHL,EAAG,EACHC,EAAG,EACHC,EAAG,EAGHJ,EAAG,EAGH2H,IAAK,GACLC,IAAK,GACLC,IAAK,IAMHlU,EAAS8E,EAAM9E,OAErB,MAAO,CASHgJ,EAAQkL,EAAKC,EAAQ3D,GAAY,EAAOwD,GACpC,IAAMhU,EAAOwF,SAAU,CAEnB,MAAM,EAAE+G,EAAF,EAAKC,EAAL,EAAQC,EAAR,EAAWJ,GAAMZ,EAEvBpM,EAAMoM,EAAOyI,GACb7U,EACIoM,EACA,CACIkB,EAAGpG,GAAgB,IAAVkF,EAAMwE,GACfrD,EAAGrG,GAAgB,IAAVkF,EAAMqE,IAEnBkE,GD3CI,GAAGtH,IAAGuD,IAAGH,QAEtB,CACHvD,EAAG1M,GAFP6M,GAAK,GAEQuD,EAAGH,GACZtD,EAAG3M,GAAG6M,EAAI,EAAGuD,EAAGH,GAChBrD,EAAG5M,GAAG6M,EAAI,EAAGuD,EAAGH,KCsCGsE,CAAS3I,IAGpB,MAAM,EAAE8G,EAAF,EAAWrD,EAAX,EAAqB4C,EAArB,EAA+BpB,GAAa5L,EAAMW,EAClD4O,EAAYpI,GAAUR,EAAO1N,IAC5BsU,EAAWiC,GDrEV,GAAG/H,IAAGC,IAAGC,IAAGJ,OACzB,CAAC,IAAMuH,GAAMrH,GAAKqH,GAAMpH,GAAKoH,GAAMnH,GAAIJ,EAAI,EAAIuH,GAAMrN,GAAU,IAAJ8F,IAAY,ICoEpCkI,CAAS9I,GAEvCA,EAAMyI,IAAMjI,GAAUR,EAAOzN,GAC7ByN,EAAMwI,IAAM5B,EAAYiC,EACxB7I,EAAMuI,IAAMK,EAGZ9Q,GAAeuB,EAAMoD,EAAWjD,IAAO1H,EAAO8W,GAC9CnF,EAASlG,EAAQyC,EAAO+E,GACxBE,EAASkB,EAASyC,GAClBvC,EAAS9I,EAAQyC,EAAO4G,EAAW7B,GACnC+B,EAAQiB,EAAQ/H,IAIZ0I,GAAW1I,EAAMc,IAAMA,GAAKd,EAAMe,IAAMA,GAAKf,EAAMgB,IAAMA,GAAKhB,EAAMY,IAAMA,GAC1EvH,EAAM+G,EAAQC,EAAUvO,EAAO4W,EAEtC,CACJ,EAKD9D,IACI0D,EAAatI,EAAMU,EACtB,EAWDiE,EAAQ+D,EAAQK,KACPA,GAAUA,GAAST,IAAetI,EAAMU,KACzCrH,EAAM+G,EAAQC,EAAUhO,EAAQqW,EAEvC,EASD1F,EAAKvC,EAAOiI,EAAQM,GAChB,IACIT,EAAKE,GADJQ,EAAaC,EAAmBC,GAAqBtH,GAAWpB,GAIjET,EAAMkJ,KAAuBC,IACzBD,IAAsB5W,GACtBiW,EAAMU,EACNR,ED3FI,GAAG3H,IAAGC,IAAGC,IAAGJ,QAKhC,MAAMwI,EAAOrQ,GAJb+H,GAAK,IACLC,GAAK,IACLC,GAAK,KAGCqI,EAAOzO,GAAIkG,EAAGC,EAAGC,GACjBsI,EAAIF,EAAOC,EACXhF,GAAK+E,EAAOC,GAAQ,EAY1B,MAAO,CACHpI,EAAG5F,GAAmB,IAXhB,IAANiO,EACM,EACAF,IAAStI,GACPC,EAAIC,GAAKsI,EAAK,EAChBF,IAASrI,GACRC,EAAIF,GAAKwI,EAAI,EACdF,IAASpI,GACRF,EAAIC,GAAKuI,EAAI,EACd,IAIN9E,EAAG8E,EAAIA,GAAK,EAAIzO,GAAI,EAAIwJ,EAAI,IAAM,EAClCA,IACAzD,IAJJ,ECuEsB2I,CAAShB,KAEfE,EAAMQ,EACNR,EAAIjE,EAAIyE,EAAY/H,EAAI,IACxBuH,EAAIpE,EAAI4E,EAAY9H,EAAI,KAG5B/G,KAAKmD,EAAQkL,EAAKC,GAAQ,EAAMH,GAE5BS,GACA5O,KAAKuK,EAAQ+D,GAGxB,EAODc,EAAQ,KAAM,CACVvI,EAAGjB,EAAMiB,EACTC,EAAGlB,EAAMkB,EACTC,EAAGnB,EAAMmB,EAETL,EAAGd,EAAMc,EACTC,EAAGf,EAAMe,EACTC,EAAGhB,EAAMgB,EAETJ,EAAGZ,EAAMY,EAET4H,IAAKxI,EAAMwI,IACXD,IAAKvI,EAAMuI,IACXE,IAAKzI,EAAMyI,MAQfb,EAAW6B,GACP/I,EAASnM,EAAOmM,OAAS+I,CAC5B,EAOD7D,EAAO9D,GAAaA,EAAW9B,EAAMU,GAAUV,EAtInD,EC3DU0J,GAAW,CAMrB9P,GAAI,GAOJD,UAAW,GAOXyC,MAAO,QAOPrH,QAAQ,EAQRsH,SAAS,EAeTC,SAAU,eAOVC,OAAQ,EAOR7C,QAAQ,EAOR+G,MAAO/O,EAOPiY,QAASjY,EAUT0B,OAAQ,GAOR2G,UAAU,EAOV2G,OAAQ,MAQR4G,aAAa,EAQbO,OAAQ,CACJU,KAAK,EACLC,KAAK,EACLC,KAAK,GAQT9H,SAAS,EAOTqF,SAAS,EAOTC,MAAM,EAONxD,SAAU,GAQV3N,QAAQ,EAOR4N,gBAAgB,EAQhBrD,eAAe,EAKfuD,KAAM,CACFmB,QAAS,eACTlB,QAAS,CACLoD,KAAM,0BACN0B,aAAc,sBACd7E,OAAQ,gBAEZ6D,QAAS,CACLF,IAAK,aACLC,MAAO,oBCrLJ,MAAMkD,GAEH,eAAGC,QAKF,gBAAGH,GAQlBI,YAAY3U,EAAWX,GACnB,MAAM6E,EAAQe,KAEdf,EAAM9E,OAASX,EAAM,CAAC,EAAGgW,GAAMF,UAC/BrQ,EAAM+G,ECpBa/G,KAIvB,MAAM0Q,EAAY,CACd,CAACnY,GAAO,GACR,CAACC,GAAQ,GACT,CAACQ,GAAS,GACV,CAACP,GAAQ,IAGb,MAAO,CAOHuO,EAAU3H,EAAMgQ,GACNrP,EAAM9E,OAAOwF,WACdgQ,EAAUrR,IAAS,IAAIN,SAAQ4R,IAC5BA,EAAQpW,EAAM,CAAE8E,OAAMgQ,UAAUrP,EAAM6F,EAAOsK,KAA7C,GAGX,EAQDS,EAAa5W,EAAOC,GACZyW,EAAU1W,KAAY0W,EAAU1W,GAAO6W,SAAS5W,IAChDyW,EAAU1W,GAAOwE,KAAKvE,EAE7B,EAQD6W,GAAiB9W,EAAOC,GACdsB,GAAMvB,GAKD0W,EAAU1W,KACbuB,GAAMtB,GAENyW,EAAU1W,GAAS0W,EAAU1W,GAAO8P,QAAQ/O,GAAOA,IAAOd,IAG1DyW,EAAU1W,GAAS,IATvBa,GAAe6V,GAAW,CAACK,EAAQC,KAC/BN,EAAUM,GAAc,EAAxB,GAWX,EAhDL,EDSoBC,CAAWjR,GAC3BA,EAAM6F,EAASuB,GAAMpH,GACrBA,EAAMoD,EAAatD,GAAUjE,GAAWC,GAAYkE,GACpDA,EAAMkR,WAAW/V,EACpB,CAOD+V,WAAW/V,GACPA,EAAUA,GAAW,CAAC,EAEtB,IAII2H,EAAYqO,EAJZnR,EAAQe,KACR7F,EAAS8E,EAAM9E,QACf,MAAEkM,EAAF,SAAS1G,GAAavF,EACtBqQ,EAAOxL,EAAM6F,EAGjB7F,EAAMoD,EAAW3C,EAAaC,GAExBxF,EAAOwF,WACTzF,GAAaC,EAAQC,GACrB6E,EAAMW,EAAcmC,ER4BF9C,KAC1B,IAAI,EAAEW,EAAazF,QAAQ,OAAEO,IAAYuE,EAGzC,GAAIW,EAAa,CAIb,GAAK0C,GAAS1C,KAAkBlF,EAC5B,OAAOkF,EAIXA,EAAYC,EAAKC,EAAQb,GAAO,GAAO,GAKvC6O,GAAkBlO,EACrB,CAED,OAAIlF,GAEMwO,KACFA,GAAmBE,GAAiBnK,IAGxCkK,KAEOD,IAIJE,GAAiBnK,EAAxB,EQ7DyCoR,CAAcpR,GAC/CA,EAAMoD,EAAWhD,EAAMlF,GACvBiW,EAAMrO,EAAWlC,EAEbyC,GAASP,IACTqO,EAAItQ,EAAQ,MAAM,GAGtBsQ,EAAIvO,EAAO1H,EAAQ8E,GAEfzE,GAAM6L,IACNoE,EAAK7B,EAAKvC,GAGrB,CAODzE,SACI,OAAO5B,KAAKJ,EAAYC,EAAKqG,GAChC,CAKDoK,OACItQ,KAAKJ,EAAYC,EAAKC,EAAQE,MAAM,EACvC,CAKDsN,QACItN,KAAKJ,EAAYC,EAAKC,EAAQE,MAAM,EACvC,CAKDrF,SACIqF,KAAKJ,EAAYC,EAAKC,EAAQE,KACjC,CAQDuQ,GAAGjS,EAAMsR,GACL5P,KAAKgG,EAAQ6J,EAAavR,EAAMsR,EACnC,CAaDY,IAAIlS,EAAMsR,GACN5P,KAAKgG,EAAQ+J,GAAiBzR,EAAMsR,EACvC,CAODa,SAASpK,GAEL,OADArG,KAAK8E,EAAO8D,EAAKvC,GACVrG,IACV,CAOD0Q,WACI,OAAO1Q,KAAK8E,EAAOsK,GACtB,CAODuB,eAAetI,GACXrI,KAAKJ,EAAYiO,EAAUhF,EAAKR,EACnC,CAODuI,kBAAkBvI,GACdrI,KAAKJ,EAAYiO,EAAU/E,EAAQT,EACtC,CAKDwI,SACI7Q,KAAKqC,EAAW3C,GAAa,EAChC,CAKDoR,UACI9Q,KAAKqC,EAAW3C,GAAa,EAChC,CAKDqR,QACI/Q,KAAK8E,EAAO8D,EAAK5I,KAAK7F,OAAOoV,QAChC,CAKD5G,aACI3I,KAAKJ,EAAYC,EAAKkG,GACzB,CAODiL,QAAQ1S,GACJ0B,KAAKgG,EAAQC,EAAU3H,EAC1B,CAKD2S,UACI,MAAMhS,EAAQe,KAEdf,EAAMoD,EAAWtC,IACjB+N,GAAkB7O,EAAMW,GAGxB9F,GAAemF,GAAO,CAACiS,EAAGhc,YACf+J,EAAM/J,EAAb,IAIJuE,EAAewF,EAAOvJ,EACzB,E","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/constants/classnames.js","webpack://Alwan/./src/constants/globals.js","webpack://Alwan/./src/core/events/binder.js","webpack://Alwan/./src/utils/object.js","webpack://Alwan/./src/utils/is.js","webpack://Alwan/./src/utils/dom.js","webpack://Alwan/./src/components/reference.js","webpack://Alwan/./src/utils/number.js","webpack://Alwan/./src/lib/popover.js","webpack://Alwan/./src/components/App.js","webpack://Alwan/./src/assets/svg.js","webpack://Alwan/./src/colors/stringify.js","webpack://Alwan/./src/colors/parser.js","webpack://Alwan/./src/components/Swatches.js","webpack://Alwan/./src/core/component.js","webpack://Alwan/./src/components/Palette.js","webpack://Alwan/./src/components/Utility.js","webpack://Alwan/./src/components/Sliders.js","webpack://Alwan/./src/components/Inputs.js","webpack://Alwan/./src/colors/converter.js","webpack://Alwan/./src/core/color.js","webpack://Alwan/./src/constants/defaults.js","webpack://Alwan/./src/index.js","webpack://Alwan/./src/core/events/dispatcher.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ALWAN_CLASSNAME = 'alwan';\r\nexport const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;\r\nexport const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;\r\nexport const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;\r\nexport const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;\r\nexport const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;\r\nexport const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;\r\nexport const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;\r\nexport const SLIDERS_CLASSNAME = `${ALWAN_CLASSNAME}__sliders`;\r\nexport const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--hue`;\r\nexport const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--alpha`;\r\nexport const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;\r\nexport const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;\r\nexport const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;\r\nexport const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;\r\nexport const PRESET_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__preset-button`;\r\nexport const BACKDROP_CLASSNAME = `${ALWAN_CLASSNAME}__backdrop`;\r\nexport const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__toggle-button`;\r\n\r\nexport const POPUP_CLASSNAME = `${ALWAN_CLASSNAME}--popup`;\r\nexport const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;\r\nexport const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;","export const ROOT = document;\r\nexport const DOC_ELEMENT = ROOT.documentElement;\r\n\r\nexport const DEFAULT_COLOR = '#000';\r\n\r\nexport const BUTTON = 'button';\r\n\r\nexport const OPEN = 'open';\r\nexport const CLOSE = 'close';\r\nexport const COLOR = 'color';\r\nexport const CLICK = 'click';\r\nexport const POINTER_DOWN = 'pointerdown';\r\nexport const POINTER_MOVE = 'pointermove';\r\nexport const POINTER_UP = 'pointerup';\r\nexport const SCROLL = 'scroll';\r\nexport const RESIZE = 'resize';\r\nexport const KEY_DOWN = 'keydown';\r\nexport const INPUT = 'input';\r\nexport const CHANGE = 'change';\r\nexport const BLUR = 'blur';\r\nexport const FOCUS_IN = 'focusin';\r\nexport const MOUSE_OUT = 'mouseout';\r\n\r\nexport const HEX_FORMAT = 'hex';\r\nexport const RGB_FORMAT = 'rgb';\r\nexport const HSL_FORMAT = 'hsl';\r\n\r\nexport const TAB = 'Tab';\r\nexport const ESCAPE = 'Escape';\r\n\r\n// Picker supported color formats.\r\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\r\n\r\n// Element insert positions.\r\nexport const INSERT_BEFORE_FIRST_CHILD = 'afterbegin';\r\nexport const INSERT_AFTER = 'afterend';\r\nexport const INSERT_AFTER_LAST_CHILD = 'beforeend';\r\n\r\nexport const ARIA_LABEL = 'aria-label';\r\n\r\n/**\r\n * Horizontal movement using the keyboard arrow keys.\r\n */\r\nexport const KEYBOARD_X = {\r\n    ArrowRight: 1,\r\n    ArrowLeft: -1\r\n};\r\n\r\n/**\r\n * Vertical movement using the keyboard arrow keys.\r\n */\r\nexport const KEYBOARD_Y = {\r\n    ArrowDown: 1,\r\n    ArrowUp: -1\r\n};","/**\r\n * Attach an event listener to an element.\r\n *\r\n * @param {EventTarget} target - Event target.\r\n * @param {string} event - Event type.\r\n * @param {EventListenerOrEventListenerObject} listener - Event listener.\r\n */\r\nexport const addEvent = (target, event, listener) => {\r\n    target.addEventListener(event, listener);\r\n}\r\n\r\n/**\r\n * Removes event listener from an element.\r\n *\r\n * @param {EventTarget} target - Event target.\r\n * @param {string} event - Event type.\r\n * @param {EventListenerOrEventListenerObject} listener - Event listener.\r\n */\r\nexport const removeEvent = (target, event, listener) => {\r\n    target.removeEventListener(event, listener);\r\n}\r\n\r\n","export const { keys, assign: merge, setPrototypeOf, prototype } = Object;\r\nexport const { from: toArray, isArray } = Array;\r\n\r\n/**\r\n * Iterate in an object.\r\n * If any callback function return a value different then null or undefined,\r\n * then stop iteration and return that value.\r\n *\r\n * @param {Object} object - Any object.\r\n * @param {Function} fn - A Callback function.\r\n * @returns {any}\r\n */\r\nexport const objectIterator = (object, fn) => {\r\n    let props = keys(object);\r\n    for (const prop of props) {\r\n       fn(object[prop], prop);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Deep merge options.\r\n *\r\n * @param {object} config - Alwan config object.\r\n * @param {object} options - User options.\r\n */\r\nexport const mergeOptions = (config, options) => {\r\n    objectIterator(options, (val, key) => {\r\n        if (key in config) {\r\n            if (typeof val === 'object' && !isArray(val)) {\r\n                config[key] = merge({}, config[key]);\r\n                mergeOptions(config[key], val);\r\n            } else {\r\n                config[key] = options[key];\r\n            }\r\n        }\r\n    });\r\n}","/**\r\n * Checks if a value is a string.\r\n *\r\n * @param {unknown} value - Value to check.\r\n * @returns {boolean} Whether value is a string.\r\n */\r\nexport const isString = (value) => {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Checks if a value is not undefined or null.\r\n *\r\n * @param {Any} value - Value.\r\n * @returns {Boolean}\r\n */\r\nexport const isset = value => value != null;\r\n\r\n\r\n/**\r\n * Checks if an instance is able to be toggled.\r\n *\r\n * @param {object} param0 - Alwan instance config.\r\n * @returns {boolean}\r\n */\r\nexport const isTogglable = ({ shared, toggle }) => shared || toggle;","import { BUTTON_CLASSNAME, CONTAINER_CLASSNAME, SLIDER_CLASSNAME } from \"../constants/classnames\";\r\nimport { ARIA_LABEL, BUTTON, DOC_ELEMENT, INPUT, INSERT_AFTER_LAST_CHILD, ROOT } from \"../constants/globals\";\r\nimport { merge, objectIterator } from \"./object\";\r\nimport { isString, isset } from \"./is\";\r\n\r\n/**\r\n * Gets the body element.\r\n *\r\n * @returns Document's body.\r\n */\r\nexport const bodyElement = () => ROOT.body;\r\n\r\n/**\r\n * Gets elements.\r\n *\r\n * @param {string|Element} reference - CSS selector or a HTML element.\r\n * @param {Document|Element} context - Element to search from.\r\n * @param {boolean} all - Select all elements.\r\n * @returns {null|Element|NodeList}\r\n */\r\nexport const getElement = (reference, context = bodyElement(), all = false) => {\r\n    if (isString(reference) && reference.trim()) {\r\n        return context[`querySelector${ all ? 'All' : ''}`](reference);\r\n    }\r\n    // Reference must be an element in the page.\r\n    if (reference instanceof Element && bodyElement().contains(reference) && reference !== bodyElement()) {\r\n        return reference;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Inserts an element relative to another element (target element).\r\n *\r\n * @param {Element} element - The element to be inserted.\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {InsertPosition} where - Insert position relative to the targetElement.\r\n * @returns {Element|undefined} - The inserted element.\r\n */\r\nexport const insertElement = (element, targetElement, where = INSERT_AFTER_LAST_CHILD) => {\r\n    if (element && targetElement) {\r\n        targetElement.insertAdjacentElement(where, element);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets element's inner html.\r\n *\r\n * @param {Element} element - An HTML element.\r\n * @param {string} html - HTML string.\r\n */\r\nexport const setHTML = (element, html) => {\r\n    element.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Creates a new HTML Element.\r\n *\r\n * @param {string} tagName - Element tag name.\r\n * @param {string} className - Element class name.\r\n * @param {Element} targetElement - Insert the new element relative to this element using position.\r\n * @param {object} details - Element details (attributes + Initial content).\r\n * @param {InsertPosition} insertPosition - Insert position.\r\n * @returns {Element} The new created element.\r\n */\r\nexport const createElement = (tagName, className, targetElement, details, insertPosition) => {\r\n    const element = ROOT.createElement(tagName || 'div');\r\n\r\n    if (className) {\r\n        element.className = className;\r\n    }\r\n\r\n    objectIterator(details || {}, (value, name) => {\r\n        if (name === 'html') {\r\n            setHTML(element, value);\r\n        } else if (value) {\r\n            element.setAttribute(name, value);\r\n        }\r\n    });\r\n\r\n    if (targetElement) {\r\n        insertElement(element, targetElement, insertPosition);\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * Gets element's bounding rect.\r\n *\r\n * @param {Document|Element} element - Element.\r\n * @returns {DOMRect}\r\n */\r\nexport const getBounds = (element) => {\r\n    let x, y, width, height, right, bottom;\r\n\r\n    if (element === ROOT) {\r\n        x = y = 0;\r\n        width = right = DOC_ELEMENT.clientWidth;\r\n        height = bottom = DOC_ELEMENT.clientHeight;\r\n    } else {\r\n        ({ x, y, width, height, right, bottom } = element.getBoundingClientRect());\r\n    }\r\n\r\n    return [x, y, width, height, right, bottom];\r\n}\r\n\r\n/**\r\n * Replaces an element in the DOM with another element.\r\n *\r\n * @param {Element} element - Element to replace another element.\r\n * @param {Element} replacement - Element to be replaced by the newElement.\r\n * @returns {Element} The new element.\r\n */\r\nexport const replaceElement = (element, replacement) => {\r\n    element.replaceWith(replacement);\r\n    return replacement;\r\n}\r\n\r\n/**\r\n * Remove element from the document.\r\n *\r\n * @param {Element} element - Element to remove.\r\n */\r\nexport const removeElement = (element) => {\r\n    if (element) {\r\n        element.remove();\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets overflow ancestor of an element (body element is not included).\r\n *\r\n * @param {Element} element - Element.\r\n * @param {array<Element|Document>} ancestors - Array of overflow ancestors.\r\n * @returns {array<Element|Document>}\r\n */\r\nexport const getOverflowAncestors = (element, ancestors = [ROOT]) => {\r\n\r\n    if (element) {\r\n        element = element.parentElement;\r\n    }\r\n\r\n    if (! element || element === bodyElement()) {\r\n        return ancestors;\r\n    }\r\n\r\n    if (/auto|scroll|overflow|clip|hidden/.test(getComputedStyle(element).overflow)) {\r\n        ancestors.push(element);\r\n    }\r\n\r\n    return getOverflowAncestors(element, ancestors);\r\n}\r\n\r\n/**\r\n * Sets a CSS custom property if value is not undefined, otherwise returns the value of,\r\n * the given property.\r\n *\r\n * @param {HTMLElement} element  - Element to set/get its custom property.\r\n * @param {string} property - Custom property name.\r\n * @param {string | undefined} value    - Custom property value.\r\n */\r\nexport const customProperty = (element, property, value) => {\r\n\r\n    if (element) {\r\n        return element.style[isset(value) ? 'setProperty' : 'getPropertyValue']('--alwan-' + property, value);\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n\r\n/**\r\n * Adds/Removes a class to/from an based on a boolean variable.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {string|string[]} tokens - Class name or array of classes.\r\n * @param {boolean} toggler - Whether to add (true) or remove a class.\r\n */\r\nexport const toggleClassName = (element, tokens, toggler) => {\r\n\r\n    if (isString(tokens)) {\r\n        tokens = [tokens];\r\n    }\r\n\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            element.classList.toggle(token, toggler);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a button Element.\r\n *\r\n * @param {string} className - Class.\r\n * @param {Element} targetElement - TargetElement.\r\n * @param {object} details - Button details.\r\n * @param {string} label - Button label.\r\n * @param {title} title - Button title.\r\n * @param {string} insertPosition - Button insert position.\r\n * @returns {Element} A button.\r\n */\r\nexport const createButton = (className, targetElement, details, label, title, insertPosition) => {\r\n    return createElement(\r\n        BUTTON,\r\n        BUTTON_CLASSNAME + ' ' + className,\r\n        targetElement,\r\n        merge({\r\n            type: BUTTON,\r\n            [ARIA_LABEL]: label,\r\n            title: title || label\r\n        }, details),\r\n        insertPosition\r\n    );\r\n}\r\n\r\n/**\r\n * Translates an element.\r\n *\r\n * @param {Element} element - Element to translate.\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n */\r\nexport const translate = (element, x, y) => {\r\n    element.style.transform = `translate(${x}px,${y}px)`;\r\n}\r\n\r\n/**\r\n * Creates a slider.\r\n *\r\n * @param {string} className - CSS class.\r\n * @param {Element} parent - Slider parent.\r\n * @param {number} max - Max property.\r\n * @param {number} step - Step property.\r\n * @returns {HTMLInputElement} - Slider.\r\n */\r\nexport const createSlider = (className, parent, max, step) => {\r\n    return createElement(INPUT, SLIDER_CLASSNAME + ' ' + className, parent, { type: 'range', max, step });\r\n}\r\n\r\n/**\r\n * Creates a container element.\r\n *\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {InsertPosition | undefined} where - Insert position relative to the targetElement\r\n */\r\nexport const createContainer = (targetElement, where) => {\r\n    return createElement('', CONTAINER_CLASSNAME, targetElement, {}, where);\r\n}\r\n\r\n/**\r\n * Adds aria label to an element.\r\n *\r\n * @param {HTMLElement} element - Element to label.\r\n * @param {string} label - Label value.\r\n */\r\nexport const setLabel = (element, label) => {\r\n    if (element) {\r\n        element.setAttribute(ARIA_LABEL, label);\r\n    }\r\n}","import { PRESET_BUTTON_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { bodyElement, createButton, removeElement, replaceElement, toggleClassName } from \"../utils/dom\";\r\nimport { isString, isTogglable, isset } from \"../utils/is\";\r\n\r\n/**\r\n * Creates an element that controls (open/close) the color picker.\r\n *\r\n * @param {string|Element} reference - User Reference.\r\n * @param {Alwan} param1 - Alwan instance.\r\n * @returns {object} - ReferenceElement control.\r\n */\r\nexport const Reference = (userReference, alwan) => {\r\n\r\n    /**\r\n     * Reference element.\r\n     *\r\n     * @type {Element | HTMLButtonElement | null}\r\n     */\r\n    let element = userReference || createButton(PRESET_BUTTON_CLASSNAME, bodyElement());\r\n\r\n    /**\r\n     * Preset button user set classes.\r\n     */\r\n    let buttonClasses = [];\r\n\r\n    /**\r\n     * Handles mouse click.\r\n     */\r\n    let handleClick = () => {\r\n        alwan.toggle();\r\n    }\r\n\r\n    /**\r\n     * Reference API.\r\n     */\r\n    return {\r\n        /**\r\n         * Returns the reference element.\r\n         *\r\n         * @returns {Element}\r\n         */\r\n        _el: () => element,\r\n\r\n        /**\r\n         * Initialize Reference element.\r\n         *\r\n         * @param {object} param - Alwan options.\r\n         */\r\n        _init({ preset, classname }) {\r\n            // userReference === element means preset button is not set.\r\n            if (userReference && preset !== (userReference !== element)) {\r\n                if (preset) {\r\n                    // Replace user reference with a preset button.\r\n                    element = replaceElement(userReference, createButton(PRESET_BUTTON_CLASSNAME, null, { id: userReference.id }));\r\n                } else {\r\n                    // Replace preset button with the user reference.\r\n                    element = replaceElement(element, userReference);\r\n                }\r\n            }\r\n\r\n            addEvent(element, CLICK, handleClick);\r\n\r\n            // Add custom classes to the preset button.\r\n            if ((! userReference || preset) && isString(classname)) {\r\n                // Remove previously add classes.\r\n                toggleClassName(element, buttonClasses, false);\r\n                buttonClasses = classname.split(/\\s+/);\r\n                // Add the new classname.\r\n                toggleClassName(element, buttonClasses, true);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Disables/Enables Picker instance.\r\n         *\r\n         * @param {boolean} disabled - Disable/Enable.\r\n         */\r\n        _setDisabled(disabled) {\r\n            if (isset(disabled)) {\r\n                const { config, _components } = alwan;\r\n                const toggler = _components._app._toggle;\r\n\r\n                config.disabled = element.disabled = !! disabled;\r\n\r\n                if (disabled) {\r\n                    toggler(alwan, false, true);\r\n                } else if (! isTogglable(config)) {\r\n                    toggler(alwan, true, true);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Destroy reference component.\r\n         */\r\n        _destroy() {\r\n            if (userReference) {\r\n                this._init({ preset: false });\r\n                removeEvent(element, CLICK, handleClick);\r\n            } else {\r\n                element = removeElement(element);\r\n            }\r\n        }\r\n    }\r\n}","export const { parseFloat: float, parseInt: int, isFinite: isNumeric } = Number;\r\nexport const { min, max, abs, round, PI } = Math;\r\n\r\n/**\r\n * Keeps a number in a range.\r\n *\r\n * @param {number} number - A number to keep it between two numbers.\r\n * @param {number} upperBound - Max.\r\n * @param {number} lowerBound - Min.\r\n * @returns {number}\r\n */\r\nexport const boundNumber = (number, upperBound = 100, lowerBound = 0) => {\r\n    return min(max(number, lowerBound), upperBound);\r\n}\r\n\r\n/**\r\n * Angle value in degrees, it must be between 0 and 360.\r\n *\r\n * @param {number} angle - Angle.\r\n * @returns {Number}\r\n */\r\nexport const normalizeAngle = angle => {\r\n    return (round(angle) % 360 + 360) % 360;\r\n}","import { KEY_DOWN, POINTER_DOWN, RESIZE, ROOT, SCROLL } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { getBounds, getOverflowAncestors, translate } from \"../utils/dom\";\r\nimport { abs, float, isNumeric, round } from \"../utils/number\";\r\nimport { isString, isset } from \"../utils/is\";\r\n\r\n// getBounds function array.\r\nconst LEFT = 0; // Also the x coordinate.\r\nconst TOP = 1; // Also the y coordinate.\r\nconst RIGHT = 4;\r\nconst BOTTOM = 5;\r\n\r\nconst START = 0;\r\nconst CENTER = 1;\r\nconst END = 2;\r\n\r\n/**\r\n * Sides to fallback to for each side.\r\n */\r\nconst fallbackSides = {\r\n    top: [TOP, BOTTOM, RIGHT, LEFT],\r\n    bottom: [BOTTOM, TOP, RIGHT, LEFT],\r\n    right: [RIGHT, LEFT, TOP, BOTTOM],\r\n    left: [LEFT, RIGHT, TOP, BOTTOM],\r\n};\r\n\r\n/**\r\n * Alignments to fallback to for each alignment.\r\n */\r\nconst fallbackAlignments = {\r\n    start: [START, CENTER, END],\r\n    center: [CENTER, START, END],\r\n    end: [END, CENTER, START],\r\n};\r\n\r\n/**\r\n * Creates a Popover instance.\r\n *\r\n * @param {Element} target - Popover target.\r\n * @param {HTMLElement} container - Popover container.\r\n * @param {object} param2 - Popover options.\r\n * @param {Function} autoUpdate - Auto update callback.\r\n * @param {Function} accessibility - Popover accessibility callback.\r\n */\r\nexport const createPopover = (target, container, { _margin, _position }, autoUpdate, popoverAccessibility) => {\r\n    if (isString(_margin)) {\r\n        _margin = float(_margin);\r\n    }\r\n    const margin = isNumeric(_margin) ? _margin : 0;\r\n    const [side, alignment] = isString(_position) ? _position.split('-') : [];\r\n    const sidesFlipOrder = fallbackSides[side] || fallbackSides.bottom;\r\n    const alignmentsFlipOrder = fallbackAlignments[alignment] || fallbackAlignments.center;\r\n    const overflowAncestors = getOverflowAncestors(target);\r\n\r\n    /**\r\n     * Updates the container's position.\r\n     */\r\n    const _update = () => {\r\n        const visualViewport = getBounds(ROOT);\r\n        const targetBounds = getBounds(target);\r\n        const containerBounds = getBounds(container);\r\n        const coordinates = [];\r\n\r\n        /**\r\n         * Check sides.\r\n         */\r\n        sidesFlipOrder.some((side) => {\r\n            // Get axis of the side.\r\n            // x (0) if side is LEFT (1) or RIGHT (4).\r\n            // y (1) if side is TOP (0) or BOTTOM (5).\r\n            let axis = side % 2;\r\n            // Viewport side.\r\n            const domSide = visualViewport[side];\r\n            // Target element coordinate.\r\n            const targetSide = targetBounds[side];\r\n            // Space required for the container.\r\n            // Adding 2 to the axis index gives the dimension based on the axis,\r\n            // x => width and y => height.\r\n            const requiredSpace = margin + containerBounds[axis + 2];\r\n\r\n            if (requiredSpace <= abs(domSide - targetSide)) {\r\n                // Calculate coordinate to set this side.\r\n                // side <= 1 means side is either TOP or LEFT.\r\n                // otherwise it's BOTTOM or RIGHT.\r\n                coordinates[axis] = targetSide + (side <= 1 ? -requiredSpace : margin);\r\n                // Reverse the axis for the alignments.\r\n                // x (0) => y (1)\r\n                // y (1) => x (0)\r\n                axis = (axis + 1) % 2;\r\n                const containerDimension = containerBounds[axis + 2];\r\n                // Lower bound is either the TOP | LEFT coordinate and,\r\n                // the Upper bound is either the BOTTOM | RIGHT coordinates of the target element.\r\n                // depends on the axis.\r\n                const targetLowerBound = targetBounds[axis];\r\n                const targetUpperBound = targetBounds[axis + 4];\r\n                // Distance between the document upper bound (BOTTOM or RIGHT) and,\r\n                // the target element lower bound (TOP or LEFT).\r\n                const upperBoundDistance = visualViewport[axis + 4] - targetLowerBound;\r\n                // Offset between the container and the reference element.\r\n                const offset = (containerDimension + targetBounds[axis + 2]) / 2;\r\n\r\n                /**\r\n                 * Check alignments, only if the container is attached to one side.\r\n                 */\r\n                alignmentsFlipOrder.some((alignment) => {\r\n                    // Check space, if it's available then align the container.\r\n                    if (alignment === START && containerDimension <= upperBoundDistance) {\r\n                        coordinates[axis] = targetLowerBound;\r\n                        return true;\r\n                    }\r\n                    if (\r\n                        alignment === CENTER &&\r\n                        offset <= targetUpperBound &&\r\n                        offset <= upperBoundDistance\r\n                    ) {\r\n                        coordinates[axis] = targetUpperBound - offset;\r\n                        return true;\r\n                    }\r\n                    if (alignment === END && containerDimension <= targetUpperBound) {\r\n                        coordinates[axis] = targetUpperBound - containerDimension;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n\r\n                return true;\r\n            }\r\n        });\r\n\r\n        // If there is no space to position the popover in all sides,\r\n        // then center the popover in the screen.\r\n        // If the popover is attached to one side but there is no space,\r\n        // for the alignment then center it horizontally/vertically depends on the side.\r\n        translate(\r\n            container,\r\n            ...(coordinates.map((value, axis) =>\r\n                round(\r\n                    isset(value) ?\r\n                    value\r\n                    : (visualViewport[axis + 4] - containerBounds[axis + 2]) / 2\r\n                )\r\n            ))\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Checks if target element is visible is the viewport.\r\n     */\r\n    const isVisible = () => {\r\n        return overflowAncestors.every((ancestor) => {\r\n            const [x, y, , , right, bottom] = getBounds(target);\r\n            const [ancestorX, ancestorY, , , ancestorRight, ancestorBottom] = getBounds(ancestor);\r\n\r\n            return (\r\n                y < ancestorBottom && bottom > ancestorY && x < ancestorRight && right > ancestorX\r\n            );\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Target overflow ancestors onScroll and window onResize event handler.\r\n     */\r\n    const eventHandler = () => {\r\n        autoUpdate(_update, isVisible);\r\n    };\r\n\r\n    /**\r\n     * Attach/Detach popover event listeners.\r\n     *\r\n     * @param {Function} fn - A callback function that attach/Detach events listeners.\r\n     */\r\n    const popoverEvents = (fn) => {\r\n        overflowAncestors.forEach((ancestor) => {\r\n            fn(ancestor, SCROLL, eventHandler);\r\n        });\r\n        fn(window, RESIZE, eventHandler);\r\n        fn(ROOT, KEY_DOWN, popoverAccessibility);\r\n        fn(ROOT, POINTER_DOWN, popoverAccessibility);\r\n    };\r\n\r\n    // First update.\r\n    _update();\r\n    // Attach listeners.\r\n    popoverEvents(addEvent);\r\n\r\n    return {\r\n        _update,\r\n\r\n        /**\r\n         * Remove popover functionality.\r\n         */\r\n        _destroy() {\r\n            // Remove listeners.\r\n            popoverEvents(removeEvent);\r\n            container.style.transform = '';\r\n        }\r\n    }\r\n}","import { OPEN_CLASSNAME, POPUP_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLOSE, ESCAPE, INSERT_AFTER, INSERT_AFTER_LAST_CHILD, OPEN, TAB} from \"../constants/globals\";\r\nimport { createPopover } from \"../lib/popover\";\r\nimport { getElement, insertElement, removeElement, toggleClassName } from \"../utils/dom\";\r\nimport { objectIterator, toArray } from \"../utils/object\";\r\nimport { isString, isTogglable, isset } from \"../utils/is\";\r\nimport { isShared } from \"../core/component\";\r\n\r\n/**\r\n * Creates App component and initialize components.\r\n *\r\n * @param {Element} root - Picker container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object}\r\n */\r\nexport const App = (root, alwan) => {\r\n    /**\r\n     * Popper instance.\r\n     */\r\n    let popoverInstance = null;\r\n\r\n    /**\r\n     * Visibility state.\r\n     */\r\n    let isOpen = false;\r\n\r\n    /**\r\n     * Setup and Initialize other components.\r\n     *\r\n     * @param {object} options - Alwan options.\r\n     * @param {object} instance - Alwan instance.\r\n     */\r\n    const _setup = (options, instance = alwan) => {\r\n        alwan = instance;\r\n        const components = alwan._components;\r\n        const { theme, popover, target, position, margin, id } = options;\r\n        const refElement = alwan._reference._el();\r\n        const targetElement = getElement(target) || refElement;\r\n        const toggle = isTogglable(options);\r\n\r\n        if (isString(id) && ! isShared(components)) {\r\n            root.id = id;\r\n        }\r\n\r\n        // Initialize components.\r\n        objectIterator(components, ({ _init }) => {\r\n            if (_init) {\r\n                _init(options, alwan);\r\n            }\r\n        })\r\n\r\n        // Set theme (dark or light).\r\n        root.dataset.theme = theme;\r\n\r\n        // If toggle option changed to false, then open (show) the picker\r\n        if (! toggle) {\r\n            _toggle(alwan, true, true);\r\n        }\r\n\r\n        // Hide reference element if both toggle and popover options are set to false,\r\n        // and the components are not shared.\r\n        refElement.style.display = popover || toggle ? '' : 'none';\r\n\r\n        // Toggle popup class that makes the root's position fixed.\r\n        toggleClassName(root, POPUP_CLASSNAME, popover);\r\n\r\n        if (popoverInstance) {\r\n            popoverInstance._destroy();\r\n            popoverInstance = null;\r\n        }\r\n\r\n        if (popover) {\r\n            popoverInstance = createPopover(\r\n                targetElement,\r\n                root,\r\n                {\r\n                    _margin: margin,\r\n                    _position: position\r\n                },\r\n                autoUpdate,\r\n                popoverAccessibility\r\n            );\r\n        } else {\r\n            // If there is a target element then append the color picker widget in it,\r\n            // otherwise insert it after the reference element.\r\n            insertElement(\r\n                root,\r\n                targetElement,\r\n                targetElement === refElement ? INSERT_AFTER : INSERT_AFTER_LAST_CHILD\r\n            )\r\n        }\r\n\r\n        alwan._color._update({}, null, true);\r\n    }\r\n\r\n    /**\r\n     * Auto updates popover position and picker visibility.\r\n     *\r\n     * @param {Function} update - Popover position updater function.\r\n     * @param {Function} isInViewport - Checks if popover target element is visible in the viewport.\r\n     */\r\n    const autoUpdate = (update, isInViewport) => {\r\n        if (isOpen || ! isTogglable(alwan.config)) {\r\n            if (isInViewport()) {\r\n                if (isOpen) {\r\n                    // Update popover position if its target element is in the viewport,\r\n                    // and picker is open.\r\n                    update();\r\n\r\n                    if (alwan.config.closeOnScroll) {\r\n                        // Close picker when scrolling.\r\n                        _toggle(alwan, false);\r\n                    }\r\n                } else {\r\n                    // This is reachable only if toggle is false,\r\n                    // open picker if the popover target element becomes visible.\r\n                    _toggle(alwan, true, true);\r\n                }\r\n            } else {\r\n                // Force close picker if the target element is not in the viewport.\r\n                _toggle(alwan, false, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keyboard accessibility.\r\n     *\r\n     * If picker is displayed as a popover then link the focus from the reference,\r\n     * to the picker focusable elements.\r\n     *\r\n     * @param {KeyboardEvent | PointerEvent} e - Event.\r\n     */\r\n    const popoverAccessibility = (e) => {\r\n        if (isOpen) {\r\n            let { target, key, shiftKey } = e;\r\n            let refElement = alwan._reference._el();\r\n            let focusableElements,\r\n                firstFocusableElement,\r\n                lastFocusableElement,\r\n                elementToFocusOn;\r\n\r\n            // Close picker if:\r\n            // - Escape key is pressed.\r\n            // - A pointerdown event happened outside the picker and not on the reference element\r\n            // or one of its labels (if it has any).\r\n            if (\r\n                key === ESCAPE ||\r\n                (target !== refElement && !root.contains(target) && ! toArray(refElement.labels || []).some((label) => label.contains(target)))\r\n            ) {\r\n                _toggle(alwan, false);\r\n            } else if (key === TAB) {\r\n                focusableElements = toArray(getElement('button,input,[tabindex]', root, true));\r\n                firstFocusableElement = focusableElements[0];\r\n                lastFocusableElement = focusableElements.pop();\r\n\r\n                if (target === refElement && !shiftKey) {\r\n                    // Pressing Tab while focusing on the reference element sends focus,\r\n                    // to the first element (palette) inside the picker container.\r\n                    elementToFocusOn = firstFocusableElement;\r\n                } else if ((shiftKey && target === firstFocusableElement) || (!shiftKey && target === lastFocusableElement)) {\r\n                    // Pressing Tab while focusing on the palette with the shift key or focussing on the last,\r\n                    // focusable element without shift key sends focus to the reference element (if it's focusable).\r\n                    elementToFocusOn = refElement;\r\n                }\r\n\r\n                if (elementToFocusOn) {\r\n                    e.preventDefault();\r\n                    elementToFocusOn.focus();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles color picker visibility.\r\n     *\r\n     * @param {object} instance - Alwan instance.\r\n     * @param {boolean} state - True to open, false to close.\r\n     * @param {boolean} forced - Open/Close picker even if its disabled or the toggle option is set to false.\r\n     */\r\n    const _toggle = (instance, state, forced) => {\r\n        instance = instance || alwan;\r\n\r\n        const instanceConfig = instance.config;\r\n\r\n        if (! instanceConfig.disabled || forced) {\r\n\r\n            if (! isset(state)) {\r\n                // If the instance doesn't control the components.\r\n                // then close the instance that controls the components.\r\n                if (isOpen && instance !== alwan) {\r\n                    _toggle(alwan, false);\r\n                }\r\n\r\n                state = ! isOpen;\r\n            }\r\n\r\n            if (state !== isOpen && (isTogglable(instanceConfig) || forced)) {\r\n                if (state) {\r\n                    if (instance !== alwan) {\r\n                        // Set components to point to the new instance,\r\n                        // and update options.\r\n                        _setup(instanceConfig, instance);\r\n                    }\r\n\r\n                    // Update popover position before open.\r\n                    if (state) {\r\n                        _reposition();\r\n                    }\r\n                }\r\n\r\n                // Only the instance that controls the components,\r\n                // open/close the picker.\r\n                if (instance === alwan) {\r\n                    isOpen = state;\r\n                    toggleClassName(root, OPEN_CLASSNAME, state);\r\n                    alwan._events._dispatch(state ? OPEN : CLOSE, root);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the popover's position.\r\n     */\r\n    const _reposition = () => {\r\n        if (popoverInstance) {\r\n            popoverInstance._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets current picker state (opened or closed).\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    const _isOpen = () => {\r\n        return isOpen;\r\n    }\r\n\r\n    /**\r\n     * Destroy components and remove root element from the DOM.\r\n     */\r\n    const _destroy = () => {\r\n        if (popoverInstance) {\r\n            popoverInstance._destroy();\r\n        }\r\n        removeElement(root);\r\n    }\r\n\r\n    return {\r\n        _setup,\r\n        _reposition,\r\n        _toggle,\r\n        _isOpen,\r\n        _destroy\r\n    }\r\n}","export const clipboardSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>`;\r\nexport const checkSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path></svg>`;\r\nexport const switchInputsSVG = `<svg width=\"15\" height=\"15\" viewBox=\"0 0 20 20\" aria-role=\"none\"><path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path></svg>`;\r\nexport const caretSVG = `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z\"></path></svg>`;","import { RGB_FORMAT } from \"../constants/globals\";\r\n\r\n/**\r\n * Converts RGB or HSL color objects to string.\r\n *\r\n * @param {object} color - HSL or RGB color object.\r\n * @param {string} format - Color format (hex, rgb or hsl).\r\n * @returns {string} rgb or hsl string.\r\n */\r\nexport const stringify = (color, format) => {\r\n    let opacity = '';\r\n    let a = color.a;\r\n    let str = format;\r\n\r\n    if (a < 1) {\r\n        str += 'a';\r\n        opacity = ', ' + a;\r\n    }\r\n\r\n    if (format === RGB_FORMAT) {\r\n        return str + `(${color.r}, ${color.g}, ${color.b + opacity})`;\r\n    }\r\n\r\n    return str + `(${color.h}, ${color.s}%, ${color.l}%${opacity})`;\r\n}","import { DEFAULT_COLOR, HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { createElement } from \"../utils/dom\";\r\nimport { float, isNumeric, normalizeAngle, boundNumber, PI, round, int } from \"../utils/number\";\r\nimport { isString } from \"../utils/is\";\r\nimport { stringify } from \"./stringify\";\r\n\r\nconst ctx = createElement('canvas').getContext('2d');\r\n\r\n/**\r\n * Regex.\r\n */\r\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?\\s*[\\s,]\\s*([+-]?\\d*\\.?\\d+)%?\\s*,?\\s*([+-]?\\d*\\.?\\d+)%?(?:\\s*[\\/,]\\s*([+-]?\\d*\\.?\\d+)(%)?)?\\s*\\)?$/;\r\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\r\n/**\r\n * Used to convert non degrees angles to degrees.\r\n */\r\nconst ANGLE_COEFFICIENT_MAP = {\r\n    deg: 1,\r\n    turn: 360,\r\n    rad: 180 / PI,\r\n    grad: 0.9\r\n}\r\n\r\n/**\r\n * Parses any value into an RGB or HSL objects.\r\n * Invalid color values default to #000.\r\n *\r\n * @param {unknown} value - A value to parse.\r\n * @param {boolean} asString - Whether to return the result as a string or object.\r\n * @returns {object|string} - Parsed color as string or object.\r\n */\r\nexport const parseColor = (value = '', asString) => {\r\n\r\n    let color;\r\n    let format;\r\n    let str = '';\r\n\r\n    /**\r\n     * Validate Non string values, convert color objects into strings.\r\n     * Invalid values default to empty string.\r\n     */\r\n    if (! isString(value)) {\r\n        value = value || {};\r\n\r\n        format = [RGB_FORMAT, HSL_FORMAT].find(format => {\r\n            return format.split('').every(key => {\r\n                return isNumeric(float(value[key]));\r\n            });\r\n        });\r\n\r\n        if (format) {\r\n            str = stringify(value, format);\r\n        }\r\n    } else {\r\n        str = value.trim();\r\n    }\r\n\r\n    /**\r\n     * Parse strings\r\n     */\r\n    let [input, h, angle, s, l, a = 1, percentage] = HSL_REGEX.exec(str) || [];\r\n\r\n    // str is a hsl string.\r\n    if (input) {\r\n        /**\r\n         * Normalize values.\r\n         *\r\n         * The hue value is so often given in degrees, it can be given as a number, however\r\n         * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradients),\r\n         * If the hue has a unit other than deg, then convert it to degrees.\r\n         */\r\n        color = {\r\n            h: normalizeAngle(h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),\r\n            s: round(boundNumber(s)),\r\n            l: round(boundNumber(l)),\r\n            a: boundNumber(percentage ? a / 100 : a, 1)\r\n        }\r\n        format = HSL_FORMAT;\r\n    } else {\r\n        format = RGB_FORMAT;\r\n\r\n        ctx.fillStyle = DEFAULT_COLOR;\r\n        ctx.fillStyle = str;\r\n        str = ctx.fillStyle;\r\n        // ColorString is either hex or rgb string,\r\n        // if it's hex convert it to rgb object,\r\n        // if it's rgb then parse it to object.\r\n        if (HEX_REGEX.test(str)) {\r\n            // Convert hex string to rgb object.\r\n            color = {\r\n                r: int(str.slice(1, 3), 16),\r\n                g: int(str.slice(3, 5), 16),\r\n                b: int(str.slice(5, 7), 16),\r\n                a: 1\r\n            }\r\n        } else {\r\n            // Parse rgb string into a rgb object.\r\n            const [r, g, b, a] = /\\((.+)\\)/.exec(str)[1].split(',').map(value => float(value));\r\n            color = { r, g, b, a };\r\n        }\r\n    }\r\n\r\n    // Round the transparency component to two numbers behind\r\n    color.a = round(color.a * 100) / 100;\r\n\r\n    str = stringify(color, format);\r\n\r\n    return asString ? str : [color, format, str];\r\n}","import { caretSVG } from \"../assets/svg\";\r\nimport { COLLAPSE_BUTTON_CLASSNAME, COLLAPSE_CLASSNAME, SWATCHES_CLASSNAME, SWATCH_CLASSNAME } from \"../constants/classnames\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { CLICK, COLOR } from \"../constants/globals\";\r\nimport { createButton, createElement, customProperty, removeElement, toggleClassName } from \"../utils/dom\";\r\nimport { int } from \"../utils/number\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { isArray } from \"../utils/object\";\r\n\r\n/**\r\n * Creates color swatches buttons.\r\n *\r\n * @param {Element} ref - Element to append the swatches container to.\r\n * @param {object} alwan - Picker Instance.\r\n * @returns {object} - Swatches component.\r\n */\r\nexport const Swatches = (ref, alwan) => {\r\n\r\n    /**\r\n     * Swatches container.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Swatches array.\r\n     *\r\n     * @type {Array<string>}\r\n     */\r\n    let swatchesArray;\r\n\r\n    /**\r\n     * Button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let collapseButton;\r\n\r\n    /**\r\n     * Swatches API.\r\n     */\r\n    return {\r\n        /**\r\n         * Creates color swatches.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ swatches, toggleSwatches }, instance) {\r\n            alwan = instance || alwan;\r\n            swatchesArray = [];\r\n\r\n            if (isArray(swatches)) {\r\n                swatchesArray = swatches;\r\n                container = removeElement(container);\r\n                collapseButton = removeElement(collapseButton);\r\n\r\n                if (swatches.length) {\r\n                    // Create swatches container.\r\n                    container = createElement('', SWATCHES_CLASSNAME, ref);\r\n                    // Create swatch buttons.\r\n                    swatches.forEach(color => {\r\n                        customProperty(\r\n                            createButton(\r\n                                SWATCH_CLASSNAME,\r\n                                container,\r\n                                {},\r\n                                alwan.config.i18n.buttons.swatch + ': ' + color,\r\n                                color\r\n                            ),\r\n                            COLOR,\r\n                            parseColor(color, true)\r\n                        );\r\n                    });\r\n\r\n                    // Create or remove the collapse button depend if the toggleSwatches,\r\n                    // option changes.\r\n                    if (toggleSwatches) {\r\n                        collapseButton = createButton(COLLAPSE_BUTTON_CLASSNAME, ref, { html: caretSVG });\r\n                        /**\r\n                         * Handles toggle swatches button click.\r\n                         */\r\n                        addEvent(collapseButton, CLICK, () => {\r\n                            toggleClassName(container, COLLAPSE_CLASSNAME);\r\n                            alwan.reposition();\r\n                        });\r\n                    }\r\n                    /**\r\n                     * Handles clicks in the swatches container.\r\n                     */\r\n                    addEvent(container, CLICK, ({ target }) => {\r\n                        if(target !== container) {\r\n                            alwan._color._set(customProperty(target, COLOR), target, true);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Adds color swatches.\r\n         *\r\n         * @param {Array<string | object>} swatches - Color swatches array to add.\r\n         */\r\n        _add(swatches) {\r\n            alwan.config.swatches = [ ...swatchesArray, ...swatches ];\r\n            this._init(alwan.config);\r\n        },\r\n\r\n        /**\r\n         * Removes color swatches.\r\n         *\r\n         * @param {Array<string | number | object} swatches - Color swatches or their index to remove.\r\n         */\r\n        _remove(swatches) {\r\n            alwan.config.swatches = swatchesArray.filter((swatch, index) => ! swatches.some((item) => item === swatch || int(item) === index));\r\n            this._init(alwan.config);\r\n        }\r\n    };\r\n}","import { ALWAN_CLASSNAME } from \"../constants/classnames\";\r\nimport { App } from \"../components/App\";\r\nimport { Inputs } from \"../components/Inputs\";\r\nimport { Palette } from \"../components/Palette\";\r\nimport { Sliders } from \"../components/Sliders\";\r\nimport { Swatches } from \"../components/Swatches\";\r\nimport { Utility } from \"../components/Utility\";\r\nimport { bodyElement, createContainer, createElement } from \"../utils/dom\";\r\n\r\n/**\r\n * Shared Components.\r\n */\r\nlet sharedComponents = null;\r\n\r\n/**\r\n * Number of instances that uses the shared components.\r\n */\r\nlet instanceCount = 0;\r\n\r\n/**\r\n * Creates components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} alwan components.\r\n */\r\nconst createComponents = (alwan) => {\r\n\r\n    const root = createElement('', ALWAN_CLASSNAME, bodyElement());\r\n    const _app = App(root, alwan);\r\n    const _palette = Palette(root, alwan);\r\n    const container = createContainer(root);\r\n    const _utility = Utility(container, alwan);\r\n    const _sliders = Sliders(container, alwan);\r\n    const _inputs = Inputs(container, alwan);\r\n    const _swatches = Swatches(root, alwan);\r\n\r\n    return {\r\n        _app,\r\n        _palette,\r\n        _utility,\r\n        _sliders,\r\n        _inputs,\r\n        _swatches\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if components are shared.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {boolean} - True if components are shared.\r\n */\r\nexport const isShared = (components) => {\r\n    return !!sharedComponents && components === sharedComponents;\r\n}\r\n\r\n/**\r\n * Destroys components.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {void}\r\n */\r\nexport const destroyComponents = (components) => {\r\n    if (isShared(components)) {\r\n        instanceCount--;\r\n        if (instanceCount > 0) {\r\n            return;\r\n        }\r\n        sharedComponents = null;\r\n    }\r\n\r\n    components._app._destroy();\r\n    components._palette._destroy();\r\n    components = {};\r\n}\r\n\r\n/**\r\n * Gets components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} components.\r\n */\r\nexport const useComponents = (alwan) => {\r\n    let { _components, config: { shared }} = alwan;\r\n\r\n    // Alwan already has components.\r\n    if (_components) {\r\n        // Nothing is changing, if components are shared and the option shared is true,\r\n        // or the components are not shared and the option shared is false\r\n        // then just return the current components.\r\n        if ((isShared(_components)) === shared) {\r\n            return _components;\r\n        }\r\n\r\n        // Force close the picker before destroying its components.\r\n        _components._app._toggle(alwan, false, true);\r\n        // If something changed, either the components were shared,\r\n        // and the option shared is false which means set the components as,\r\n        // non-shared or the components were non-shared and we want to share them.\r\n        // in either cases we need to destroy the current components.\r\n        destroyComponents(_components);\r\n    }\r\n\r\n    if (shared) {\r\n        // Create components and set them to sharedComponents.\r\n        if (! sharedComponents) {\r\n            sharedComponents = createComponents(alwan);\r\n        }\r\n        // Increase the instances that uses this shared components.\r\n        instanceCount++;\r\n\r\n        return sharedComponents;\r\n    }\r\n\r\n    // Create components.\r\n    return createComponents(alwan);\r\n}","import { BACKDROP_CLASSNAME, MARKER_CLASSNAME, PALETTE_CLASSNAME } from \"../constants/classnames\";\r\nimport { DOC_ELEMENT, KEYBOARD_X, KEYBOARD_Y, KEY_DOWN, POINTER_DOWN, POINTER_MOVE, POINTER_UP, ROOT } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { createElement, getBounds, translate, removeElement, customProperty, setLabel } from \"../utils/dom\"\r\nimport { boundNumber, min } from \"../utils/number\";\r\n\r\n/**\r\n * Color picking area, pick color by dragging the marker.\r\n *\r\n * @param {HTMLElement} ref - Insert palette element relative to this element.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object}\r\n */\r\nexport const Palette = (ref, alwan) => {\r\n    /**\r\n     * Marker X coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerX;\r\n\r\n    /**\r\n     * Marker Y coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerY;\r\n\r\n    /**\r\n     * Palette element bounds.\r\n     *\r\n     * @type {DOMRect}\r\n     */\r\n    let paletteBounds;\r\n\r\n    /**\r\n     * A transparent element that covers the whole document.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let backdropElement;\r\n\r\n    /**\r\n     * Indicates whether a pointer (mouse, pen or touch) is down.\r\n     */\r\n    let isPointerDown = false;\r\n\r\n    /**\r\n     * Palette element.\r\n     */\r\n    const palette = createElement('', PALETTE_CLASSNAME, ref, { tabindex: '0' });\r\n\r\n    /**\r\n     * Palette's marker.\r\n     */\r\n    const marker = createElement('', MARKER_CLASSNAME, palette);\r\n\r\n    /**\r\n     * Moves marker and updates the color state.\r\n     * Moves it using a pointer (mouse, touch or pen) or keyboard arrow keys.\r\n     *\r\n     * @param {PointerEvent | null} e - Pointer Event.\r\n     * @param {object} keyboard - Keyboard steps.\r\n     */\r\n    const moveMarkerAndUpdateColor = (e, keyboard) => {\r\n        let [ x, y, width, height ] = paletteBounds;\r\n        let v, L;\r\n\r\n        if (e) {\r\n            x = e.clientX - x;\r\n            y = e.clientY - y;\r\n        } else {\r\n            x = markerX + keyboard.x * width / 100;\r\n            y = markerY + keyboard.y * height / 100;\r\n        }\r\n\r\n        x = boundNumber(x, width);\r\n        y = boundNumber(y, height);\r\n\r\n        if (x !== markerX || y !== markerY) {\r\n            markerX = x;\r\n            markerY = y;\r\n            translate(marker, markerX, markerY);\r\n\r\n            v = (1 - y / height);\r\n            L = v * (1 - x / (2 * width));\r\n\r\n            alwan._color._update({\r\n                S: L === 1 || L === 0 ? 0 : (v - L) / min(L, 1 - L),\r\n                L\r\n            }, palette);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragStart = e => {\r\n        if (! backdropElement) {\r\n            backdropElement = createElement('', BACKDROP_CLASSNAME, DOC_ELEMENT);\r\n        }\r\n        // Save color state.\r\n        alwan._color._save();\r\n        paletteBounds = getBounds(palette);\r\n        isPointerDown = true;\r\n        moveMarkerAndUpdateColor(e);\r\n    }\r\n\r\n    /**\r\n     * Dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const drag = e => {\r\n        if (isPointerDown) {\r\n            moveMarkerAndUpdateColor(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag end (released the marker).\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragEnd = e => {\r\n        if (isPointerDown) {\r\n            alwan._color._change(palette, true);\r\n            backdropElement = removeElement(backdropElement);\r\n            isPointerDown = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves marker using keyboard arrow keys and adds focus-visible to the palette.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleKeyboard = e => {\r\n        const key = e.key;\r\n        const x = KEYBOARD_X[key] || 0;\r\n        const y = KEYBOARD_Y[key] || 0;\r\n        const core = alwan._color;\r\n\r\n        if (x || y) {\r\n            e.preventDefault();\r\n\r\n            paletteBounds = getBounds(palette);\r\n\r\n            core._save();\r\n            moveMarkerAndUpdateColor(null, { x, y });\r\n            core._change(palette, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    addEvent(palette, POINTER_DOWN, dragStart);\r\n    addEvent(ROOT, POINTER_MOVE, drag);\r\n    addEvent(ROOT, POINTER_UP, dragEnd);\r\n    addEvent(palette, KEY_DOWN, handleKeyboard);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize component.\r\n         *\r\n         * @param {object} options - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init(_options, instance) {\r\n            alwan = instance || alwan;\r\n            setLabel(palette, alwan.config.i18n.palette);\r\n        },\r\n\r\n        /**\r\n         * Updates palette's hue and marker position.\r\n         *\r\n         * @param {object} param0 - Alwan color state object.\r\n         * @param {boolean} updateAll - Whether to update palette (update marker's position).\r\n         */\r\n        _update({ h, S, L }, updateAll) {\r\n            // Update palette's hue.\r\n            customProperty(palette, 'h', h);\r\n\r\n            if (updateAll) {\r\n                paletteBounds = getBounds(palette);\r\n                // Temporary hold the value of V in the HSV color space.\r\n                markerY = L + S * min(L, 1 - L);\r\n\r\n                markerX = (markerY ? 2 * (1 - L / markerY) : 0) * paletteBounds[2];\r\n                markerY = (1 - markerY) * paletteBounds[3];\r\n\r\n                translate(marker, markerX, markerY);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove listeners attached to the document.\r\n         */\r\n        _destroy() {\r\n            removeEvent(ROOT, POINTER_MOVE, drag);\r\n            removeEvent(ROOT, POINTER_UP, dragEnd);\r\n        }\r\n    }\r\n}","import { checkSVG, clipboardSVG } from \"../assets/svg\";\r\nimport { COPY_BUTTON_CLASSNAME, PREVIEW_CLASSNAME } from \"../constants/classnames\";\r\nimport { BLUR, CLICK, COLOR, DOC_ELEMENT, INPUT, INSERT_BEFORE_FIRST_CHILD, MOUSE_OUT, ROOT } from \"../constants/globals\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { createButton, createElement, customProperty, removeElement, setHTML } from \"../utils/dom\";\r\n\r\n/**\r\n * Preview color and copy color string.\r\n *\r\n * @param {HTMLElement} ref - Element to insert utility elements into.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} Utility component.\r\n */\r\nexport const Utility = (ref, alwan) => {\r\n    /**\r\n     * Preview color.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let previewElement;\r\n\r\n    /**\r\n     * Copy button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let copyButton;\r\n\r\n    /**\r\n     * Indicate whether color is copied.\r\n     */\r\n    let isCopied;\r\n\r\n    /**\r\n     * Set button icon.\r\n     *\r\n     * @param {boolean} state - Copy state.\r\n     */\r\n    const updateIcon = (state) => {\r\n        isCopied = state;\r\n        setHTML(copyButton, state ? checkSVG : clipboardSVG);\r\n    };\r\n\r\n    /**\r\n     * Copy color fallback if browser doesn't support 'navigator.clipboard'.\r\n     *\r\n     * @param {string} color - Color to copy.\r\n     */\r\n    const fallback = (color) => {\r\n        let input = createElement(\r\n            INPUT,\r\n            '',\r\n            DOC_ELEMENT,\r\n            { value: color }\r\n        );\r\n        input.select();\r\n        ROOT.execCommand('copy');\r\n        input = removeElement(input);\r\n        copyButton.focus();\r\n        // change icon.\r\n        updateIcon(true);\r\n    };\r\n\r\n    /**\r\n     * Copies the selected color to the clipboard.\r\n     */\r\n    const copyColor = () => {\r\n        if (! isCopied && ! alwan.config.disabled) {\r\n            const clipboard = navigator.clipboard;\r\n            const color = alwan._color._get(true);\r\n\r\n            if (clipboard) {\r\n                clipboard.writeText(color)\r\n                            .then(() => updateIcon(true))\r\n                            .catch(() => fallback(color));\r\n            } else {\r\n                fallback(color);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * API.\r\n     */\r\n    return {\r\n        /**\r\n         * Initialize utility component.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ preview, copy }, instance) {\r\n            alwan = instance;\r\n            // Initialize elements.\r\n            previewElement = removeElement(previewElement);\r\n            copyButton = removeElement(copyButton);\r\n\r\n            if (preview) {\r\n                previewElement = createElement('',\r\n                    PREVIEW_CLASSNAME,\r\n                    ref,\r\n                    {},\r\n                    INSERT_BEFORE_FIRST_CHILD\r\n                );\r\n            }\r\n\r\n            if (copy) {\r\n                copyButton = createButton(\r\n                    COPY_BUTTON_CLASSNAME,\r\n                    previewElement || ref,\r\n                    { html: clipboardSVG },\r\n                    alwan.config.i18n.buttons.copy,\r\n                    '',\r\n                    INSERT_BEFORE_FIRST_CHILD,\r\n                );\r\n\r\n                /**\r\n                 * Add events.\r\n                 */\r\n                addEvent(copyButton, CLICK, copyColor);\r\n                // Reset clipboard icon.\r\n                addEvent(copyButton, BLUR, () => isCopied && updateIcon(false));\r\n                addEvent(copyButton, MOUSE_OUT, () => copyButton.blur());\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Previews current color.\r\n         *\r\n         * @param {string} color - Color string.\r\n         */\r\n        _preview(color) {\r\n            customProperty(previewElement, COLOR, color);\r\n        }\r\n    }\r\n}","import { ALPHA_SLIDER_CLASSNAME, HUE_SLIDER_CLASSNAME, SLIDERS_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, INPUT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { createElement, createSlider, customProperty, removeElement, setLabel } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates hue and alpha sliders.\r\n *\r\n * @param {HTMLElement} ref - Element to append sliders to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} Sliders component.\r\n */\r\nexport const Sliders = (ref, alwan) => {\r\n    /**\r\n     * Alpha slider.\r\n     *\r\n     * @type {HTMLInputElement | null}\r\n     */\r\n    let alphaSlider;\r\n\r\n    /**\r\n     * Sliders container.\r\n     */\r\n    const container = createElement('', SLIDERS_CLASSNAME, ref);\r\n\r\n    /**\r\n     * Hue slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, container, 360);\r\n\r\n    /**\r\n     * Updates color.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target, type, target: { value }}) => {\r\n        if (type === CHANGE) {\r\n            alwan._color._change(target);\r\n        } else {\r\n            alwan._color._update(target === hueSlider ? { h: 360 - value } : { a: value * 1 }, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    addEvent(container, INPUT, handleChange);\r\n    addEvent(container, CHANGE, handleChange);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize sliders.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ opacity }, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            const { hue, alpha } = alwan.config.i18n.sliders;\r\n\r\n            alphaSlider = removeElement(alphaSlider);\r\n\r\n            if (opacity) {\r\n                alphaSlider = createSlider(\r\n                    ALPHA_SLIDER_CLASSNAME,\r\n                    container,\r\n                    1,\r\n                    0.01\r\n                );\r\n            } else {\r\n                alwan._color._update({ a: 1 });\r\n            }\r\n\r\n            setLabel(hueSlider, hue);\r\n            setLabel(alphaSlider, alpha);\r\n        },\r\n\r\n        /**\r\n         * Sets sliders values and updates alpha slider's background color.\r\n         *\r\n         * @param {object} param0 - Alwan color state object.\r\n         * @param {string} opaqueHex - Hex color without opacity.\r\n         * @param {boolean} updateAll - Whether to update sliders or not.\r\n         */\r\n        _update({ h, a }, opaqueHex, updateAll) {\r\n            // Update alpha slider's background color.\r\n            customProperty(alphaSlider, RGB_FORMAT, opaqueHex);\r\n\r\n            if (updateAll) {\r\n                hueSlider.value = 360 - h;\r\n\r\n                if (alphaSlider) {\r\n                    alphaSlider.value = a;\r\n                }\r\n            }\r\n        }\r\n    };\r\n}","import { switchInputsSVG } from \"../assets/svg\";\r\nimport { INPUTS_CLASSNAME, INPUT_CLASSNAME } from \"../constants/classnames\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport {\r\n    CHANGE,\r\n    CLICK,\r\n    COLOR_FORMATS,\r\n    FOCUS_IN,\r\n    HEX_FORMAT,\r\n    INPUT,\r\n    INSERT_AFTER,\r\n    INSERT_BEFORE_FIRST_CHILD,\r\n    KEY_DOWN\r\n} from \"../constants/globals\";\r\nimport { createButton, createContainer, createElement, removeElement } from \"../utils/dom\";\r\nimport { float, max } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { addEvent } from \"../core/events/binder\";\r\n\r\n/**\r\n * Creates Inputs.\r\n *\r\n * @param {Element} ref - Insert outer container relative to this element.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} - Inputs component.\r\n */\r\nexport const Inputs = (ref, alwan) => {\r\n\r\n    /**\r\n     * Outer container.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Inputs wrapper.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let inputsContainer;\r\n\r\n    /**\r\n     * Switch button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let switchButton;\r\n\r\n    /**\r\n     * Inputs color formats.\r\n     */\r\n    let formats = [];\r\n\r\n    /**\r\n     * Current color format index.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let currentFormatIndex;\r\n\r\n    /**\r\n     * Object that maps fields label to their inputs.\r\n     *\r\n     * @type {object}\r\n     */\r\n    let inputsMap;\r\n\r\n    /**\r\n     * Indicates that an input value has changed.\r\n     */\r\n    let isChanged = false;\r\n\r\n    /**\r\n     * Checks if inputs are one single input.\r\n     */\r\n    const isSingle = () => {\r\n        return alwan.config.singleInput || formats[currentFormatIndex] === HEX_FORMAT;\r\n    };\r\n\r\n    /**\r\n     * Builds inputs.\r\n     */\r\n    const build = () => {\r\n        // Initialize inputs map.\r\n        inputsMap = {};\r\n        // Create inputs container.\r\n        removeElement(inputsContainer);\r\n        inputsContainer = createElement('', INPUTS_CLASSNAME, container, {}, INSERT_BEFORE_FIRST_CHILD);\r\n\r\n        const color = alwan._color._get();\r\n        // Each letter in the format variable represent a color channel,\r\n        // For multiple inputs, each color channel has an input field.\r\n        // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\r\n        const format = formats[currentFormatIndex];\r\n        const fields = isSingle()\r\n            ? [format]\r\n            : (format + (alwan.config.opacity ? 'a' : '')).split('');\r\n\r\n        fields.forEach(field => {\r\n            /**\r\n             * Create Input.\r\n             *\r\n             * <label>\r\n             *     <input type=\"text\" class=\"alwan__input\">\r\n             *     <span>${field}</span>\r\n             * </label>\r\n             */\r\n            const labelElement = createElement('label', '', inputsContainer);\r\n            inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, labelElement, { type: 'text', value: color[field] + '' });\r\n            createElement('span', '', labelElement, { html: field });\r\n        });\r\n\r\n        /**\r\n        * Bind events.\r\n        */\r\n        addEvent(inputsContainer, INPUT, handleChange);\r\n        addEvent(inputsContainer, CHANGE, handleChange);\r\n        // Select value on focus.\r\n        addEvent(inputsContainer, FOCUS_IN, (e) => { e.target.select(); });\r\n        // Close picker if enter pressed while focusing in inputs.\r\n        addEvent(inputsContainer, KEY_DOWN, (e) => { e.key === 'Enter' && alwan.close() });\r\n    }\r\n\r\n    /**\r\n     * Changes color format.\r\n     */\r\n    const changeFormat = () => {\r\n        // Increment input format index, reset it if it reaches the end.\r\n        // this index will point to the next format.\r\n        currentFormatIndex = (currentFormatIndex + 1) % formats.length;\r\n        alwan._color._setFormat(formats[currentFormatIndex]);\r\n        build();\r\n    }\r\n\r\n    /**\r\n     * Handles changes in inputs.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target, type }) => {\r\n\r\n        if (type === CHANGE) {\r\n            alwan._color._change(target, true);\r\n            isChanged = false;\r\n        } else {\r\n\r\n            if (! isChanged) {\r\n                alwan._color._save();\r\n                isChanged = true;\r\n            }\r\n\r\n            let str = target.value;\r\n            let color = {};\r\n\r\n            if (! isSingle()) {\r\n                // Copy inputs values into an object (rgb or hsl).\r\n                objectIterator(inputsMap, (input, key) => {\r\n                    color[key] = float(input.value);\r\n                });\r\n                // Convert the object into string.\r\n                str = stringify(color, formats[currentFormatIndex]);\r\n            }\r\n\r\n            alwan._color._set(str, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Component API.\r\n     */\r\n    return {\r\n        /**\r\n         * Initialize Inputs.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ inputs, format }, instance) {\r\n            alwan = instance || alwan;\r\n            inputs = inputs || {};\r\n\r\n            formats = COLOR_FORMATS;\r\n\r\n            if (inputs !== true) {\r\n                // Get only valid formats.\r\n                formats = formats.filter((format) => inputs[format]);\r\n            }\r\n\r\n            const length = formats.length;\r\n\r\n            // Validate format.\r\n            if(! length) {\r\n                formats = COLOR_FORMATS;\r\n            }\r\n            currentFormatIndex = max(formats.indexOf(format), 0);\r\n            alwan._color._setFormat(formats[currentFormatIndex]);\r\n\r\n            // Initialize element.\r\n            container = removeElement(container);\r\n            switchButton = removeElement(switchButton);\r\n\r\n            if (length) {\r\n                // Create container and insert it after the util-sliders container.\r\n                container = createContainer(ref, INSERT_AFTER);\r\n                build();\r\n\r\n                if (length > 1) {\r\n                    switchButton = createButton('', container, { html: switchInputsSVG }, alwan.config.i18n.buttons.changeFormat);\r\n                    addEvent(switchButton, CLICK, changeFormat);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Updates Input(s) value(s).\r\n         *\r\n         * @param {Object} color - Alwan color state object.\r\n         */\r\n        _values(color) {\r\n            if (! isChanged) {\r\n                objectIterator(inputsMap || {}, (input, key) => {\r\n                    input.value = color[key];\r\n                })\r\n            }\r\n        }\r\n    }\r\n}","import { abs, max, min, normalizeAngle, round } from \"../utils/number\";\r\n\r\n/**\r\n * Converts a decimal number to hexadecimal.\r\n *\r\n * @param {number} number - A decimal number.\r\n */\r\nconst toHex = (number) => {\r\n    return (number < 16 ? '0' : '') + number.toString(16);\r\n};\r\n\r\n/**\r\n * Converts RGB color to hex.\r\n *\r\n * returns an array of two values, the hex string without the alpha channel,\r\n * and the alpha channel (in hexadecimal).\r\n *\r\n * The hex without alpha (opaque) is used to color the background of the alpha slider.\r\n *\r\n * @param {object} param0 - RGB color object.\r\n */\r\nexport const RGBToHEX = ({ r, g, b, a }) => {\r\n    return ['#' + toHex(r) + toHex(g) + toHex(b), a < 1 ? toHex(round(a * 255)) : ''];\r\n};\r\n\r\n/**\r\n * Helper function used for converting HSL to RGB.\r\n *\r\n * @param {number} k - Positive coefficient.\r\n * @param {number} s - HSL saturation.\r\n * @param {number} l - HSL lightness.\r\n */\r\nexport const fn = (k, s, l) => {\r\n    k %= 12;\r\n    return round((l - s * min(l, 1 - l) * max(-1, min(k - 3, 9 - k, 1))) * 255);\r\n};\r\n\r\n/**\r\n * Converts HSL to RGB.\r\n *\r\n * @param {object} param0 - HSL color components.\r\n */\r\nexport const HSLToRGB = ({ h, S, L }) => {\r\n    h /= 30;\r\n    return {\r\n        r: fn(h, S, L),\r\n        g: fn(h + 8, S, L),\r\n        b: fn(h + 4, S, L),\r\n    };\r\n};\r\n\r\n/**\r\n * Converts RGB to HSL.\r\n *\r\n * @param {object} param0 - RGB color object.\r\n * @returns {object} - HSL color object.\r\n */\r\nexport const RGBToHSL = ({ r, g, b, a }) => {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    const cMax = max(r, g, b);\r\n    const cMin = min(r, g, b);\r\n    const d = cMax - cMin;\r\n    const L = (cMax + cMin) / 2;\r\n    const h =\r\n        d === 0\r\n            ? 0\r\n            : cMax === r\r\n            ? ((g - b) / d) % 6\r\n            : cMax === g\r\n            ? (b - r) / d + 2\r\n            : cMax === b\r\n            ? (r - g) / d + 4\r\n            : 0;\r\n\r\n    return {\r\n        h: normalizeAngle(h * 60),\r\n        S: d ? d / (1 - abs(2 * L - 1)) : 0,\r\n        L,\r\n        a,\r\n    };\r\n};","import { HSLToRGB, RGBToHEX, RGBToHSL } from \"../colors/converter\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, COLOR, HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { customProperty } from \"../utils/dom\";\r\nimport { round } from \"../utils/number.js\";\r\nimport { keys, merge } from \"../utils/object\";\r\n\r\n/**\r\n * Creates the core color state and UI updater.\r\n *\r\n * @param {object} alwan - Alwan instance.\r\n * @returns {object} Core color state.\r\n */\r\nexport const color = (alwan) => {\r\n\r\n    /**\r\n     * Save an rgb string.\r\n     *\r\n     * @type {string}\r\n     */\r\n    let savedColor;\r\n\r\n    /**\r\n     * Current color format.\r\n     *\r\n     * @type {'rgb'|'hsl'|'hex'}\r\n     */\r\n    let format;\r\n\r\n    /**\r\n     * Color state.\r\n     */\r\n    const state = {\r\n        // Hue.\r\n        h: 0,\r\n        // Saturation (capital S) and Lightness (capital L),\r\n        // are used internally, their values are between 0-1.\r\n        S: 0,\r\n        L: 0,\r\n\r\n        // HSL saturation and lightness (0-100)\r\n        s: 0,\r\n        l: 0,\r\n\r\n        // Red, Green and Blue values (0-255)\r\n        r: 0,\r\n        g: 0,\r\n        b: 0,\r\n\r\n        // Opacity value (0-1)\r\n        a: 1,\r\n\r\n        // color strings.\r\n        rgb: '',\r\n        hex: '',\r\n        hsl: ''\r\n    }\r\n\r\n    /**\r\n     * Alwan options.\r\n     */\r\n    const config = alwan.config;\r\n\r\n    return {\r\n        /**\r\n         * Updates color state and UI.\r\n         *\r\n         * @param {object} hsl - HSL color components.\r\n         * @param {HTMLElement | undefined} source - Element that updating the color.\r\n         * @param {boolean | undefined} updateAll - Whether to update the palette and sliders components.\r\n         * @param {object | undefined} rgb - RGB color object.\r\n         */\r\n        _update(hsl, source, updateAll = false, rgb) {\r\n            if (! config.disabled) {\r\n\r\n                const { r, g, b, a } = state;\r\n\r\n                merge(state, hsl);\r\n                merge(\r\n                    state,\r\n                    {\r\n                        s: round(state.S * 100),\r\n                        l: round(state.L * 100),\r\n                    },\r\n                    rgb || HSLToRGB(state)\r\n                );\r\n\r\n                const { _inputs, _palette, _sliders, _utility } = alwan._components;\r\n                const rgbString = stringify(state, RGB_FORMAT);\r\n                const [opaqueHex, alphaHex] = RGBToHEX(state);\r\n\r\n                state.hsl = stringify(state, HSL_FORMAT);\r\n                state.hex = opaqueHex + alphaHex;\r\n                state.rgb = rgbString;\r\n\r\n                // Update ui.\r\n                customProperty(alwan._reference._el(), COLOR, rgbString);\r\n                _palette._update(state, updateAll);\r\n                _utility._preview(rgbString);\r\n                _sliders._update(state, opaqueHex, updateAll);\r\n                _inputs._values(state);\r\n\r\n                // If an element in the picker is changing the state,\r\n                // then trigger color event.\r\n                if (source && (state.r !== r || state.g !== g || state.b !== b || state.a !== a)) {\r\n                    alwan._events._dispatch(COLOR, source);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Saves the current color as a string.\r\n         */\r\n        _save() {\r\n            savedColor = state[format];\r\n        },\r\n\r\n        /**\r\n         * Triggers change event.\r\n         *\r\n         * If checkChange flag is true, fire change event only if the saved color (color start),\r\n         * and the current color are different.\r\n         *\r\n         * @param {HTMLElement} source - Event source.\r\n         * @param {boolean} check - Whether to compare current color with the saved color.\r\n         */\r\n        _change(source, check) {\r\n            if (!check || (check && savedColor !== state[format])) {\r\n                alwan._events._dispatch(CHANGE, source);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets a new color.\r\n         *\r\n         * @param {string|object} color - Color string or object.\r\n         * @param {HTMLElement | undefined} source - Source element.\r\n         * @param {boolean} triggerChange - Whether to fire the change event or not.\r\n         */\r\n        _set(color, source, triggerChange) {\r\n            let [parsedColor, parsedColorFormat, parsedColorString] = parseColor(color);\r\n            let rgb, hsl;\r\n\r\n            // Update color state if the current color and the parsed color are different.\r\n            if (state[parsedColorFormat] !== parsedColorString) {\r\n                if (parsedColorFormat === RGB_FORMAT) {\r\n                    rgb = parsedColor;\r\n                    hsl = RGBToHSL(rgb);\r\n                } else {\r\n                    hsl = parsedColor;\r\n                    hsl.S = parsedColor.s / 100;\r\n                    hsl.L = parsedColor.l / 100;\r\n                }\r\n\r\n                this._update(hsl, source, true, rgb);\r\n\r\n                if (triggerChange) {\r\n                    this._change(source);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Creates and return color value.\r\n         *\r\n         * @returns {object} - Color value.\r\n         */\r\n        _value: () => ({\r\n            h: state.h,\r\n            s: state.s,\r\n            l: state.l,\r\n\r\n            r: state.r,\r\n            g: state.g,\r\n            b: state.b,\r\n\r\n            a: state.a,\r\n\r\n            hex: state.hex,\r\n            rgb: state.rgb,\r\n            hsl: state.hsl\r\n        }),\r\n\r\n        /**\r\n         * Sets a new color format.\r\n         *\r\n         * @param {string} newFormat - Color format.\r\n         */\r\n        _setFormat(newFormat) {\r\n            format = config.format = newFormat;\r\n        },\r\n\r\n        /**\r\n         * Gets color state object or current color as a string\r\n         *\r\n         * @returns {string | object}\r\n         */\r\n        _get: (asString) => asString ? state[format] : state,\r\n    }\r\n}","import { DEFAULT_COLOR } from \"./globals\";\r\n\r\n/**\r\n * Alwan defaults.\r\n */\r\n export const defaults = {\r\n    /**\r\n     * Set the container's (widget) id.\r\n     *\r\n     * @type {string}\r\n     */\r\n    id: '',\r\n\r\n    /**\r\n     * Add classes (separated by a white space) to the preset button.\r\n     *\r\n     * @type {string}\r\n     */\r\n    classname: '',\r\n\r\n    /**\r\n     * Choose a theme.\r\n     *\r\n     * @type {'dark' | 'light'}\r\n     */\r\n    theme: 'light',\r\n\r\n    /**\r\n     * Toggle picker's visibility (Show/Hide), Setting this to false keeps the picker visible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    toggle: true,\r\n\r\n    /**\r\n     * Display the picker container as a pop-up (a box that floats on top of the page content),\r\n     * if it's false, picker container will be displayed as a block (embedded in the page's content).\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    popover: true,\r\n\r\n    /**\r\n     * Set the position of the popper (if popover is set to true) relative to the reference element,\r\n     * the position has two values separated by a dash (-),\r\n     * the first value is the direction (top, bottom, right, left),\r\n     * the second value is the alignment (start, center, end), omitting this value will default to center.\r\n     * e.g. 'bottom-start': 'bottom' places the picker below the reference element,\r\n     * and 'start' aligns the left side of the container with the left side of the reference element.\r\n     * Note:\r\n     * If the picker container has no space to be placed, it will auto-position itself.\r\n     * based on the available space.\r\n     *\r\n     * @type {string}\r\n     */\r\n    position: 'bottom-start',\r\n\r\n    /**\r\n     * Set the gap (in pixels) between the picker container and the reference element.\r\n     *\r\n     * @type {number}\r\n     */\r\n    margin: 0,\r\n\r\n    /**\r\n     * Replace the reference element with a pre-styled button.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    preset: true,\r\n\r\n    /**\r\n     * Initial color.\r\n     *\r\n     * @type {string | object}\r\n     */\r\n    color: DEFAULT_COLOR,\r\n\r\n    /**\r\n     * Default color.\r\n     *\r\n     * @type {string | object}\r\n     */\r\n    default: DEFAULT_COLOR,\r\n\r\n    /**\r\n     * Target can be a selector or an HTML element,\r\n     * If the option popover is true, the picker container will be positioned relative to this element,\r\n     * instead of the reference element.\r\n     * else if popover option is false, the picker container will be appended as a child into this element.\r\n     *\r\n     * @type {string | Element}\r\n     */\r\n    target: '',\r\n\r\n    /**\r\n     * Disable the picker, users won't be able to pick colors.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    disabled: false,\r\n\r\n    /**\r\n     * Initial color format.\r\n     *\r\n     * @type {string}\r\n     */\r\n    format: 'rgb',\r\n\r\n    /**\r\n     * For the formats 'hsl' and 'rgb', choose a single input to display the color string,\r\n     * or if false, display an input for each color channel.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    singleInput: false,\r\n\r\n    /**\r\n     * Input(s) field(s) for each color format. if this option is set to true then all formats are,\r\n     * selected.\r\n     *\r\n     * @type {boolean | object}\r\n     */\r\n    inputs: {\r\n        rgb: true,\r\n        hex: true,\r\n        hsl: true,\r\n    },\r\n\r\n   /**\r\n    * Support alpha channel and display opacity slider.\r\n    *\r\n    * @type {boolean}\r\n    */\r\n    opacity: true,\r\n\r\n    /**\r\n     * Preview the color.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    preview: true,\r\n\r\n    /**\r\n     * Add/Remove a copy button.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    copy: true,\r\n\r\n    /**\r\n     * Array of color swatches, invalid values will default to the DEFAULT_COLOR.\r\n     *\r\n     * @type {Array<string | object>}\r\n     */\r\n    swatches: [],\r\n\r\n    /**\r\n     * Share components with multiple alwan instances (use less memory if there\r\n     * are multiple color picker instances).\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    shared: false,\r\n\r\n    /**\r\n     * Make swatches container collapsible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    toggleSwatches: false,\r\n\r\n    /**\r\n     * Close color picker when scrolling, only if the color picker,\r\n     * is displayed as a popover and can be closed.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    closeOnScroll: false,\r\n\r\n    /**\r\n     * Internationalization of the interactive elements labels.\r\n     */\r\n    i18n: {\r\n        palette: 'Color picker',\r\n        buttons: {\r\n            copy: 'Copy color to clipboard',\r\n            changeFormat: 'Change color format',\r\n            swatch: 'Color swatch',\r\n        },\r\n        sliders: {\r\n            hue: 'Change hue',\r\n            alpha: 'Change opacity'\r\n        }\r\n    }\r\n}","import { Reference } from \"./components/reference\";\r\nimport { merge, mergeOptions, objectIterator, prototype, setPrototypeOf } from \"./utils/object\";\r\nimport { destroyComponents, isShared, useComponents } from \"./core/component\";\r\nimport { color } from \"./core/color\";\r\nimport { Dispatcher } from \"./core/events/dispatcher\";\r\nimport \"./assets/scss/alwan.scss\";\r\nimport { defaults } from \"./constants/defaults\";\r\nimport { isset } from \"./utils/is\";\r\nimport { getElement } from \"./utils/dom\";\r\n\r\n\r\nexport default class Alwan {\r\n\r\n    static version = VERSION;\r\n\r\n    /**\r\n     * Alwan defaults.\r\n     */\r\n    static defaults = defaults;\r\n\r\n    /**\r\n     * Alwan instance constructor.\r\n     *\r\n     * @param {String|Element} reference - The reference element.\r\n     * @param {Object} options - Options.\r\n     */\r\n    constructor(reference, options) {\r\n        const alwan = this;\r\n\r\n        alwan.config = merge({}, Alwan.defaults);\r\n        alwan._events = Dispatcher(alwan);\r\n        alwan._color = color(alwan);\r\n        alwan._reference = Reference(getElement(reference), alwan);\r\n        alwan.setOptions(options);\r\n    }\r\n\r\n    /**\r\n     * Sets new options.\r\n     *\r\n     * @param {Object} options - Alwan options.\r\n     */\r\n    setOptions(options) {\r\n        options = options || {};\r\n\r\n        let alwan = this;\r\n        let config = alwan.config;\r\n        let { color, disabled } = options;\r\n        let core = alwan._color;\r\n        let components, app;\r\n\r\n        alwan._reference._setDisabled(disabled);\r\n\r\n        if (! config.disabled) {\r\n            mergeOptions(config, options);\r\n            alwan._components = components = useComponents(alwan);\r\n            alwan._reference._init(config);\r\n            app = components._app;\r\n\r\n            if (isShared(components)) {\r\n                app._toggle(null, false);\r\n            }\r\n\r\n            app._setup(config, alwan);\r\n\r\n            if (isset(color)) {\r\n                core._set(color);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the state of the picker whether it's opened or closed.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isOpen() {\r\n        return this._components._app._isOpen();\r\n    }\r\n\r\n    /**\r\n     * Opens the picker.\r\n     */\r\n    open() {\r\n        this._components._app._toggle(this, true);\r\n    }\r\n\r\n    /**\r\n     * Closes the picker.\r\n     */\r\n    close() {\r\n        this._components._app._toggle(this, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles (opens/closes) the picker.\r\n     */\r\n    toggle() {\r\n        this._components._app._toggle(this);\r\n    }\r\n\r\n    /**\r\n     * Attaches an event handler function for an event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    on(type, handler) {\r\n        this._events._addListener(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Detaches one or more event handlers.\r\n     *\r\n     * Note:\r\n     * omitting handler, remove all handlers from the event,\r\n     * omitting both event type and handler, remove all handlers that are,\r\n     * attached to all events.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    off(type, handler) {\r\n        this._events._removeListeners(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Sets a color.\r\n     *\r\n     * @param {String|Object} color - Color.\r\n     */\r\n    setColor(color) {\r\n        this._color._set(color);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets color.\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getColor() {\r\n        return this._color._value();\r\n    }\r\n\r\n    /**\r\n     * Adds color swatches.\r\n     *\r\n     * @param {Array<string | object>} swatches - Color swatches.\r\n     */\r\n    addSwatches(...swatches) {\r\n        this._components._swatches._add(swatches);\r\n    }\r\n\r\n    /**\r\n     * Removes color swatches.\r\n     *\r\n     * @param {Array<string | number | object} swatches - Array of swatches or their indexes in the config.swatches array.\r\n     */\r\n    removeSwatches(...swatches) {\r\n        this._components._swatches._remove(swatches);\r\n    }\r\n\r\n    /**\r\n     * Enables picker.\r\n     */\r\n    enable() {\r\n        this._reference._setDisabled(false);\r\n    }\r\n\r\n    /**\r\n     * Disables picker.\r\n     */\r\n    disable() {\r\n        this._reference._setDisabled(true);\r\n    }\r\n\r\n    /**\r\n     * Resets to default color.\r\n     */\r\n    reset() {\r\n        this._color._set(this.config.default);\r\n    }\r\n\r\n    /**\r\n     * Repositions picker if it's displayed as a popover.\r\n     */\r\n    reposition() {\r\n        this._components._app._reposition();\r\n    }\r\n\r\n    /**\r\n     * Executes all handlers attached to the specified event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     */\r\n    trigger(type) {\r\n        this._events._dispatch(type);\r\n    }\r\n\r\n    /**\r\n     * Destroy picker and free up memory.\r\n     */\r\n    destroy() {\r\n        const alwan = this;\r\n\r\n        alwan._reference._destroy();\r\n        destroyComponents(alwan._components);\r\n\r\n        // Remove all properties of this instance.\r\n        objectIterator(alwan, (_, key) => {\r\n            delete alwan[key];\r\n        });\r\n\r\n        // Empty instance prototype.\r\n        setPrototypeOf(alwan, prototype);\r\n    }\r\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants/globals\"\r\nimport { merge, objectIterator } from \"../../utils/object\";\r\nimport { isset } from \"../../utils/is\";\r\n\r\n/**\r\n * Alwan events.\r\n *\r\n * @param {Alwan} alwan - Alwan Instance.\r\n * @returns\r\n */\r\nexport const Dispatcher = (alwan) => {\r\n    /**\r\n     * Alwan event listeners.\r\n     */\r\n    const listeners = {\r\n        [OPEN]: [],\r\n        [CLOSE]: [],\r\n        [CHANGE]: [],\r\n        [COLOR]: []\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Dispatch an event.\r\n         *\r\n         * @param {string} type - Alwan event.\r\n         * @param {object} ev - Event object.\r\n         */\r\n        _dispatch(type, source) {\r\n            if (! alwan.config.disabled) {\r\n                (listeners[type] || []).forEach(handler => {\r\n                    handler(merge({ type, source }, alwan._color._value()));\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Add an event listener.\r\n         *\r\n         * @param {string} event - Alwan event.\r\n         * @param {Function} listener - Event listener callback.\r\n         */\r\n        _addListener(event, listener) {\r\n            if (listeners[event] && ! listeners[event].includes(listener)) {\r\n                listeners[event].push(listener);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove event listener(s).\r\n         *\r\n         * @param {string} event - Alwan event.\r\n         * @param {Function} listener - Event listener callback.\r\n         */\r\n        _removeListeners(event, listener) {\r\n            if (! isset(event)) {\r\n                // Remove all listeners if event is undefined.\r\n                objectIterator(listeners, (_array, alwanEvent) => {\r\n                    listeners[alwanEvent] = [];\r\n                });\r\n            } else if (listeners[event]) {\r\n                if (isset(listener)) {\r\n                    // Remove the given listener.\r\n                    listeners[event] = listeners[event].filter((fn) => fn !== listener);\r\n                } else {\r\n                    // Remove all listeners of a given event if listener is undefined.\r\n                    listeners[event] = [];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ALWAN_CLASSNAME","CONTAINER_CLASSNAME","PALETTE_CLASSNAME","MARKER_CLASSNAME","PREVIEW_CLASSNAME","BUTTON_CLASSNAME","COPY_BUTTON_CLASSNAME","SLIDER_CLASSNAME","SLIDERS_CLASSNAME","HUE_SLIDER_CLASSNAME","ALPHA_SLIDER_CLASSNAME","INPUT_CLASSNAME","INPUTS_CLASSNAME","SWATCH_CLASSNAME","SWATCHES_CLASSNAME","PRESET_BUTTON_CLASSNAME","BACKDROP_CLASSNAME","COLLAPSE_BUTTON_CLASSNAME","POPUP_CLASSNAME","OPEN_CLASSNAME","COLLAPSE_CLASSNAME","ROOT","document","DOC_ELEMENT","documentElement","DEFAULT_COLOR","BUTTON","OPEN","CLOSE","COLOR","CLICK","POINTER_DOWN","POINTER_MOVE","POINTER_UP","KEY_DOWN","INPUT","CHANGE","RGB_FORMAT","HSL_FORMAT","COLOR_FORMATS","INSERT_BEFORE_FIRST_CHILD","INSERT_AFTER","INSERT_AFTER_LAST_CHILD","ARIA_LABEL","KEYBOARD_X","ArrowRight","ArrowLeft","KEYBOARD_Y","ArrowDown","ArrowUp","addEvent","target","event","listener","addEventListener","removeEvent","removeEventListener","keys","assign","merge","setPrototypeOf","from","toArray","isArray","Array","objectIterator","object","fn","props","mergeOptions","config","options","val","isString","value","isset","isTogglable","shared","toggle","bodyElement","body","getElement","reference","context","all","trim","Element","contains","insertElement","element","targetElement","where","insertAdjacentElement","setHTML","html","innerHTML","createElement","tagName","className","details","insertPosition","name","setAttribute","getBounds","x","y","width","height","right","bottom","clientWidth","clientHeight","getBoundingClientRect","replaceElement","replacement","replaceWith","removeElement","remove","getOverflowAncestors","ancestors","parentElement","test","getComputedStyle","overflow","push","customProperty","property","style","toggleClassName","tokens","toggler","forEach","token","classList","createButton","label","title","type","translate","transform","createSlider","parent","max","step","createContainer","setLabel","Reference","userReference","alwan","buttonClasses","handleClick","_el","_init","preset","classname","id","split","_setDisabled","disabled","_components","_app","_toggle","_destroy","this","parseFloat","float","parseInt","int","isFinite","isNumeric","Number","min","abs","round","PI","Math","boundNumber","number","upperBound","lowerBound","normalizeAngle","angle","fallbackSides","top","left","fallbackAlignments","start","center","end","App","popoverInstance","isOpen","_setup","instance","components","theme","popover","position","margin","refElement","_reference","isShared","dataset","display","container","_margin","_position","autoUpdate","popoverAccessibility","side","alignment","sidesFlipOrder","alignmentsFlipOrder","overflowAncestors","_update","visualViewport","targetBounds","containerBounds","coordinates","some","axis","domSide","targetSide","requiredSpace","containerDimension","targetLowerBound","targetUpperBound","upperBoundDistance","offset","map","isVisible","every","ancestor","ancestorX","ancestorY","ancestorRight","ancestorBottom","eventHandler","popoverEvents","window","createPopover","_color","update","isInViewport","closeOnScroll","e","focusableElements","firstFocusableElement","lastFocusableElement","elementToFocusOn","shiftKey","labels","pop","preventDefault","focus","state","forced","instanceConfig","_reposition","_events","_dispatch","_isOpen","clipboardSVG","stringify","color","format","opacity","a","str","r","g","b","h","s","l","ctx","getContext","HSL_REGEX","HEX_REGEX","ANGLE_COEFFICIENT_MAP","deg","turn","rad","grad","parseColor","asString","find","input","percentage","exec","fillStyle","slice","Swatches","ref","swatchesArray","collapseButton","swatches","toggleSwatches","length","i18n","buttons","swatch","reposition","_set","_add","_remove","filter","index","item","sharedComponents","instanceCount","createComponents","_palette","markerX","markerY","paletteBounds","backdropElement","isPointerDown","palette","tabindex","marker","moveMarkerAndUpdateColor","keyboard","v","L","clientX","clientY","S","drag","dragEnd","_change","_save","core","_options","updateAll","Palette","_utility","previewElement","copyButton","isCopied","updateIcon","fallback","select","execCommand","copyColor","clipboard","navigator","_get","writeText","then","catch","preview","copy","blur","_preview","Utility","_sliders","alphaSlider","hueSlider","handleChange","hue","alpha","sliders","opaqueHex","Sliders","_inputs","inputsContainer","switchButton","currentFormatIndex","inputsMap","formats","isChanged","isSingle","singleInput","build","field","labelElement","close","changeFormat","_setFormat","inputs","indexOf","_values","Inputs","_swatches","destroyComponents","toHex","toString","k","savedColor","rgb","hex","hsl","source","HSLToRGB","rgbString","alphaHex","RGBToHEX","check","triggerChange","parsedColor","parsedColorFormat","parsedColorString","cMax","cMin","d","RGBToHSL","_value","newFormat","defaults","default","Alwan","VERSION","constructor","listeners","handler","_addListener","includes","_removeListeners","_array","alwanEvent","Dispatcher","setOptions","app","useComponents","open","on","off","setColor","getColor","addSwatches","removeSwatches","enable","disable","reset","trigger","destroy","_"],"sourceRoot":""}