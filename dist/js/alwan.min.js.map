{"version":3,"file":"js/alwan.min.js","mappings":"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","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/constants/classnames.js","webpack://Alwan/./src/constants/globals.js","webpack://Alwan/./src/utils/string.js","webpack://Alwan/./src/core/events/binder.js","webpack://Alwan/./src/utils/number.js","webpack://Alwan/./src/utils/object.js","webpack://Alwan/./src/utils/util.js","webpack://Alwan/./src/utils/dom.js","webpack://Alwan/./src/lib/popper.js","webpack://Alwan/./src/components/App.js","webpack://Alwan/./src/assets/svg.js","webpack://Alwan/./src/colors/stringify.js","webpack://Alwan/./src/colors/converter.js","webpack://Alwan/./src/colors/parser.js","webpack://Alwan/./src/core/component.js","webpack://Alwan/./src/components/Palette.js","webpack://Alwan/./src/components/Utility.js","webpack://Alwan/./src/components/Sliders.js","webpack://Alwan/./src/components/Inputs.js","webpack://Alwan/./src/components/Swatches.js","webpack://Alwan/./src/core/color.js","webpack://Alwan/./src/core/init.js","webpack://Alwan/./src/constants/defaults.js","webpack://Alwan/./src/index.js","webpack://Alwan/./src/core/events/dispatcher.js","webpack://Alwan/./src/components/reference.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ALWAN_CLASSNAME = 'alwan';\r\nexport const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;\r\nexport const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;\r\nexport const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;\r\nexport const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;\r\nexport const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;\r\nexport const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;\r\nexport const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;\r\nexport const SLIDERS_CLASSNAME = `${ALWAN_CLASSNAME}__sliders`;\r\nexport const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--hue`;\r\nexport const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--alpha`;\r\nexport const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;\r\nexport const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;\r\nexport const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;\r\nexport const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;\r\nexport const PRESET_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__preset-button`;\r\nexport const OVERLAY_CLASSNAME = `${ALWAN_CLASSNAME}__overlay`;\r\nexport const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__collapse-button`;\r\n\r\nexport const POPUP_CLASSNAME = `${ALWAN_CLASSNAME}--popup`;\r\nexport const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;\r\nexport const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;","export const ROOT = document;\r\nexport const HTML = ROOT.documentElement;\r\n\r\nexport const BUTTON = 'button';\r\n\r\nexport const OPEN = 'open';\r\nexport const CLOSE = 'close';\r\nexport const COLOR = 'color';\r\nexport const CLICK = 'click';\r\nexport const POINTER_DOWN = 'pointerdown';\r\nexport const POINTER_MOVE = 'pointermove';\r\nexport const POINTER_UP = 'pointerup';\r\nexport const SCROLL = 'scroll';\r\nexport const RESIZE = 'resize';\r\nexport const KEY_DOWN = 'keydown';\r\nexport const INPUT = 'input';\r\nexport const CHANGE = 'change';\r\nexport const FOCUS_OUT = 'focusout';\r\nexport const FOCUS_IN = 'focusin';\r\nexport const MOUSE_OUT = 'mouseout';\r\n\r\nexport const HEX_FORMAT = 'hex';\r\nexport const RGB_FORMAT = 'rgb';\r\nexport const HSL_FORMAT = 'hsl';\r\nexport const HSV_FORMAT = 'hsv';\r\n\r\nexport const TAB = 'Tab';\r\nexport const ENTER = 'Enter';\r\nexport const ESCAPE = 'Escape';\r\n\r\nexport const COLOR_PROPERTY = '--lw-' + COLOR;\r\n\r\n// Picker supported color formats.\r\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\r\nexport const INSERT_BEFORE_FIRST_CHILD = 'afterbegin';","/**\r\n * Checks if a value is a string.\r\n *\r\n * @param {unknown} value - Value to check.\r\n * @returns {boolean} Whether value is a string.\r\n */\r\nexport const isString = (value) => {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Trims a string.\r\n *\r\n * @param {string} str - String to trim.\r\n * @returns {string} trimmed string\r\n */\r\nexport const trimString = (str) => {\r\n    return str.trim();\r\n}","import { isString } from \"../../utils/string\";\r\n\r\n/**\r\n * Adds event listeners to an element and stores its data.\r\n *\r\n * @returns {object}\r\n */\r\nexport const Binder = () => {\r\n    /**\r\n     * Stores event listeners data.\r\n     */\r\n    let eventListenersData = [];\r\n\r\n    /**\r\n     * Adds/Removes event listeners.\r\n     *\r\n     * @param {EventTarget} eventTarget - Event target.\r\n     * @param {array<string>} events - Events (event type)\r\n     * @param {Function} handler - Event handler.\r\n     * @param {boolean} toggler - add/remove event listener.\r\n     */\r\n    let toggleEventListener = (eventTarget, events, handler, toggler = true) => {\r\n        events.forEach(event => {\r\n            eventTarget[`${toggler?`add`:`remove`}EventListener`](event, handler);\r\n        });\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * binds an event listener to an element.\r\n         *\r\n         * @param {EventTarget} eventTarget - Event target.\r\n         * @param {string|Array<string>} events - Event(s)\r\n         * @param {Function} handler - Event handler.\r\n         */\r\n        _bind(eventTarget, events, handler) {\r\n            if (isString(events)) {\r\n                events = [events];\r\n            }\r\n            eventListenersData.push([eventTarget, events, handler]);\r\n            toggleEventListener(eventTarget, events, handler);\r\n        },\r\n\r\n        /**\r\n         * Removes all event listeners and clears their data.\r\n         */\r\n        _unbindAll() {\r\n            eventListenersData.forEach(([target, events, handler]) => {\r\n                toggleEventListener(target, events, handler, false);\r\n            });\r\n            eventListenersData = [];\r\n        }\r\n    }\r\n}","export const { parseFloat: float, parseInt: int, isFinite: isNumeric } = Number;\r\nexport const { min, max, abs, round, PI } = Math;\r\n\r\n/**\r\n * Keeps a number in a range.\r\n *\r\n * @param {number} number - A number to keep it between two numbers.\r\n * @param {number} upperBound - Max.\r\n * @param {number} lowerBound - Min.\r\n * @returns {number}\r\n */\r\nexport const confineNumber = (number, upperBound = 100, lowerBound = 0) => {\r\n    return min(max(number, lowerBound), upperBound);\r\n}\r\n\r\n/**\r\n * Angle value in degrees, it must be between 0 and 360.\r\n *\r\n * @param {number} angle - Angle.\r\n * @returns {Number}\r\n */\r\nexport const normalizeAngle = angle => {\r\n    return (round(angle) % 360 + 360) % 360;\r\n}","export const { keys, assign: merge, setPrototypeOf, prototype } = Object;\r\n\r\n/**\r\n * Iterate in an object.\r\n * If any callback function return a value different then null or undefined,\r\n * then stop iteration and return that value.\r\n *\r\n * @param {Object} object - Any object.\r\n * @param {Function} fn - A Callback function.\r\n * @returns {any}\r\n */\r\nexport const objectIterator = (object, fn) => {\r\n    let props = keys(object);\r\n    for (const prop of props) {\r\n       fn(object[prop], prop);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if obj1 keys and values equal to obj2's keys and values.\r\n *\r\n * @param {Object} obj1 - Any object.\r\n * @param {Object} obj2 - Any object.\r\n * @returns {Boolean}\r\n */\r\nexport const isEqual = (obj1, obj2) => {\r\n    if (obj1 && obj2) {\r\n        return keys(obj1).every(key => obj1[key] === obj2[key]);\r\n    }\r\n    return false;\r\n}","/**\r\n * Checks if a value is not undefined or null.\r\n *\r\n * @param {Any} value - Value.\r\n * @returns {Boolean}\r\n */\r\nexport const isset = value => value != null;","import { BUTTON_CLASSNAME, SLIDER_CLASSNAME } from \"../constants/classnames\";\r\nimport { BUTTON, HTML, INPUT, ROOT } from \"../constants/globals\";\r\nimport { round } from \"./number\";\r\nimport { merge, objectIterator } from \"./object\";\r\nimport { isString, trimString } from \"./string\";\r\nimport { isset } from \"./util\";\r\n\r\n/**\r\n * Gets the body element.\r\n *\r\n * @returns Document's body.\r\n */\r\nexport const body = () => ROOT.body;\r\n\r\n/**\r\n * Gets elements.\r\n *\r\n * @param {string|Element} reference - CSS selector or a HTML element.\r\n * @param {Document|Element} context - Element to search from.\r\n * @param {boolean} all - Select all elements.\r\n * @returns {null|Element|NodeList}\r\n */\r\nexport const getElement = (reference, context = ROOT, all = false) => {\r\n    if (isString(reference) && trimString(reference)) {\r\n        return context[`querySelector${ all ? 'All' : ''}`](reference);\r\n    }\r\n\r\n    if (reference instanceof Element) {\r\n        return reference;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Inserts an element relative to another element (target element).\r\n *\r\n * @param {Element} element - The element to be inserted.\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {string} where - Insert position relative to the targetElement.\r\n * @returns {Element|undefined} - The inserted element.\r\n */\r\nexport const insertElement = (element, targetElement, where) => {\r\n    if (element && targetElement) {\r\n        return targetElement.insertAdjacentElement(where || 'beforeend', element);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets element's inner html.\r\n *\r\n * @param {Element} element - An HTML element.\r\n * @param {string} html - HTML string.\r\n */\r\nexport const setHTML = (element, html) => {\r\n    element.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Creates a new HTML Element.\r\n *\r\n * @param {string} tagName - Element tag name.\r\n * @param {string} className - Element class name.\r\n * @param {Element} targetElement - Insert the new element relative to this element using position.\r\n * @param {object} details - Element details (attributes + Initial content).\r\n * @param {InsertPosition} insertPosition - Insert position.\r\n * @returns {Element} The new created element.\r\n */\r\nexport const createElement = (tagName, className, targetElement, details, insertPosition) => {\r\n    const element = ROOT.createElement(tagName || 'div');\r\n\r\n    if (className) {\r\n        element.className = className;\r\n    }\r\n\r\n    objectIterator(details || {}, (value, name) => {\r\n        if (name === 'html') {\r\n            setHTML(element, value);\r\n        } else if (value) {\r\n            element.setAttribute(name, value);\r\n        }\r\n    });\r\n\r\n    if (targetElement) {\r\n        insertElement(element, targetElement, insertPosition);\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * Gets element's bounding rect.\r\n *\r\n * @param {Document|Element} element - Element.\r\n * @returns {DOMRect}\r\n */\r\nexport const getBounds = (element) => {\r\n    if (element === ROOT) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            top: 0,\r\n            left: 0,\r\n            right: HTML.clientWidth,\r\n            bottom: HTML.clientHeight\r\n        }\r\n    }\r\n    return element.getBoundingClientRect();\r\n}\r\n\r\n/**\r\n * Gets an element parent.\r\n *\r\n * @param {Element} element - Element.\r\n * @returns {Element|null} - The parent element.\r\n */\r\nexport const parent = (element) => {\r\n    return element.parentElement;\r\n}\r\n\r\n/**\r\n * Replaces an element in the DOM with another element.\r\n *\r\n * @param {Element} newElement - Element to replace another element.\r\n * @param {Element} oldElement - Element to be replaced by the newElement.\r\n * @returns {Element} The new element.\r\n */\r\nexport const replaceElement = (newElement, oldElement) => {\r\n    parent(oldElement).replaceChild(newElement, oldElement);\r\n    return newElement;\r\n}\r\n\r\n/**\r\n * Remove element from the document.\r\n *\r\n * @param {Element} element - Element to remove.\r\n */\r\nexport const removeElement = (element) => {\r\n    if (element) {\r\n        element.remove();\r\n    }\r\n}\r\n\r\n/**\r\n * Gets scrollable ancestor of an element (body element is not included).\r\n *\r\n * @param {Element} element - Element.\r\n * @param {array<Element|Document>} scrollables - Array of scrollable Elements.\r\n * @returns {array<Element|Document>}\r\n */\r\nexport const getScrollableAncestors = (element, scrollables = [ROOT]) => {\r\n    element = parent(element);\r\n    if (! element || element === ROOT.body) {\r\n        return scrollables;\r\n    }\r\n\r\n    if (/auto|scroll/.test(getComputedStyle(element).overflow)) {\r\n        scrollables.push(element);\r\n    }\r\n\r\n    return getScrollableAncestors(element, scrollables);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Check if an element is visible in the viewport of all scrollable elements.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {Array} scrollables - Scrollable elements.\r\n * @returns {boolean}\r\n */\r\nexport const isInViewport = (element, scrollables) => {\r\n    return scrollables.every(scrollable => {\r\n        let { x: elementX, y: elementY, bottom: elementBottom, right: elementRight } = getBounds(element);\r\n        let { x: scrollableX, y: scrollableY, bottom: scrollableBottom, right: scrollableRight } = getBounds(scrollable);\r\n\r\n        return elementY < scrollableBottom && elementBottom > scrollableY && elementX < scrollableRight && elementRight > scrollableX;\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Sets a CSS custom property.\r\n *\r\n * @param {HTMLElement} el  - Element to set its custom property.\r\n * @param {string} property - Property name.\r\n * @param {string} value    - Property value.\r\n */\r\nexport const setCustomProperty = (element, property, value) => {\r\n    if (element && isset(value)) {\r\n        element.style.setProperty(property, value);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Hides/Shows element.\r\n *\r\n * @param {Element} element - Element to show/hide.\r\n * @param {boolean} toggler - Whether to show (true) or hide the element.\r\n */\r\nexport const toggleVisibility = (element, toggler = true) => {\r\n    element.style.display = toggler ? '' : 'none';\r\n}\r\n\r\n/**\r\n * Adds/Removes a class to/from an based on a boolean variable.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {string|string[]} tokens - Class name or array of classes.\r\n * @param {boolean} toggler - Whether to add (true) or remove a class.\r\n */\r\nexport const toggleClassName = (element, tokens, toggler) => {\r\n\r\n    if (isString(tokens)) {\r\n        tokens = [tokens];\r\n    }\r\n\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            element.classList.toggle(token, toggler);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a button Element.\r\n *\r\n * @param {string} className - Class.\r\n * @param {Element} targetElement - TargetElement.\r\n * @param {object} details - Button details.\r\n * @param {string} insertPosition - Button insert position.\r\n * @returns {Element} A button.\r\n */\r\nexport const createButton = (className, targetElement, details, insertPosition) => {\r\n    return createElement(BUTTON, BUTTON_CLASSNAME + ' ' + className, targetElement, merge({ type: BUTTON }, details), insertPosition);\r\n}\r\n\r\n/**\r\n * Translates an element.\r\n *\r\n * @param {Element} element - Element to translate.\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n */\r\nexport const translate = (element, x, y) => {\r\n    element.style.transform = `translate(${round(x)}px,${round(y)}px)`;\r\n}\r\n\r\n/**\r\n * Creates a slider.\r\n *\r\n * @param {string} className - CSS class.\r\n * @param {Element} parent - Sldier parent.\r\n * @param {number} max - Max property.\r\n * @param {number} step - Step property.\r\n * @returns {HTMLInputElement} - Slider.\r\n */\r\nexport const createSlider = (className, parent, max, step) => {\r\n    return createElement(INPUT, SLIDER_CLASSNAME + ' ' + className, parent, { type: 'range', max, step });\r\n}","import { ROOT } from \"../constants/globals\";\r\nimport { getBounds, translate } from \"../utils/dom\";\r\nimport { abs, float, isNumeric } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { isString } from \"../utils/string\";\r\n\r\n/**\r\n * Popper constants.\r\n */\r\nconst TOP = 'top';\r\nconst BOTTOM = 'bottom';\r\nconst RIGHT = 'right';\r\nconst LEFT = 'left';\r\nconst START = 'start';\r\nconst CENTER = 'center';\r\nconst END = 'end';\r\n\r\nconst dimension = {\r\n    x: 'width',\r\n    y: 'height'\r\n}\r\n\r\nconst upperBound = {\r\n    x: RIGHT,\r\n    y: BOTTOM\r\n}\r\n\r\nconst X_AXIS = 'x';\r\nconst Y_AXIS = 'y';\r\n\r\n/**\r\n * Creates popper instance.\r\n *\r\n * @param {Element} reference - Popper reference element.\r\n * @param {Element} container - Popper container.\r\n * @param {object} param2 - Popper options.\r\n * @returns {object} - Popper instance.\r\n */\r\nexport const createPopper = (reference, container, { _margin, _position }) => {\r\n    /**\r\n     * Sides to fallback to.\r\n     */\r\n    let fallbackSides = {\r\n        [TOP]:    [TOP, BOTTOM, RIGHT, LEFT],\r\n        [BOTTOM]: [BOTTOM, TOP, RIGHT, LEFT],\r\n        [RIGHT]:  [RIGHT, LEFT, TOP, BOTTOM],\r\n        [LEFT]:   [LEFT, RIGHT, TOP, BOTTOM]\r\n    };\r\n    /**\r\n     * Alignments to fallback to.\r\n     */\r\n    let fallbackAlignments = {\r\n        start: [START, CENTER, END],\r\n        center: [CENTER, START, END],\r\n        end: [END, CENTER, START]\r\n    };\r\n    /**\r\n     * Popup coordinates.\r\n     */\r\n    let coordinates;\r\n\r\n    /**\r\n     * Space between the reference and the container.\r\n     */\r\n    let margin = 5;\r\n\r\n    /**\r\n     * Side and alignment from the position.\r\n     */\r\n    let [side, alignment] = isString(_position) ? _position.split('-') : [];\r\n\r\n    // Validate values.\r\n    if (! fallbackSides[side]) {\r\n        side = BOTTOM;\r\n    }\r\n    if (! alignment) {\r\n        alignment = CENTER;\r\n    } else if (! fallbackAlignments[alignment]) {\r\n        alignment = START;\r\n    }\r\n    _margin = float(_margin);\r\n    if (isNumeric(_margin)) {\r\n        margin = _margin;\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Popper Reference element.\r\n         *\r\n         * @type {Element}\r\n         */\r\n        _reference: reference,\r\n\r\n        /**\r\n         * Update container's position.\r\n         */\r\n        _update() {\r\n            let domBounds = getBounds(ROOT);\r\n            let referenceBoundingRect = getBounds(reference);\r\n            let containerBoundingRect = getBounds(container);\r\n\r\n            coordinates = {\r\n                x: null,\r\n                y: null\r\n            }\r\n\r\n            /**\r\n             * Check sides.\r\n             */\r\n            fallbackSides[side].some(referenceSide => {\r\n                let axis = referenceSide === TOP || referenceSide === BOTTOM ? Y_AXIS : X_AXIS;\r\n\r\n                let domBound = domBounds[referenceSide];\r\n                let referenceBound = referenceBoundingRect[referenceSide];\r\n\r\n                // The amount of space for the container.\r\n                let containerSpace = margin + containerBoundingRect[dimension[axis]];\r\n                // If container has available space.\r\n                if (containerSpace <= abs(domBound - referenceBound)) {\r\n                    // Calculate coordinate to set this side,\r\n                    // for the top/left sides substruct the container space from the top/left bound of the reference element,\r\n                    // and for the bottom/right sides just add the margin.\r\n                    coordinates[axis] = referenceBound + (domBound ? margin : -containerSpace);\r\n                    // Reverse the axises for the alignments.\r\n                    axis = axis === X_AXIS ? Y_AXIS : X_AXIS;\r\n\r\n                    /**\r\n                     * Check alignments, only if the container is attached.\r\n                     */\r\n                    fallbackAlignments[alignment].some(alignment => {\r\n                        // container width/height depends on the axis.\r\n                        let containerDimension = containerBoundingRect[dimension[axis]];\r\n                        // Lower bound is for the top/left coordinates.\r\n                        // Upper bound is for the bottom/right coordinates.\r\n                        // top/left coordinates are always lesser(lower) than bottom/right.\r\n                        let {\r\n                            [axis]: referenceLowerBound,\r\n                            [upperBound[axis]]: referenceUpperBound,\r\n                        } = referenceBoundingRect;\r\n                        // Distance between the reference bottom/right coordinates and the DOM,\r\n                        // bottom/right coordinates or boundries.\r\n                        let upperBoundDistance = domBounds[upperBound[axis]] - referenceLowerBound;\r\n\r\n                        // Offset between the container and the reference element.\r\n                        let offset = (containerDimension + referenceBoundingRect[dimension[axis]]) / 2;\r\n\r\n                        // Check for space availability and set the coordinate.\r\n                        if (alignment === START && containerDimension <= upperBoundDistance) {\r\n                            coordinates[axis] = referenceLowerBound;\r\n                            return true;\r\n                        }\r\n                        if (alignment === CENTER && offset <= referenceUpperBound && offset <= upperBoundDistance) {\r\n                            coordinates[axis] = referenceUpperBound - offset;\r\n                            return true;\r\n                        }\r\n                        if (alignment === END && containerDimension <= referenceUpperBound) {\r\n                            coordinates[axis] = referenceUpperBound - containerDimension;\r\n                            return true;\r\n                        }\r\n                    });\r\n                    // Exit the fallback sides loop.\r\n                    return true;    \r\n                }\r\n            });\r\n            // If there is no space to position the popover in all sides,\r\n            // then center the popover in the screen.\r\n            // If the popover is attached to one side but there is no space,\r\n            // for the alignment than center it horizontally/vertically depends on the side.\r\n            objectIterator(coordinates, (value, axis) => {\r\n                if (value === null) {\r\n                    coordinates[axis] = (domBounds[upperBound[axis]] - containerBoundingRect[dimension[axis]]) / 2;\r\n                }\r\n            });\r\n\r\n            translate(container, coordinates.x, coordinates.y);\r\n        }\r\n    }\r\n}","import { OPEN_CLASSNAME, POPUP_CLASSNAME } from \"../constants/classnames\";\r\nimport { BUTTON, CLOSE, ESCAPE, INPUT, KEY_DOWN, OPEN, POINTER_DOWN, RESIZE, ROOT, SCROLL, TAB } from \"../constants/globals\";\r\nimport { Binder } from \"../core/events/binder\";\r\nimport { createPopper } from \"../lib/popper\";\r\nimport { getElement, getScrollableAncestors, insertElement, isInViewport, removeElement, toggleClassName, toggleVisibility } from \"../utils/dom\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { isString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates App componenet and initialize components.\r\n *\r\n * @param {Element} root - Picker container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {App}\r\n */\r\nexport const App = (root, alwan, events) => {\r\n    /**\r\n     * Alwan reference element.\r\n     */\r\n    let referenceElement;\r\n\r\n    /**\r\n     * Popper event binder.\r\n     */\r\n    let popperEvents = Binder();\r\n\r\n    /**\r\n     * Popper instance.\r\n     */\r\n    let popper;\r\n\r\n    /**\r\n     * Popper reference's scrollable ancestors.\r\n     *\r\n     * @type {Array[Element]}\r\n     */\r\n    let scrollableAncestors;\r\n\r\n    /**\r\n     * Visibility state.\r\n     */\r\n    let isOpen = false;\r\n\r\n    /**\r\n     * Setup and Initialize other components.\r\n     *\r\n     * @param {object} options - Alwan options.\r\n     * @param {object} instance - Alwan instance.\r\n     */\r\n    const _setup = (options, instance = alwan) => {\r\n        alwan = instance;\r\n        let { theme, popover, target, position, margin, id, toggle, shared } = options;\r\n        let targetElement = getElement(target);\r\n\r\n        if (isString(id) && ! shared) {\r\n            root.id = id;\r\n        }\r\n\r\n        // Initialize components.\r\n        objectIterator(alwan._components, ({ _init }) => {\r\n            if (_init) {\r\n                _init(options, alwan);\r\n            }\r\n        })\r\n\r\n        referenceElement = alwan._reference._element;\r\n        target = targetElement || referenceElement;\r\n\r\n        // Set theme (dark or light).\r\n        root.dataset.theme = theme;\r\n\r\n        // Toggle option changed to false then open (show) the picker\r\n        if (! toggle && ! shared) {\r\n            _toggle(alwan, true, true);\r\n        }\r\n        // Hide reference element if both popover and toggle are false.\r\n        // and the components are not shared.\r\n        toggleVisibility(referenceElement, popover || toggle || shared);\r\n        // Toggle popup class that makes the root's position fixed.\r\n        toggleClassName(root, POPUP_CLASSNAME, popover);\r\n\r\n        popperEvents._unbindAll();\r\n        popper = null;\r\n\r\n        if (popover) {\r\n            popper = createPopper(target, root, {\r\n                _margin: margin,\r\n                _position: position\r\n            });\r\n            popper._update();\r\n            // If reference element inside a nested scrollable elements,\r\n            // get all those scrollable elements in an array.\r\n            scrollableAncestors = getScrollableAncestors(target);\r\n            // Attach scroll event to all scrollable ancestors of the reference element,\r\n            // in order to update the popper's position.\r\n            // On window resize reposition the popper.\r\n            popperEvents._bind(window, RESIZE, updatePopper);\r\n            scrollableAncestors.forEach(scrollable => {\r\n                popperEvents._bind(scrollable, SCROLL, updatePopper);\r\n            });\r\n            popperEvents._bind(ROOT, [KEY_DOWN, POINTER_DOWN], handleAccessibility);\r\n        } else {\r\n            root.style = '';\r\n            insertElement(root, target, ! targetElement && 'afterend');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates popper's position and visibility.\r\n     *\r\n     * @param {Event} e - Event.\r\n     */\r\n    const updatePopper = e => {\r\n        if (isOpen) {\r\n\r\n            popper._update();\r\n\r\n            // Close picker if popper's reference is scrolled out of view.\r\n            if (! isInViewport(popper._reference, scrollableAncestors)) {\r\n                _toggle(alwan, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keyboard accessibility.\r\n     *\r\n     * If picker is displayed as a popover then link the focus from the reference,\r\n     * to the picker focusable elements.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleAccessibility = e => {\r\n        if (isOpen) {\r\n            let { target, key, shiftKey } = e;\r\n            let paletteElement = alwan._components._palette._element;\r\n            let elementToFocusOn;\r\n            let lastFocusableElement;\r\n\r\n            // Close picker if:\r\n            // - Escape key is pressed.\r\n            // - A pointerdown event happened ouside the picker and not on the reference element or one of its labels,\r\n            // (only if the reference element is a labelable element).\r\n            if (key === ESCAPE || (target !== referenceElement && ! root.contains(target) && ! [...referenceElement.labels || []].some(label => label.contains(target)))) {\r\n                _toggle(alwan, false);\r\n            } else if (key === TAB) {\r\n\r\n                lastFocusableElement = [...getElement(BUTTON + ',' + INPUT, root, true)].pop();\r\n\r\n                if (target === referenceElement && ! shiftKey) {\r\n                    // Pressing Tab while focusing on the reference element sends focus,\r\n                    // to the first element (palette) inside the picker container.\r\n                    elementToFocusOn = paletteElement;\r\n                } else if ((shiftKey && target === paletteElement) || (! shiftKey && target === lastFocusableElement)) {\r\n                    // Pressing Tab while focusing on the palette with the shift key or focussing on the last,\r\n                    // focusable element without shift key sends focus to the reference element (if it's focusable).\r\n                    elementToFocusOn = referenceElement;\r\n                }\r\n                if (elementToFocusOn) {\r\n                    e.preventDefault();\r\n                    elementToFocusOn.focus();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles color picker visiblity.\r\n     *\r\n     * @param {object} instance - Alwan instance.\r\n     * @param {boolean} state - True to open, false to close.\r\n     * @param {boolean} forced - Open/Close picker even if its disabled or the toggle option is set to false.\r\n     */\r\n    const _toggle = (instance, state, forced) => {\r\n        instance = instance || alwan;\r\n        let { shared, toggle, disabled } = instance.config;\r\n\r\n        if (! disabled || forced) {\r\n\r\n            if (! isset(state)) {\r\n                // If the instance doesn't control the components.\r\n                // then close the instance that controls the components.\r\n                if (isOpen && instance !== alwan) {\r\n                    _toggle(alwan, false);\r\n                }\r\n\r\n                state = ! isOpen;\r\n            }\r\n\r\n            if (state !== isOpen && (shared || toggle || forced)) {\r\n                if (state) {\r\n                    if (instance !== alwan) {\r\n                        // Set components to point to the new instance,\r\n                        // and update options.\r\n                        _setup(instance.config, instance);\r\n                    }\r\n                    alwan._color._updateAll();\r\n                    _reposition();\r\n                }\r\n\r\n                // Only the instance that controls the components,\r\n                // open/close the picker.\r\n                if (instance === alwan) {\r\n                    isOpen = state;\r\n                    toggleClassName(root, OPEN_CLASSNAME, state);\r\n                    alwan._events._dispatch(state ? OPEN : CLOSE, root);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the popper's position.\r\n     */\r\n    const _reposition = () => {\r\n        if (popper) {\r\n            popper._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets current picker state (opened or closed).\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    const _isOpen = () => {\r\n        return isOpen;\r\n    }\r\n\r\n    /**\r\n     * Destroy components and remove root element from the DOM.\r\n     */\r\n    const _destroy = () => {\r\n        // Remove components events.\r\n        events._unbindAll();\r\n        // Remove popper events.\r\n        popperEvents._unbindAll();\r\n        root = removeElement(root);\r\n        alwan = {};\r\n    }\r\n\r\n    return {\r\n        _root: root,\r\n        _setup,\r\n        _reposition,\r\n        _toggle,\r\n        _isOpen,\r\n        _destroy\r\n    }\r\n}","export const clipboardSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>`;\r\nexport const checkSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path></svg>`;\r\nexport const switchInputsSVG = `<svg width=\"15\" height=\"15\" viewBox=\"0 0 20 20\" aria-role=\"none\"><path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path></svg>`;\r\nexport const caretSVG = `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z\"></path></svg>`;","import { HSL_FORMAT } from \"../constants/globals\";\r\n\r\n/**\r\n * Converts RGB or HSL color objects to string.\r\n *\r\n * @param {object} color - HSL or RGB color object.\r\n * @param {string} format - hsl or rgb.\r\n * @returns {string} rgb or hsl string.\r\n */\r\nexport const stringify = (color, format, opaque) => {\r\n    let percentage = '';\r\n    let opacity = '';\r\n    let a = color.a;\r\n\r\n    if (format === HSL_FORMAT) {\r\n        percentage = '%';\r\n    }\r\n\r\n    if (a < 1 && ! opaque) {\r\n        format += 'a';\r\n        opacity = ', ' + a;\r\n    }\r\n\r\n    return `${format}(${color[format[0]]}, ${color[format[1]] + percentage}, ${color[format[2]] + percentage + opacity})`;\r\n}","import { int, max, min, normalizeAngle, round } from \"../utils/number\";\r\n\r\n/**\r\n * Helper function used for converting HSV to RGB.\r\n *\r\n * @param {number} k - Positive coefficient.\r\n * @param {number} s - Saturation.\r\n * @param {number} v - Value.\r\n * @returns {number}\r\n */\r\nconst fn = (k, s, v) => {\r\n    return (v - v * s * max(0, min(k, 4 - k, 1))) * 255;\r\n}\r\n\r\n/**\r\n * Converts HSV to RGB.\r\n *\r\n * @param {object} param0 - HSV color object.\r\n * @returns {object} - RGB color object.\r\n */\r\nexport const HSVToRGB = ({ h, s, v, a }) => {\r\n    h /= 60;\r\n    return {\r\n        r: round(fn((5 + h) % 6, s, v)),\r\n        g: round(fn((3 + h) % 6, s, v)),\r\n        b: round(fn((1 + h) % 6, s, v)),\r\n        a\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts hex color string to RGB object.\r\n *\r\n * @param {string} hex - Hexadecimal color.\r\n * @returns {object} - RGB color object.\r\n */\r\nexport const HEXToRGB = hex => {\r\n    return {\r\n        r: int(hex.slice(1, 3), 16),\r\n        g: int(hex.slice(3, 5), 16),\r\n        b: int(hex.slice(5, 7), 16),\r\n        a: 1\r\n    }\r\n}\r\n\r\n/**\r\n * Converts a decimal number to hexadecimal.\r\n *\r\n * @param {number} number - A decimal number.\r\n * @returns {string} - Hexadecimal.\r\n */\r\nconst toHex = number => {\r\n    return (number < 16 ? '0' : '') + number.toString(16);\r\n}\r\n\r\n\r\n/**\r\n * Converts RGB object to Hex string.\r\n *\r\n * @param {object} param0 - RGB color object.\r\n * @returns {string} - Hex color.\r\n */\r\nexport const RGBToHEX = ({ r, g, b, a }) => {\r\n    return '#' + toHex(r) + toHex(g) + toHex(b) + (a < 1 ? toHex(round(a * 255)) : '');\r\n}\r\n\r\n\r\n/**\r\n * Converts HSV to HSL.\r\n *\r\n * @param {object} param0 - HSV color object.\r\n * @returns {object} - HSL object.\r\n */\r\nexport const HSVToHSL = ({ h, s, v, a }) => {\r\n    // Lightness value.\r\n    s = v * (1 - s / 2);\r\n\r\n    return {\r\n        h,\r\n        s: round((! s || s === 1 ? 0 : (v - s) / min(s, 1 - s)) * 100),\r\n        l: round(s * 100),\r\n        a: round(a * 100) / 100\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts HSL to HSV.\r\n *\r\n * @param {Object} hsl - HSL color object.\r\n * @returns {Object}\r\n */\r\nexport const HSLToHSV = ({ h, s, l, a }) => {\r\n    l /= 100;\r\n    // Value.\r\n    s = l + s * min(l, 1 - l) / 100;\r\n\r\n    return {\r\n        h,\r\n        s: s ? 2 * (1 - l / s) : 0,\r\n        v: s,\r\n        a\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts RGB to HSV.\r\n *\r\n * @param {Object} rgb - RGB color object.\r\n * @returns {Object}\r\n */\r\nexport const RGBToHSV = ({ r, g, b, a }) => {\r\n\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    let cMax = max(r, g, b);\r\n    let cMin = min(r, g, b);\r\n    let range = cMax - cMin;\r\n    let h = range === 0 ? 0\r\n            : cMax === r ? ((g - b) / range) % 6\r\n            : cMax === g ? ((b - r) / range) + 2\r\n            : cMax === b ? ((r - g) / range) + 4\r\n            : 0;\r\n\r\n    return {\r\n        h: normalizeAngle(h * 60),\r\n        s: cMax ? range / cMax : 0,\r\n        v: cMax,\r\n        a: round(a * 100) / 100\r\n    }\r\n}","import { HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { createElement } from \"../utils/dom\";\r\nimport { float, isNumeric, normalizeAngle, confineNumber, PI } from \"../utils/number\";\r\nimport { isString, trimString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\nimport { HEXToRGB, HSVToRGB } from \"./converter\";\r\nimport { stringify } from \"./stringify\";\r\n\r\nconst ctx = createElement('canvas').getContext('2d');\r\n\r\n/**\r\n * Regex.\r\n */\r\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?\\s*[\\s,]\\s*([+-]?\\d*\\.?\\d+)%?\\s*,?\\s*([+-]?\\d*\\.?\\d+)%?(?:\\s*[\\/,]\\s*([+-]?\\d*\\.?\\d+)(%)?)?\\s*\\)?$/;\r\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\r\n\r\nconst ANGLE_COEFFICIENT_MAP = {\r\n    deg: 1,\r\n    turn: 360,\r\n    rad: 180 / PI,\r\n    grad: 0.9\r\n}\r\n\r\n/**\r\n * Parses any value into an RGB or HSL objects.\r\n * Invalid color values default to #000.\r\n *\r\n * @param {unknown} value - A value to parse.\r\n * @param {boolean} asString - Whether to return the result as a string or object.\r\n * @returns {object|string} - Parsed color as string or object.\r\n */\r\nexport const parseColor = (value = '', asString) => {\r\n\r\n    let color;\r\n    let format;\r\n    let str = '';\r\n\r\n    /**\r\n     * Validate Non string values, convert color objects into strings.\r\n     * Invalid values default to empty string.\r\n     */\r\n    if (! isString(value)) {\r\n\r\n        format = [RGB_FORMAT, HSL_FORMAT, HSV_FORMAT].find(format => {\r\n\t\t\treturn format.split('').every(key => {\r\n\t\t\t\treturn isNumeric(float(value[key]));\r\n\t\t\t});\r\n\t\t});\r\n\r\n        if (format) {\r\n            if (! isset(value.a)) {\r\n                value.a = 1;\r\n            }\r\n\r\n            if (format === HSV_FORMAT) {\r\n                format = RGB_FORMAT;\r\n                value = HSVToRGB({\r\n                    h: normalizeAngle(value.h),\r\n                    s: confineNumber(value.s) / 100,\r\n                    v: confineNumber(value.v) / 100,\r\n                    a: value.a\r\n                });\r\n            }\r\n\r\n            str = stringify(value, format);\r\n        }\r\n    } else {\r\n        str = trimString(value);\r\n    }\r\n\r\n    /**\r\n     * Parse strings\r\n     */\r\n    let [input, h, angle, s, l, a, percentage] = HSL_REGEX.exec(str) || [];\r\n\r\n    // str is a hsl string.\r\n    if (input) {\r\n        /**\r\n         * Normalize values.\r\n         *\r\n         * The hue value is so often given in degrees, it can be given as a number, however\r\n         * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradians),\r\n         * If the hue has a unit other than deg, then convert it to degrees.\r\n         */\r\n        color = {\r\n            h: normalizeAngle(h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),\r\n            s: confineNumber(s),\r\n            l: confineNumber(l),\r\n            a: isset(a) ? confineNumber(percentage ? a / 100 : a, 1) : 1\r\n        }\r\n        format = HSL_FORMAT;\r\n    } else {\r\n        format = RGB_FORMAT;\r\n\r\n        ctx.fillStyle = '#000';\r\n        ctx.fillStyle = str;\r\n        str = ctx.fillStyle;\r\n        // ColorString is either hex or rgb string,\r\n        // if it's hex convert it to rgb object,\r\n        // if it's rgb then parse it to object.\r\n        if (HEX_REGEX.test(str)) {\r\n            color = HEXToRGB(str);\r\n        } else {\r\n            let [r, g, b, a] = /\\((.+)\\)/.exec(str)[1].split(',').map(value => float(value));\r\n            color = { r, g, b, a };\r\n        }\r\n    }\r\n\r\n    return asString ? stringify(color, format) : { _format: format, _color: color }\r\n}","import { ALWAN_CLASSNAME, CONTAINER_CLASSNAME } from \"../constants/classnames\";\r\nimport { App } from \"../components/App\";\r\nimport { Inputs } from \"../components/Inputs\";\r\nimport { Palette } from \"../components/Palette\";\r\nimport { Sliders } from \"../components/Sliders\";\r\nimport { Swatches } from \"../components/Swatches\";\r\nimport { Utility } from \"../components/Utility\";\r\nimport { body, createElement } from \"../utils/dom\";\r\nimport { Binder } from \"./events/binder\";\r\n\r\n/**\r\n * Shared Components.\r\n */\r\nlet sharedComponents = null;\r\n\r\n/**\r\n * Number of instances that uses the shared components.\r\n */\r\nlet instanceCount = 0;\r\n\r\n/**\r\n * Creates components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} alwan components.\r\n */\r\nconst createComponents = (alwan) => {\r\n    const events = Binder();\r\n    const root = createElement('', ALWAN_CLASSNAME, body());\r\n\r\n    const _app = App(root, alwan, events);\r\n    const _palette = Palette(root, alwan, events);\r\n    const container = createElement('', CONTAINER_CLASSNAME, root);\r\n    const _utility = Utility(container, alwan, events);\r\n    const _sliders = Sliders(container, alwan, events);\r\n    const _inputs = Inputs(createElement('', CONTAINER_CLASSNAME, root), alwan, events);\r\n    const _swatches = Swatches(root, alwan, events);\r\n\r\n    return {\r\n        _app,\r\n        _palette,\r\n        _utility,\r\n        _sliders,\r\n        _inputs,\r\n        _swatches\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if components are shared.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {boolean} - True if components are shared.\r\n */\r\nexport const isShared = (components) => {\r\n    return !!sharedComponents && components === sharedComponents;\r\n}\r\n\r\n/**\r\n * Destroys components.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {void}\r\n */\r\nexport const destroyComponents = (components) => {\r\n    if (isShared(components)) {\r\n        instanceCount--;\r\n        if (instanceCount > 0) {\r\n            return;\r\n        }\r\n        sharedComponents = null;\r\n    }\r\n\r\n    components._app._destroy();\r\n    components = {};\r\n}\r\n\r\n/**\r\n * Gets components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} components.\r\n */\r\nexport const useComponents = (alwan) => {\r\n    let { _components, config: { shared }} = alwan;\r\n\r\n    // Alwan already has components.\r\n    if (_components) {\r\n        // Nothing is changing, if components are shared and the option shared is true,\r\n        // or the components are not shared and the option shared is false\r\n        // then just return the current compoenents.\r\n        if ((isShared(_components)) === shared) {\r\n            return _components;\r\n        }\r\n\r\n        // Force close the picker before destroying its components.\r\n        _components._app._toggle(alwan, false, true);\r\n        // If something changed, either the components were shared,\r\n        // and the option shared is false which means set the components as,\r\n        // non-shared or the coponents were non-shared and we want to share them.\r\n        // in either cases we need to destroy the current components.\r\n        destroyComponents(_components);\r\n    }\r\n\r\n    if (shared) {\r\n        // Create components and set them to sharedComponents.\r\n        if (! sharedComponents) {\r\n            sharedComponents = createComponents(alwan);\r\n        }\r\n        // Increase the instances that uses this shared components.\r\n        instanceCount++;\r\n\r\n        return sharedComponents;\r\n    }\r\n\r\n    // Create components.\r\n    return createComponents(alwan);\r\n}","import { MARKER_CLASSNAME, OVERLAY_CLASSNAME, PALETTE_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, COLOR, KEY_DOWN, POINTER_DOWN, POINTER_MOVE, POINTER_UP, ROOT } from \"../constants/globals\";\r\nimport { createElement, getBounds, translate, removeElement } from \"../utils/dom\"\r\nimport { confineNumber } from \"../utils/number\";\r\n\r\n/**\r\n * Picker palette.\r\n *\r\n * @param {Element} root - Root element to append the palette elements to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object}\r\n */\r\nexport const Palette = (root, alwan, events) => {\r\n    /**\r\n     * Marker X coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerX;\r\n\r\n    /**\r\n     * Marker Y coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerY;\r\n\r\n    /**\r\n     * Palette element bounds.\r\n     *\r\n     * @type {DOMRect}\r\n     */\r\n    let paletteBounds;\r\n\r\n    /**\r\n     * A transparent element cover the whole document.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let overlayElement;\r\n\r\n    /**\r\n     * Indicates whether a pointer (mouse, pen or touch) is down.\r\n     */\r\n    let isPointerDown = false;\r\n\r\n    /**\r\n     * Palette element.\r\n     */\r\n    const palette = createElement('', PALETTE_CLASSNAME, root, { tabindex: '0' });\r\n\r\n    /**\r\n     * Palette marker.\r\n     */\r\n    const marker = createElement('', MARKER_CLASSNAME, palette);\r\n\r\n    /**\r\n     * Palette element dimension.\r\n     */\r\n    const { width, height } = getBounds(palette);\r\n\r\n    /**\r\n     * Move marker horizontally using the keyboard arrow keys.\r\n     */\r\n    const keyboardX = {\r\n        ArrowRight: 1,\r\n        ArrowLeft: -1\r\n    };\r\n\r\n    /**\r\n     * Move marker vertically using the keyboard arrow keys\r\n     */\r\n    const keyboardY = {\r\n        ArrowDown: 1,\r\n        ArrowUp: -1\r\n    };\r\n\r\n    /**\r\n     * Move marker and update color state.\r\n     *\r\n     * @param {number} x - X coordinate.\r\n     * @param {number} y - Y coordinate.\r\n     * @param {Function} change - Callback function if color changed.\r\n     */\r\n    const moveMarkerAndUpdateColor = (x, y, change) => {\r\n\r\n        x = confineNumber(x, width);\r\n        y = confineNumber(y, height);\r\n\r\n        if (x !== markerX || y !== markerY) {\r\n            markerX = x;\r\n            markerY = y;\r\n            translate(marker, markerX, markerY);\r\n            alwan._color._update({ s: markerX / width, v: (1 - markerY / height)});\r\n            alwan._events._dispatch(COLOR, palette);\r\n\r\n            if (change) {\r\n                change();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragStart = e => {\r\n        if (! overlayElement) {\r\n            overlayElement = createElement('', OVERLAY_CLASSNAME, root);\r\n        }\r\n        // Save color state.\r\n        alwan._color._saveState();\r\n        paletteBounds = getBounds(palette);\r\n        isPointerDown = true;\r\n        moveMarkerAndUpdateColor(e.clientX - paletteBounds.x, e.clientY - paletteBounds.y);\r\n        palette.focus();\r\n    }\r\n\r\n    /**\r\n     * Dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const drag = e => {\r\n        if (isPointerDown) {\r\n            moveMarkerAndUpdateColor(e.clientX - paletteBounds.x, e.clientY - paletteBounds.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag end (released the marker).\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragEnd = e => {\r\n        if (isPointerDown) {\r\n            alwan._color._triggerChange(palette);\r\n            overlayElement = removeElement(overlayElement);\r\n            isPointerDown = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves marker using keyboard arrow keys and adds focus-visible to the palette.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleKeyboard = e => {\r\n        let key = e.key;\r\n\r\n        if (keyboardX[key] || keyboardY[key]) {\r\n            e.preventDefault();\r\n\r\n            moveMarkerAndUpdateColor(\r\n                markerX + (keyboardX[key] || 0) * width / 100,\r\n                markerY + (keyboardY[key] || 0) * height / 100,\r\n                () => {\r\n                    alwan._events._dispatch(CHANGE, palette);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(palette, POINTER_DOWN, dragStart);\r\n    events._bind(ROOT, POINTER_MOVE, drag);\r\n    events._bind(ROOT, POINTER_UP, dragEnd);\r\n    events._bind(palette, KEY_DOWN, handleKeyboard);\r\n\r\n\r\n    return {\r\n        _element: palette,\r\n\r\n        /**\r\n         * Initialize component.\r\n         *\r\n         * @param {object} options - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init(_options, instance) {\r\n            alwan = instance || alwan;\r\n        },\r\n\r\n        /**\r\n         * Updates marker position from an hsv color object.\r\n         *\r\n         * @param {object} param0 - HSV color object.\r\n         */\r\n        _update({ s, v }) {\r\n            translate(marker, s * width, (1 - v) * height);\r\n        }\r\n    }\r\n}","import { checkSVG, clipboardSVG } from \"../assets/svg\";\r\nimport { COPY_BUTTON_CLASSNAME, PREVIEW_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK, COLOR_PROPERTY, FOCUS_OUT, HTML, INPUT, INSERT_BEFORE_FIRST_CHILD, MOUSE_OUT, ROOT } from \"../constants/globals\";\r\nimport { createButton, createElement, insertElement, removeElement, setCustomProperty, setHTML } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates utility component.\r\n *\r\n * @param {Element} parent - Container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @param {object} events - Event binder.\r\n * @returns {object} Utility component.\r\n */\r\nexport const Utility = (parent, alwan, events) => {\r\n    /**\r\n     * Preview color.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let previewElement;\r\n\r\n    /**\r\n     * Copy button.\r\n     *\r\n     * @type {HTMLButtonElement}\r\n     */\r\n    let copyButton;\r\n\r\n    /**\r\n     * Indicate whether color is copied.\r\n     */\r\n    let isCopied;\r\n\r\n    /**\r\n     * API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize utility component.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ preview, copy }, instance) {\r\n            alwan = instance;\r\n            if (copy !== !! copyButton) {\r\n                if (copy) {\r\n                    copyButton = createButton(COPY_BUTTON_CLASSNAME, previewElement || parent, { html: clipboardSVG }, INSERT_BEFORE_FIRST_CHILD);\r\n                } else {\r\n                    copyButton = removeElement(copyButton);\r\n                }\r\n            }\r\n\r\n            if (preview !== !! previewElement) {\r\n                if (preview) {\r\n                    previewElement = createElement('', PREVIEW_CLASSNAME, parent, false, INSERT_BEFORE_FIRST_CHILD);\r\n                } else {\r\n                    previewElement = removeElement(previewElement);\r\n                }\r\n\r\n                insertElement(copyButton, previewElement || parent, INSERT_BEFORE_FIRST_CHILD);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies the selected color to the clipboard.\r\n     *\r\n     * @param {MouseEvent} e - Event.\r\n     */\r\n    const copyColor = ({ target }) => {\r\n        if (target === copyButton && ! isCopied && ! alwan.config.disabled) {\r\n\r\n            let clipboard = navigator.clipboard;\r\n            let color = alwan._color._getColorByFormat(true);\r\n            let input;\r\n\r\n            if (clipboard) {\r\n                clipboard.writeText(color);\r\n            } else {\r\n                input = createElement(INPUT, '', HTML, { value: color });\r\n                input.select();\r\n                ROOT.execCommand('copy');\r\n                input = removeElement(input);\r\n            }\r\n            // change icon.\r\n            isCopied = true;\r\n            setHTML(copyButton, checkSVG);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Updates the svg icon of the button.\r\n     *\r\n     * @param {MouseEvent|FocusEvent} e - Event.\r\n     */\r\n    const updateButtonIcon = e => {\r\n        if (e.target === copyButton) {\r\n            // If the color is copied (that means the copy button has changed its icon),\r\n            // and the button has lost focus or mouse left it, then set the icon back,\r\n            // to the clipboard svg.\r\n            if (isCopied) {\r\n                isCopied = false;\r\n                setHTML(copyButton, clipboardSVG);\r\n            }\r\n            copyButton.blur();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(parent, CLICK, copyColor);\r\n    events._bind(parent, [MOUSE_OUT, FOCUS_OUT], updateButtonIcon);\r\n\r\n    return self;\r\n}","import { ALPHA_SLIDER_CLASSNAME, HUE_SLIDER_CLASSNAME, SLIDERS_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, COLOR, COLOR_PROPERTY, INPUT } from \"../constants/globals\";\r\nimport { createElement, createSlider, removeElement, setCustomProperty } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates sliders component.\r\n *\r\n * @param {Element} parent - Element to append sliders to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} Sliders component.\r\n */\r\nexport const Sliders = (parent, alwan, events) => {\r\n    /**\r\n     * Alpha slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    let alphaSlider;\r\n\r\n    /**\r\n     * Sliders container.\r\n     */\r\n    const container = createElement('', SLIDERS_CLASSNAME, parent);\r\n\r\n    /**\r\n     * Hue slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, container, 360);\r\n\r\n    /**\r\n     * Updates color.\r\n     *\r\n     * @param {InputEvent} param0 - Event.\r\n     */\r\n    const handleChange = ({ target, type, target: { value } }) => {\r\n        alwan._color._update(target === hueSlider ? { h: 360 - value } : { a: value * 1 });\r\n        alwan._events._dispatch(type === CHANGE ? CHANGE : COLOR, target);\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(container, [INPUT, CHANGE], handleChange);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize sliders.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ opacity }, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            if (opacity !== !! alphaSlider) {\r\n                if (opacity) {\r\n                    alphaSlider = createSlider(ALPHA_SLIDER_CLASSNAME, container, 1, 0.01);\r\n                } else {\r\n                    alphaSlider = removeElement(alphaSlider);\r\n                    alwan._color._update({ a: 1 });\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets sliders values.\r\n         *\r\n         * @param {object} param0 - HSV color object.\r\n         */\r\n        _setValue({ h, a }) {\r\n            hueSlider.value = 360 - h;\r\n            if (alphaSlider) {\r\n                alphaSlider.value = a;\r\n            }\r\n        }\r\n    };\r\n}","import { switchInputsSVG } from \"../assets/svg\";\r\nimport { INPUTS_CLASSNAME, INPUT_CLASSNAME } from \"../constants/classnames\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, CLICK, COLOR, COLOR_FORMATS, ENTER, FOCUS_IN, HEX_FORMAT, INPUT, KEY_DOWN} from \"../constants/globals\";\r\nimport { createButton, createElement, removeElement, setHTML, toggleVisibility } from \"../utils/dom\";\r\nimport { max } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { isString, trimString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n\r\n/**\r\n * Creates Inputs component.\r\n *\r\n * @param {Element} container - Element to append the inputs container element to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} - Inputs component.\r\n */\r\nexport const Inputs = (container, alwan, events) => {\r\n\r\n    /**\r\n     * Inputs wrapper element.\r\n     */\r\n    let inputsContainer;\r\n\r\n    /**\r\n     * Switch button.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let switchButton;\r\n\r\n    /**\r\n     * Picker formats.\r\n     */\r\n    let formats = [];\r\n\r\n    /**\r\n     * Index of the current format.\r\n     */\r\n    let formatIndex;\r\n\r\n    /**\r\n     * Object that maps fields label to their inputs.\r\n     *\r\n     * @type {object}\r\n     */\r\n    let inputsMap;\r\n\r\n    /**\r\n     * Indicates that an input value has changed.\r\n     */\r\n    let isChanged = false;\r\n\r\n    /**\r\n     * Component API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize Inputs.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ inputs, format }, instance) {\r\n\r\n            alwan = instance || alwan;\r\n            inputs = isset(inputs) ? inputs : {};\r\n            inputsMap = {};\r\n\r\n            // Get only valid formats.\r\n            formats = COLOR_FORMATS.filter(format => inputs[format]);\r\n            let length = formats.length;\r\n\r\n            if (! length) {\r\n                // No inputs, remove inputs container and the switch button.\r\n                inputsContainer = removeElement(inputsContainer);\r\n                switchButton = removeElement(switchButton);\r\n                // Normalize format value.\r\n                format = COLOR_FORMATS.includes(format) ? format : COLOR_FORMATS[0];\r\n            } else {\r\n\r\n                // Create inputs container.\r\n                if (! inputsContainer) {\r\n                    inputsContainer = createElement('', INPUTS_CLASSNAME, container);\r\n                }\r\n\r\n                if (length === 1) {\r\n                    switchButton = removeElement(switchButton);\r\n                } else if (!switchButton) {\r\n                    // For more than one input format, add a switch button.\r\n                    switchButton = createButton('', container, { html: switchInputsSVG });\r\n                }\r\n\r\n                // Validate and normalize format value.\r\n                formatIndex = max(formats.indexOf(format), 0);\r\n                format = formats[formatIndex];\r\n                build(format);\r\n            }\r\n\r\n            alwan.config.format = format;\r\n            // Show/Hide parent container.\r\n            toggleVisibility(container, length);\r\n        },\r\n\r\n        /**\r\n         * Updates Input(s) value(s).\r\n         *\r\n         * @param {Object} color - Color object.\r\n         */\r\n        _setValue(color) {\r\n            objectIterator(inputsMap, (input, key) => {\r\n                input.value = isString(color) ? color : color[key];\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds inputs.\r\n     *\r\n     * @param {string} format - Color format.\r\n     */\r\n    const build = (format) => {\r\n        let { singleInput, opacity } = alwan.config;\r\n        let fields;\r\n        // Each letter in the format variable represent a color channel,\r\n        // For multiple inputs, each color channel has an input field.\r\n        // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\r\n        if (singleInput || format === HEX_FORMAT) {\r\n            fields = [format];\r\n        } else {\r\n            fields = (format + (opacity ? 'a' : '')).split('');\r\n        }\r\n\r\n        // Empty the container from any inputs.\r\n        setHTML(inputsContainer, '');\r\n\r\n        fields.forEach(field => {\r\n            /**\r\n             * Create Input.\r\n             *\r\n             * <label>\r\n             *     <input type=\"text|number\" class=\"alwan__input\">\r\n             *     <span>${field}</span>\r\n             * </label>\r\n             */\r\n            const labelElement = createElement('label', '', inputsContainer);\r\n            inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, labelElement, { type: 'text' });\r\n            createElement('span', '', labelElement, { html: field });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles changes in inputs.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target: { value }}) => {\r\n\r\n        if (! isChanged) {\r\n            alwan._color._saveState();\r\n            isChanged = true;\r\n        }\r\n\r\n        let str = '';\r\n        let color = {};\r\n        let format = formats[formatIndex];\r\n\r\n        if (alwan.config.singleInput || format === HEX_FORMAT) {\r\n            str = value;\r\n        } else {\r\n            // Copy inputs values into an object (rgb or hsl).\r\n            objectIterator(inputsMap, (input, key) => {\r\n                color[key] = trimString(input.value);\r\n            });\r\n            // Convert the object into string.\r\n            str = stringify(color, format);\r\n        }\r\n\r\n        if (alwan._color._set(str, true)) {\r\n            alwan._events._dispatch(COLOR, inputsMap);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles when an input loses focus after its value was changed.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChangeStop = e => {\r\n        if (isChanged) {\r\n            alwan._color._triggerChange(inputsMap);\r\n            isChanged = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes color format.\r\n     *\r\n     * @param {MouseEvent} e - Click event.\r\n     */\r\n    const changeFormat = e => {\r\n        if (e.target === switchButton) {\r\n            // Increment input format index, reset it if it reaches the end.\r\n            // this index will point to the next format.\r\n            formatIndex = (formatIndex + 1) % formats.length;\r\n            alwan.config.format = formats[formatIndex];\r\n            build(formats[formatIndex]);\r\n            // Update values.\r\n            alwan._color._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select input value when focus in, and close the picker when pressing Enter key.\r\n     *\r\n     * @param {FocusEvent|KeyboardEvent} e - Event.\r\n     */\r\n    const selectOrClose = ({ target, key, type }) => {\r\n        if (target !== switchButton) {\r\n            if (type === FOCUS_IN) {\r\n                target.select();\r\n            } else if (key === ENTER) {\r\n                alwan.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(container, CLICK, changeFormat);\r\n    events._bind(container, INPUT, handleChange);\r\n    events._bind(container, CHANGE, handleChangeStop);\r\n    events._bind(container, [KEY_DOWN, FOCUS_IN], selectOrClose);\r\n\r\n\r\n    return self;\r\n}","import { caretSVG } from \"../assets/svg\";\r\nimport { COLLAPSE_BUTTON_CLASSNAME, COLLAPSE_CLASSNAME, SWATCHES_CLASSNAME, SWATCH_CLASSNAME } from \"../constants/classnames\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { CHANGE, CLICK, COLOR, COLOR_PROPERTY } from \"../constants/globals\";\r\nimport { createButton, createElement, parent, removeElement, setCustomProperty, setHTML, toggleClassName } from \"../utils/dom\";\r\nimport { int } from \"../utils/number\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates swatches component.\r\n *\r\n * @param {Element} root - Element to append the palette element to.\r\n * @param {object} alwan - Picker Instance.\r\n * @param {object} events - Event binder.\r\n * @returns {object} - Swatches component.\r\n */\r\nexport const Swatches = (root, alwan, events) => {\r\n\r\n    /**\r\n     * Swatches container.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Swatches array.\r\n     *\r\n     * @type {array<string>}\r\n     */\r\n    let swatches;\r\n\r\n    /**\r\n     * Button.\r\n     *\r\n     * @type {HTMLButtonElement}\r\n     */\r\n    let collapseButton;\r\n\r\n    /**\r\n     * Swatches array length.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let swatchesLength;\r\n\r\n    /**\r\n     * Indicate whether swatches container is collapsible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    let isCollapsible\r\n\r\n    /**\r\n     * Swatches API.\r\n     */\r\n    const self = {\r\n        /**\r\n         * Initialize swatches.\r\n         *\r\n         * @param {Object} options - Alwan options.\r\n         */\r\n        _init(options = {}, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            swatches = options.swatches || swatches;\r\n            isCollapsible = options.toggleSwatches;\r\n            isCollapsible = isset(isCollapsible) ? isCollapsible : false;\r\n\r\n            if (Array.isArray(swatches)) {\r\n\r\n                swatchesLength = swatches.length;\r\n\r\n                if (swatchesLength) {\r\n                    // Create swatches container.\r\n                    if (! container) {\r\n                        container = createElement('', SWATCHES_CLASSNAME, root);\r\n                    } else {\r\n                        // Initialize container.\r\n                        setHTML(container, '');\r\n                    }\r\n\r\n                    // Create swatch button.\r\n                    swatches.forEach(color => {\r\n                        setCustomProperty(\r\n                            createButton(SWATCH_CLASSNAME, container),\r\n                            COLOR_PROPERTY,\r\n                            parseColor(color, true)\r\n                        );\r\n                    });\r\n\r\n                    // Create or remove the collapse button depend if the toggleSwatches,\r\n                    // option changes.\r\n                    if (isCollapsible) {\r\n                        if (! collapseButton) {\r\n                            collapseButton = createButton(COLLAPSE_BUTTON_CLASSNAME, root, { html: caretSVG });\r\n                        }\r\n                    } else {\r\n                        collapseButton = removeElement(collapseButton);\r\n                    }\r\n                    toggleClassName(container, COLLAPSE_CLASSNAME, isCollapsible);\r\n                } else {\r\n                    // Remove everything if the swatches array is empty.\r\n                    container = removeElement(container);\r\n                    collapseButton = removeElement(collapseButton);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Adds a swatch button.\r\n         *\r\n         * @param {String|object} color - Color.\r\n         */\r\n        _add(color) {\r\n            swatchesLength = swatches.push(color);\r\n            if (swatchesLength > 1) {\r\n                setCustomProperty(\r\n                    createButton(SWATCH_CLASSNAME, container),\r\n                    COLOR_PROPERTY,\r\n                    parseColor(color, true)\r\n                );\r\n            } else {\r\n                // Initialize component, if calling add swatches on an empty array.\r\n                self._init();\r\n            }\r\n        },\r\n        /**\r\n         * Removes a swatch button.\r\n         *\r\n         * @param {String|Number} swatch - Color or Swatch Index.\r\n         */\r\n        _remove(swatch) {\r\n            let index = swatches.findIndex((color, index) => swatch === color || int(swatch) === index);\r\n\r\n            if (index > -1) {\r\n                swatchesLength--;\r\n                // Remove swatch button.\r\n                removeElement(container.children[index]);\r\n                // Remove color from swatches array.\r\n                swatches.splice(index, 1);\r\n\r\n                if (! swatchesLength) {\r\n                    // Initialize component, if calling remove swatches on an array that,\r\n                    // has only one value.\r\n                    self._init();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Handles clicks in the swatches container or the collapse button.\r\n     *\r\n     * @param {MouseEvent} e - Event.\r\n     */\r\n    const handleClick = ({ target }) => {\r\n        if (target === collapseButton) {\r\n            toggleClassName(container, COLLAPSE_CLASSNAME);\r\n        }else if(parent(target) === container) {\r\n            alwan._color._set(target.style.getPropertyValue(COLOR_PROPERTY));\r\n            alwan._events._dispatch(COLOR, target);\r\n            alwan._events._dispatch(CHANGE, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    events._bind(root, CLICK, handleClick);\r\n\r\n\r\n    return self;\r\n}","import { HSLToHSV, HSVToHSL, HSVToRGB, RGBToHEX, RGBToHSV } from \"../colors/converter\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, COLOR_PROPERTY, HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { setCustomProperty } from \"../utils/dom\";\r\nimport { isEqual, merge } from \"../utils/object\";\r\n\r\n/**\r\n * Creates the core color state and UI updater.\r\n *\r\n * @param {object} alwan - Alwan instance.\r\n * @returns {object} Core color state.\r\n */\r\nexport const color = (alwan) => {\r\n    /**\r\n     * HSV color object.\r\n     */\r\n    let HSV = {\r\n        h: 0,\r\n        s: 0,\r\n        v: 0,\r\n        a: 1\r\n    };\r\n\r\n    /**\r\n     * RGB color object.\r\n     *\r\n     * @type {object}\r\n     */\r\n    let RGB;\r\n\r\n    /**\r\n     * RGB color string.\r\n     *\r\n     * @type {string}\r\n     */\r\n    let rgbString;\r\n\r\n    /**\r\n     * Color state.\r\n     *\r\n     * @type{object}\r\n     */\r\n    let state;\r\n\r\n    /**\r\n     * Alwan options.\r\n     */\r\n    let config = alwan.config;\r\n\r\n    /**\r\n     * Gets color data.\r\n     *\r\n     * @param {object} color - Color object.\r\n     * @param {string} format - Color format.\r\n     * @param {boolean} asArray - Gets data as an array.\r\n     * @param {string} str - Color string.\r\n     * @returns {object} - Color data.\r\n     */\r\n    let colorData = (color, format, asArray, str) => {\r\n        return merge(\r\n            (format + (config.opacity ? 'a' : '')).split('').reduce((output, channel, index) => {\r\n                output[asArray ? index : channel] = color[channel];\r\n                return output;\r\n            }, asArray ? [] : {}),\r\n\r\n            format !== HSV_FORMAT ? { toString: () => str || stringify(color, format) } : {}\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Color api.\r\n     */\r\n    let self = {\r\n        /**\r\n         * Updates core color, css custom properties and inputs values.\r\n         *\r\n         * @param {object} hsv - HSV color object.\r\n         * @param {object|undefined} rgb - RGB color object.\r\n         * @param {boolean} isInputs - If true don't set inputs values.\r\n         */\r\n        _update(hsv, rgb, isInputs) {\r\n\r\n            let { _app: { _root }, _inputs } = alwan._components;\r\n\r\n            if (! config.disabled) {\r\n                hsv = hsv || HSV;\r\n                merge(HSV, hsv);\r\n\r\n                RGB = rgb || HSVToRGB(HSV);\r\n                rgbString = stringify(RGB, RGB_FORMAT);\r\n\r\n                // Update UI.\r\n                setCustomProperty(alwan._reference._element, COLOR_PROPERTY, rgbString);\r\n                setCustomProperty(_root, '--h', hsv.h);\r\n                setCustomProperty(_root, '--rgb', stringify(RGB, RGB_FORMAT, true));\r\n                setCustomProperty(_root, COLOR_PROPERTY, rgbString);\r\n\r\n                if (! isInputs) {\r\n                    _inputs._setValue(self._getColorByFormat(config.singleInput));\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Same as update method plus it updates palette's marker position,\r\n         * and sliders values.\r\n         *\r\n         * @param {object} hsv - HSV color object.\r\n         * @param {object|undefined} rgb - RGB color object.\r\n         * @param {boolean} isInputs - If true don't set inputs values.\r\n         */\r\n        _updateAll(hsv, rgb, isInputs) {\r\n            let { _palette, _sliders } = alwan._components;\r\n            self._update(hsv, rgb, isInputs);\r\n            _palette._update(HSV);\r\n            _sliders._setValue(HSV);\r\n        },\r\n\r\n        /**\r\n         * Gets a color string or object by a format.\r\n         *\r\n         * @param {boolean} asString - Whether to get the color as a string.\r\n         * @param {string} format - Color format.\r\n         * @returns {object|string} - Color.\r\n         */\r\n        _getColorByFormat: (asString, format = config.format) => {\r\n    \r\n            if (format === RGB_FORMAT) {\r\n                if (asString) {\r\n                    return rgbString;\r\n                }\r\n                return RGB;\r\n            }\r\n    \r\n            if (format === HSL_FORMAT) {\r\n                if (asString) {\r\n                    return stringify(HSVToHSL(HSV), HSL_FORMAT);\r\n                }\r\n                return HSVToHSL(HSV);\r\n            }\r\n    \r\n            if (format === HEX_FORMAT) {\r\n                return RGBToHEX(RGB);\r\n            }\r\n    \r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * Save color state.\r\n         */\r\n        _saveState() {\r\n            state = self._getColorByFormat();\r\n        },\r\n\r\n        /**\r\n         * Compare the current color with the saved color, if they are different,\r\n         * then dipatch a change event.\r\n         *\r\n         * @param {Element} source - Event source.\r\n         */\r\n        _triggerChange(source) {\r\n            if (! isEqual(state, self._getColorByFormat())) {\r\n                alwan._events._dispatch(CHANGE, source);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets color.\r\n         *\r\n         * @param {string|object} color - Color value.\r\n         * @param {boolean} isInputs - Is inputs component.\r\n         * @returns {boolean} - Whether the color state is changed or not.\r\n         */\r\n        _set(color, isInputs = false) {\r\n            let { _format, _color } = parseColor(color);\r\n            let isChanged = ! isEqual(_color, self._getColorByFormat(false, _format));\r\n            let isRGB = _format === RGB_FORMAT;\r\n    \r\n            if (isChanged) {\r\n                self._updateAll(\r\n                    // Convert colors (RGB or HSL) to HSV.\r\n                    isRGB ? RGBToHSV(_color) : HSLToHSV(_color),\r\n                    // If the parsed color is RGB.\r\n                    isRGB ? _color : false,\r\n                    isInputs\r\n                );\r\n                \r\n            }\r\n    \r\n            return isChanged;\r\n        },\r\n\r\n        /**\r\n         * Gets color value.\r\n         *\r\n         * @returns {object} - Color value.\r\n         */\r\n        _value: () => ({ \r\n            value: self._getColorByFormat(true),\r\n            hsv: asArray => colorData(HSV, HSV_FORMAT, asArray),\r\n            rgb: asArray => colorData(RGB, RGB_FORMAT, asArray, rgbString),\r\n            hsl: asArray => colorData(HSVToHSL(HSV), HSL_FORMAT, asArray),\r\n            hex: () => RGBToHEX(RGB),\r\n        })\r\n    }\r\n\r\n    return self;\r\n}","import { merge } from \"../utils/object\"\r\nimport { isset } from \"../utils/util\";\r\nimport { useComponents, isShared } from \"./component\";\r\n\r\n/**\r\n * Initialize instance.\r\n *\r\n * @param {object} alwan - Instance.\r\n * @param {object} options - Alwan options.\r\n */\r\nexport const initialize = (alwan, options) => {\r\n    options = options || {};\r\n\r\n    let config = merge(alwan.config, options);\r\n    let { color, disabled } = options;\r\n    let { _set, _update } = alwan._color;\r\n    let app;\r\n\r\n    alwan._components = useComponents(alwan);\r\n    alwan._reference._init(config);\r\n    app = alwan._components._app;\r\n\r\n    if (isShared(alwan._components)) {\r\n        app._toggle(null, false);\r\n    }\r\n\r\n    app._setup(config, alwan);\r\n    alwan._reference._setDisabled(disabled);\r\n\r\n    if (isset(color)) {\r\n        _set(color);\r\n    }\r\n\r\n    // To update inputs values.\r\n    _update();\r\n}","/**\r\n * SC Picker default options.\r\n */\r\n export const defaults = {\r\n    // Set the container's (widget) id.\r\n    id: '',\r\n\r\n    // One or many classes separated by a white space,\r\n    // to add it to the preset button.\r\n    classname: '',\r\n\r\n    // Choose a theme, 'dark' or 'light'.\r\n    theme: 'light',\r\n\r\n    // Toggle picker's visibility (Show/Hide),\r\n    // Setting this to false keeps the picker visible.\r\n    toggle: true,\r\n\r\n    // Display the picker container as a pop-up (a box that floats on top of the page content),\r\n    // if it's false, picker container will be displayed as a block (embeded in the page's content).\r\n    popover: true,\r\n\r\n    // Set the position of the popper (if popover is set to true) relative to the reference element,\r\n    // the position has two values seperated by a dash (-),\r\n    // the first value is the direction (top, bottom, right, left),\r\n    // the second value is the alignment (start, center, end), omitting this value will default to center.\r\n    // e.g. 'bottom-start': 'bottom' places the picker below the reference element,\r\n    // and 'start' aligns the left side of the container with the left side of the reference element.\r\n    // Note: \r\n    // If the picker container has no space to be placed, it will auto-position itself.\r\n    // based on the available space.\r\n    position: 'bottom-start',\r\n\r\n    // Set the gap (in pixels) between the picker container and the reference element.\r\n    margin: 8,\r\n\r\n    // Replace the reference element with a pre-styled button.\r\n    preset: true,\r\n\r\n    // Initial color.\r\n    color: '#000',\r\n\r\n    // Default color.\r\n    default: '#000',\r\n\r\n    // Target can be a selector or an HTML element,\r\n    // If the option popover is true, the picker container will be positionned retalive to this element,\r\n    // instead of the reference element.\r\n    // else if popover option is false, the picker container will be appended as a child into this element.\r\n    target: '',\r\n\r\n    // Disable the picker, users won't be able to pick colors.\r\n    disabled: false,\r\n\r\n    // Initial color format.\r\n    format: 'rgb',\r\n\r\n    // For the formats 'hsl' and 'rgb', choose a single input to display the color string,\r\n    // or if false, display an input for each color channel.\r\n    singleInput: false,\r\n\r\n    // Choose color formats for the picker input, 'hsl', 'rgb' or 'hex',\r\n    // No input will be displayed if the array is empty.\r\n    inputs: {\r\n        rgb: true,\r\n        hex: true,\r\n        hsl: true,\r\n    },\r\n\r\n    // Support alpha channel and display opacity slider.\r\n    opacity: true,\r\n\r\n    // Preview the color.\r\n    preview: true,\r\n\r\n    // Add/Remove a copy button.\r\n    copy: true,\r\n\r\n    // Array of color strings, invalid color strings will default to rgb(0,0,0).\r\n    swatches: [],\r\n\r\n    /**\r\n     * Share components with multiple alwan instances.\r\n     */\r\n    shared: false,\r\n\r\n    /**\r\n     * Make swatches container collapsible.\r\n     */\r\n    toggleSwatches: false,\r\n}","import { Reference } from \"./components/reference\";\r\nimport { merge, objectIterator, prototype, setPrototypeOf } from \"./utils/object\";\r\nimport { destroyComponents } from \"./core/component\";\r\nimport { color } from \"./core/color\";\r\nimport { Dispatcher } from \"./core/events/dispatcher\";\r\nimport { initialize } from \"./core/init\";\r\nimport \"./assets/scss/alwan.scss\";\r\nimport { defaults } from \"./constants/defaults\";\r\n\r\n\r\nexport default class Alwan {\r\n\r\n    static version = VERSION;\r\n\r\n    /**\r\n     * Alwan defaults.\r\n     */\r\n    static defaults = defaults;\r\n\r\n    /**\r\n     * Alwan instance constructor.\r\n     *\r\n     * @param {String|Element} reference - The reference element.\r\n     * @param {Object} options - Options.\r\n     */\r\n    constructor(reference, options) {\r\n        let alwan = this;\r\n\r\n        alwan.config = merge({}, Alwan.defaults);\r\n        alwan._events = Dispatcher(alwan);\r\n        alwan._color = color(alwan);\r\n        alwan._reference = Reference(reference, alwan);\r\n        initialize(alwan, options);\r\n    }\r\n\r\n    /**\r\n     * Sets new options.\r\n     *\r\n     * @param {Object} options - Alwan options.\r\n     */\r\n    setOptions(options) {\r\n        initialize(this, options);\r\n    }\r\n\r\n    /**\r\n     * Gets the state of the picker whether it's opened or closed.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isOpen() {\r\n        return this._components._app._isOpen();\r\n    }\r\n\r\n    /**\r\n     * Opens the picker.\r\n     */\r\n    open() {\r\n        this._components._app._toggle(this, true);\r\n    }\r\n\r\n    /**\r\n     * Closes the picker.\r\n     */\r\n    close() {\r\n        this._components._app._toggle(this, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles (opens/closes) the picker.\r\n     */\r\n    toggle() {\r\n        this._components._app._toggle(this);\r\n    }\r\n\r\n    /**\r\n     * Attaches an event handler function for an event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    on(type, handler) {\r\n        this._events._addListener(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Detaches one or more event handlers.\r\n     *\r\n     * Note:\r\n     * omitting handler, remove all handlers from the event,\r\n     * omitting both event type and handler, remove all handlers that are,\r\n     * attached to all events.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    off(type, handler) {\r\n        this._events._removeListeners(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Sets a color.\r\n     *\r\n     * @param {String|Object} color - Color.\r\n     */\r\n    setColor(color) {\r\n        this._color._set(color);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets color.\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getColor() {\r\n        return this._color._value();\r\n    }\r\n\r\n    /**\r\n     * Adds a swatch.\r\n     *\r\n     * @param {String} color - Color.\r\n     */\r\n    addSwatch(color) {\r\n        this._components._swatches._add(color);\r\n    }\r\n\r\n    /**\r\n     * Removes a swatch.\r\n     *\r\n     * @param {String|Number} swatch - Can a color string or it's index in the swatches array.\r\n     */\r\n    removeSwatch(swatch) {\r\n        this._components._swatches._remove(swatch);\r\n    }\r\n\r\n    /**\r\n     * Enables picker.\r\n     */\r\n    enable() {\r\n        this._reference._setDisabled(false);\r\n    }\r\n\r\n    /**\r\n     * Disables picker.\r\n     */\r\n    disable() {\r\n        this._reference._setDisabled(true);\r\n    }\r\n\r\n    /**\r\n     * Resets to default color.\r\n     */\r\n    reset() {\r\n        this._color._set(this.config.default);\r\n    }\r\n\r\n    /**\r\n     * Repositions picker if it's displayed as a popover.\r\n     */\r\n    reposition() {\r\n        this._components._app._reposition();\r\n    }\r\n\r\n    /**\r\n     * Executes all handlers attached to the specified event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     */\r\n    trigger(type) {\r\n        this._events._dispatch(type);\r\n    }\r\n\r\n    /**\r\n     * Destroy picker and free up memory.\r\n     */\r\n    destroy() {\r\n        let alwan = this;\r\n\r\n        alwan._reference._destroy();\r\n        destroyComponents(alwan._components);\r\n\r\n        // Remove all properties of this instance.\r\n        objectIterator(alwan, (value, key) => {\r\n            delete alwan[key];\r\n        });\r\n\r\n        // Empty instance prototype.\r\n        setPrototypeOf(alwan, prototype);\r\n    }\r\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants/globals\"\r\nimport { merge, objectIterator } from \"../../utils/object\";\r\nimport { isset } from \"../../utils/util\";\r\n\r\n/**\r\n * Alwan events.\r\n *\r\n * @param {Alwan} alwan - Alwan Instance.\r\n * @returns \r\n */\r\nexport const Dispatcher = (alwan) => {\r\n    /**\r\n     * Alwan event listeners.\r\n     */\r\n    const listeners = {\r\n        [OPEN]: [],\r\n        [CLOSE]: [],\r\n        [CHANGE]: [],\r\n        [COLOR]: []\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Dispatch an event.\r\n         *\r\n         * @param {string} type - Event type.\r\n         * @param {object} ev - Event object.\r\n         */\r\n        _dispatch(type, source) {\r\n            if (! alwan.config.disabled) {\r\n                (listeners[type] || []).forEach(handler => {\r\n                    handler(merge({ type, source }, alwan._color._value()));\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Add an event listener.\r\n         *\r\n         * @param {string} eventType - Event type.\r\n         * @param {CallableFunction} eventHandler - Event handler to registered.\r\n         */\r\n        _addListener(eventType, eventHandler) {\r\n            if (listeners[eventType] && ! listeners[eventType].includes(eventHandler)) {\r\n                listeners[eventType].push(eventHandler);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove event listener(s).\r\n         *\r\n         * @param {string} type - Event type.\r\n         * @param {CallableFunction} handlerToRemove - Event handler to remove.\r\n         */\r\n        _removeListeners(eventType, handlerToRemove) {\r\n\r\n            let handlers = eventType && listeners[eventType];\r\n\r\n            if (isset(eventType)) {\r\n                if (handlers) {\r\n                    if (isset(handlerToRemove)) {\r\n                        listeners[eventType] = handlers.filter((handler => handler !== handlerToRemove));\r\n                    } else {\r\n                        listeners[eventType] = [];\r\n                    }\r\n                }\r\n            } else {\r\n                objectIterator(listeners, (_array, eventType) => {\r\n                    listeners[eventType] = [];\r\n                });\r\n            }\r\n        }\r\n    }\r\n}","import { PRESET_BUTTON_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK } from \"../constants/globals\";\r\nimport { Binder } from \"../core/events/binder\";\r\nimport { body, createButton, getElement, removeElement, replaceElement, toggleClassName } from \"../utils/dom\";\r\nimport { isString } from \"../utils/string\";\r\nimport { isset } from \"../utils/util\";\r\n\r\n/**\r\n * Creates the reference control.\r\n *\r\n * @param {string|Element} reference - User Reference.\r\n * @param {Alwan} param1 - Alwan instance.\r\n * @returns {object} - ReferenceElement control.\r\n */\r\nexport const Reference = (reference, alwan) => {\r\n\r\n    /**\r\n     * Reference element classes.\r\n     */\r\n    let classes = [];\r\n\r\n    /**\r\n     * Event binder.\r\n     */\r\n    const events = Binder();\r\n\r\n    /**\r\n     * Body.\r\n     */\r\n    const bodyElement = body();\r\n\r\n    /**\r\n     * Reference element.\r\n     *\r\n     * @type {Element|null}\r\n     */\r\n    const element = getElement(reference);\r\n\r\n    /**\r\n     * User reference.\r\n     *\r\n     * Check if the reference element is valid.\r\n     */\r\n    const userReference = bodyElement.contains(element) && element !== bodyElement ? element : null;\r\n\r\n    /**\r\n     * Reference API.\r\n     */\r\n    const self = {\r\n        // If user reference is not valid element in the body, then create,\r\n        // a preset button and append it to the body.\r\n        _element: userReference ? userReference : createButton(PRESET_BUTTON_CLASSNAME, bodyElement),\r\n\r\n        /**\r\n         * Initialize Reference element.\r\n         *\r\n         * @param {object} param - Alwan options.\r\n         */\r\n        _init({ preset, classname }) {\r\n            let element = self._element;\r\n\r\n            // If the user reference is valid then replace it with the preset button,\r\n            // if preset option is true.\r\n            if (userReference && preset !== (userReference !== element)) {\r\n                // Clear events, element might be deleted.\r\n                events._unbindAll();\r\n\r\n                if (preset) {\r\n                    // Replace user reference with a preset button.\r\n                    element = replaceElement(createButton(PRESET_BUTTON_CLASSNAME, null, { id: userReference.id }), userReference);\r\n                } else {\r\n                    // Replace preset button with the user reference.\r\n                    element = replaceElement(userReference, element);\r\n                }\r\n\r\n                /**\r\n                 * Handles click.\r\n                 */\r\n                events._bind(element, CLICK, e => {\r\n                    alwan._components._app._toggle(alwan);\r\n                });\r\n            }\r\n\r\n            // Add custom classes to the preset button.\r\n            if (! userReference || preset && isString(classname)) {\r\n                // Remove previously add classes.\r\n                toggleClassName(element, classes, false);\r\n                classes = classname.split(/\\s+/);\r\n                // Add the new classname.\r\n                toggleClassName(element, classes, true);\r\n            }\r\n\r\n            self._element = element;\r\n        },\r\n\r\n        /**\r\n         * Disables/Enables Picker instance.\r\n         *\r\n         * @param {boolean} disabled - Disable/Enable.\r\n         */\r\n        _setDisabled(disabled) {\r\n            if (isset(disabled)) {\r\n                let { config, _components } = alwan;\r\n                let { shared, toggle } = config;\r\n                let toggler = _components._app._toggle;\r\n\r\n                config.disabled = self._element.disabled = !! disabled;\r\n\r\n                if (disabled) {\r\n                    toggler(alwan, false, true);\r\n                } else if (! shared && ! toggle) {\r\n                    toggler(alwan, true, true);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Destroy reference component.\r\n         */\r\n        _destroy() {\r\n            if (userReference) {\r\n                self._init({ preset: false });\r\n            } else {\r\n                self._element = removeElement(self._element);\r\n            }\r\n            events._unbindAll();\r\n        }\r\n    }\r\n\r\n    return self;\r\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ALWAN_CLASSNAME","CONTAINER_CLASSNAME","SWATCH_CLASSNAME","PRESET_BUTTON_CLASSNAME","COLLAPSE_CLASSNAME","ROOT","document","HTML","documentElement","BUTTON","OPEN","CLOSE","COLOR","CLICK","POINTER_DOWN","KEY_DOWN","INPUT","CHANGE","FOCUS_IN","HEX_FORMAT","RGB_FORMAT","HSL_FORMAT","HSV_FORMAT","COLOR_PROPERTY","COLOR_FORMATS","INSERT_BEFORE_FIRST_CHILD","isString","value","trimString","str","trim","Binder","eventListenersData","toggleEventListener","eventTarget","events","handler","toggler","forEach","event","_bind","push","_unbindAll","target","parseFloat","float","parseInt","int","isFinite","isNumeric","Number","min","max","abs","round","PI","Math","confineNumber","number","upperBound","lowerBound","normalizeAngle","angle","keys","assign","merge","setPrototypeOf","objectIterator","object","fn","props","isEqual","obj1","obj2","every","isset","body","getElement","reference","context","all","Element","insertElement","element","targetElement","where","insertAdjacentElement","setHTML","html","innerHTML","createElement","tagName","className","details","insertPosition","name","setAttribute","getBounds","x","y","top","left","right","clientWidth","bottom","clientHeight","getBoundingClientRect","parent","parentElement","replaceElement","newElement","oldElement","replaceChild","removeElement","remove","getScrollableAncestors","scrollables","test","getComputedStyle","overflow","setCustomProperty","property","style","setProperty","toggleVisibility","display","toggleClassName","tokens","token","classList","toggle","createButton","BUTTON_CLASSNAME","type","translate","transform","createSlider","step","SLIDER_CLASSNAME","TOP","BOTTOM","RIGHT","LEFT","START","CENTER","END","dimension","App","alwan","referenceElement","popper","scrollableAncestors","popperEvents","isOpen","_setup","options","instance","theme","popover","position","margin","id","shared","_components","_init","_reference","_element","dataset","_toggle","container","_margin","_position","coordinates","fallbackSides","fallbackAlignments","start","center","end","side","alignment","split","_update","domBounds","referenceBoundingRect","containerBoundingRect","some","referenceSide","axis","domBound","referenceBound","containerSpace","containerDimension","referenceLowerBound","referenceUpperBound","upperBoundDistance","offset","createPopper","window","updatePopper","scrollable","handleAccessibility","e","elementX","elementY","elementBottom","elementRight","scrollableX","scrollableY","scrollableBottom","scrollableRight","elementToFocusOn","lastFocusableElement","shiftKey","paletteElement","_palette","contains","labels","label","pop","preventDefault","focus","state","forced","disabled","config","_color","_updateAll","_reposition","_events","_dispatch","_root","_isOpen","_destroy","clipboardSVG","stringify","color","format","opaque","percentage","opacity","a","k","s","v","HSVToRGB","h","r","g","b","toHex","toString","RGBToHEX","HSVToHSL","l","ctx","getContext","HSL_REGEX","HEX_REGEX","ANGLE_COEFFICIENT_MAP","deg","turn","rad","grad","parseColor","asString","find","input","exec","fillStyle","hex","slice","map","_format","sharedComponents","instanceCount","createComponents","_app","markerX","markerY","paletteBounds","overlayElement","isPointerDown","palette","tabindex","marker","width","height","keyboardX","ArrowRight","ArrowLeft","keyboardY","ArrowDown","ArrowUp","moveMarkerAndUpdateColor","change","_saveState","clientX","clientY","_triggerChange","_options","Palette","_utility","previewElement","copyButton","isCopied","preview","copy","clipboard","navigator","_getColorByFormat","writeText","select","execCommand","blur","Utility","_sliders","alphaSlider","hueSlider","_setValue","Sliders","_inputs","inputsContainer","switchButton","formatIndex","inputsMap","formats","isChanged","inputs","filter","length","indexOf","build","includes","fields","singleInput","field","labelElement","_set","close","Inputs","_swatches","swatches","collapseButton","swatchesLength","isCollapsible","toggleSwatches","Array","isArray","_add","_remove","swatch","index","findIndex","children","splice","getPropertyValue","Swatches","isShared","components","destroyComponents","RGB","rgbString","HSV","colorData","asArray","reduce","output","channel","hsv","rgb","isInputs","source","isRGB","cMax","range","RGBToHSV","HSLToHSV","_value","hsl","initialize","app","useComponents","_setDisabled","defaults","classname","preset","default","Alwan","VERSION","constructor","this","listeners","_addListener","eventType","eventHandler","_removeListeners","handlerToRemove","handlers","_array","Dispatcher","classes","bodyElement","userReference","Reference","setOptions","open","on","off","setColor","getColor","addSwatch","removeSwatch","enable","disable","reset","reposition","trigger","destroy"],"sourceRoot":""}